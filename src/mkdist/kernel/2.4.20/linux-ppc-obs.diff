diff -Naru linux-2.4.20.orig/Rules.make linux-2.4.20/Rules.make
--- linux-2.4.20.orig/Rules.make	2002-12-11 11:39:22.000000000 +0900
+++ linux-2.4.20/Rules.make	2004-12-21 12:27:03.000000000 +0900
@@ -177,6 +177,8 @@
 ifneq "$(strip $(ALL_MOBJS))" ""
 	mkdir -p $(MODLIB)/kernel/$(MOD_DESTDIR)
 	cp $(sort $(ALL_MOBJS)) $(MODLIB)/kernel/$(MOD_DESTDIR)
+	${STRIP} -S $(MODLIB)/kernel/$(MOD_DESTDIR)*.o
+	gzip -9 $(MODLIB)/kernel/$(MOD_DESTDIR)*.o
 endif
 
 .PHONY: modules_install
diff -Naru linux-2.4.20.orig/arch/ppc/8xx_io/Config.in linux-2.4.20/arch/ppc/8xx_io/Config.in
--- linux-2.4.20.orig/arch/ppc/8xx_io/Config.in	2002-12-11 11:39:32.000000000 +0900
+++ linux-2.4.20/arch/ppc/8xx_io/Config.in	2004-12-21 12:27:03.000000000 +0900
@@ -15,6 +15,7 @@
   bool '860T FEC Ethernet' CONFIG_FEC_ENET
   if [ "$CONFIG_FEC_ENET" = "y" ]; then
     bool 'Use MDIO for PHY configuration' CONFIG_USE_MDIO
+    bool 'Configure FEC Ethernet before SCC Ethernet' CONFIG_FEC_ENET_BEFORE_SCC_ENET
   fi
   bool 'Use Big CPM Ethernet Buffers' CONFIG_ENET_BIG_BUFFERS
 fi
diff -Naru linux-2.4.20.orig/arch/ppc/8xx_io/enet.c linux-2.4.20/arch/ppc/8xx_io/enet.c
--- linux-2.4.20.orig/arch/ppc/8xx_io/enet.c	2002-12-11 11:38:33.000000000 +0900
+++ linux-2.4.20/arch/ppc/8xx_io/enet.c	2004-12-21 12:27:03.000000000 +0900
@@ -24,6 +24,10 @@
  * will be much more memory efficient and will easily handle lots of
  * small packets.
  *
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Replace bi_enetaddr to bi_enet1addr for OpenBlockS 50
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -812,7 +816,11 @@
 	 */
 	eap = (unsigned char *)&(ep->sen_paddrh);
 	for (i=5; i>=0; i--)
+#ifdef CONFIG_OBS50
+		*eap++ = dev->dev_addr[i] = bd->bi_enet1addr[i];
+#else
 		*eap++ = dev->dev_addr[i] = bd->bi_enetaddr[i];
+#endif
 
 	ep->sen_pper = 0;	/* 'cause the book says so */
 	ep->sen_taddrl = 0;	/* temp address (LSB) */
diff -Naru linux-2.4.20.orig/arch/ppc/8xx_io/fec.c linux-2.4.20/arch/ppc/8xx_io/fec.c
--- linux-2.4.20.orig/arch/ppc/8xx_io/fec.c	2002-12-11 11:40:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/8xx_io/fec.c	2004-12-21 12:27:03.000000000 +0900
@@ -26,15 +26,23 @@
  * Make use of MII for PHY control configurable.
  * Some fixes.
  * Copyright (c) 2000 Wolfgang Denk, DENX Software Engineering.
+ *
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Support for 78Q2120 PHY
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 
 /* List of PHYs we wish to support.
 */
 #undef	CONFIG_FEC_LXT970
-#define	CONFIG_FEC_LXT971
+#undef	CONFIG_FEC_LXT971
 #undef	CONFIG_FEC_QS6612
 #undef	CONFIG_FEC_DP83843
 #undef	CONFIG_FEC_DP83846A
+#ifdef	CONFIG_OBS50
+#define	CONFIG_FEC_78Q2120
+#endif
 
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -1024,10 +1032,68 @@
 	},
 };
 
-
 #endif /* CONFIG_FEC_QS6612 */
 
 
+#ifdef	CONFIG_FEC_78Q2120
+
+/* -------------------------------------------------------------------- */
+/* The TDK SEMICONDUCTOR CORP. 78Q2120 is used on OpenBlockS 50		*/
+/* -------------------------------------------------------------------- */
+
+#define MII_78Q2120_VENDOR	16	/* Vendor Specific Register  */
+#define MII_78Q2120_ICSR	17	/* Interrupt Control/Status Register */
+#define MII_78Q2120_DIAG	18	/* Diagnostic Register */
+
+static void mii_parse_78q2120_diag(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	/* DPLX, RATE */
+	switch((mii_reg >> 10) & 3) {
+		case 0: *s |= PHY_STAT_10HDX; break;
+		case 1: *s |= PHY_STAT_100HDX; break;
+		case 2: *s |= PHY_STAT_10FDX; break;
+		case 3: *s |= PHY_STAT_100FDX; break;
+	}
+}
+
+static phy_info_t phy_info_78q2120 = {
+	0x00300e54,
+	"78Q2120",
+
+	(const phy_cmd_t []) {  /* config */
+		{ mk_mii_write(MII_78Q2120_VENDOR, 0x0140), NULL },
+		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
+		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {  /* startup - enable interrupts */
+		/* Link Status Change Interrupt Enable */
+		{ mk_mii_write(MII_78Q2120_ICSR, 0x0400), NULL },
+		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int */
+		/* read SR and ICSR to acknowledge */
+		{ mk_mii_read(MII_78Q2120_ICSR), NULL },
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
+		/* find out the current status */
+		{ mk_mii_read(MII_78Q2120_DIAG), mii_parse_78q2120_diag },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {  /* shutdown - disable interrupts */
+		{ mk_mii_write(MII_78Q2120_ICSR, 0x0000), NULL },
+		{ mk_mii_end, }
+	},
+};
+
+#endif	/* CONFIG_FEC_78Q2120 */
+
+
 /* -------------------------------------------------------------------- */
 /* The National Semiconductor DP83843BVJE is used on a Mediatrix board  */
 /* -------------------------------------------------------------------- */
@@ -1176,6 +1242,10 @@
 	&phy_info_lxt971,
 #endif /* CONFIG_FEC_LXT971 */
 
+#ifdef CONFIG_FEC_78Q2120
+	&phy_info_78q2120,
+#endif /* CONFIG_FEC_78Q2120 */
+
 #ifdef CONFIG_FEC_QS6612
 	&phy_info_qs6612,
 #endif /* CONFIG_FEC_LXT971 */
@@ -1745,6 +1815,7 @@
 	eap = (unsigned char *)my_enet_addr;
 	iap = bd->bi_enetaddr;
 
+#ifndef CONFIG_OBS50
 #ifdef CONFIG_SCC_ENET
 	/*
          * If a board has Ethernet configured both on a SCC and the
@@ -1758,6 +1829,7 @@
 	tmpaddr[3] |= 0x80;
 	iap = tmpaddr;
 #endif
+#endif /* CONFIG_OBS50 */
 
 	for (i=0; i<6; i++) {
 		dev->dev_addr[i] = *eap++ = *iap++;
diff -Naru linux-2.4.20.orig/arch/ppc/8xx_io/uart.c linux-2.4.20/arch/ppc/8xx_io/uart.c
--- linux-2.4.20.orig/arch/ppc/8xx_io/uart.c	2002-12-11 11:40:02.000000000 +0900
+++ linux-2.4.20/arch/ppc/8xx_io/uart.c	2004-12-21 12:27:03.000000000 +0900
@@ -19,6 +19,11 @@
  * This module exports the following rs232 io functions:
  *
  *	int rs_8xx_init(void);
+ *
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Modified for OpenBlockS 50
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 
 #include <linux/config.h>
@@ -81,6 +86,13 @@
 #define CONFIG_SERIAL_CONSOLE_PORT	2
 #endif
 
+/* SCC1 for console
+*/
+#ifdef CONFIG_OBS50
+#undef CONFIG_SERIAL_CONSOLE_PORT
+#define CONFIG_SERIAL_CONSOLE_PORT	1
+#endif
+
 #define TX_WAKEUP	ASYNC_SHARE_IRQ
 
 static char *serial_name = "CPM UART driver";
@@ -160,8 +172,12 @@
   	{ 0,     0, PROFF_SMC2, CPMVEC_SMC2,   0,    1 },    /* SMC2 ttyS1 */
 # endif
 # ifdef CONFIG_USE_SCC_IO
+#  ifdef CONFIG_OBS50
+	{ 0,     0, PROFF_SCC1, CPMVEC_SCC1,   0,    (NUM_IS_SCC | 0) },    /* SCC1 ttyS1 */
+#  else
   	{ 0,     0, PROFF_SCC2, CPMVEC_SCC2,   0,    (NUM_IS_SCC | 1) },    /* SCC2 ttyS2 */
   	{ 0,     0, PROFF_SCC3, CPMVEC_SCC3,   0,    (NUM_IS_SCC | 2) },    /* SCC3 ttyS3 */
+#  endif /* CONFIG_OBS50 */
 # endif
   #else /* CONFIG_USB_xxx */
 # ifdef CONFIG_USE_SCC_IO
@@ -2633,11 +2649,18 @@
 	 */
 #ifdef CONFIG_USE_SCC_IO
 #ifndef CONFIG_MBX
+#ifdef CONFIG_OBS50
+	/* Port A for SCC1 serial port */
+	immap->im_ioport.iop_papar |=  0x0003;
+	immap->im_ioport.iop_padir &= ~0x0003;
+	immap->im_ioport.iop_paodr &= ~0x0003;
+#else
 	/* The "standard" configuration through the 860.
 	*/
 	immap->im_ioport.iop_papar |= 0x00fc;
 	immap->im_ioport.iop_padir &= ~0x00fc;
 	immap->im_ioport.iop_paodr &= ~0x00fc;
+#endif /* CONFIG_OBS50 */
 #else
 	/* On the MBX, SCC3 is through Port D.
 	*/
diff -Naru linux-2.4.20.orig/arch/ppc/boot/common/util.S linux-2.4.20/arch/ppc/boot/common/util.S
--- linux-2.4.20.orig/arch/ppc/boot/common/util.S	2002-12-11 11:37:59.000000000 +0900
+++ linux-2.4.20/arch/ppc/boot/common/util.S	2004-12-21 12:27:03.000000000 +0900
@@ -20,6 +20,9 @@
  * under  the terms of  the GNU General  Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added for OpenBlockS 50
  */
 
 #include <asm/processor.h>
@@ -153,6 +156,11 @@
 	blr
 
 .udelay_not_601:
+#ifdef CONFIG_OBS50
+	mulli	r4,r3,384
+	addi	r4,r4,125
+	li	r5,125
+#else
 	mulli	r4,r3,1000	/* nanoseconds */
 	/*  Change r4 to be the number of ticks using:	
 	 *	(nanoseconds + (timebase_period_ns - 1 )) / timebase_period_ns
@@ -161,6 +169,7 @@
 	lwz	r5,timebase_period_ns@l(r5)
 	addi	r4,r4,r5
 	addi	r4,r4,-1
+#endif
 	divw	r4,r4,r5	/* BUS ticks */
 1:	mftbu	r5
 	mftb	r6
diff -Naru linux-2.4.20.orig/arch/ppc/boot/simple/Makefile linux-2.4.20/arch/ppc/boot/simple/Makefile
--- linux-2.4.20.orig/arch/ppc/boot/simple/Makefile	2002-12-11 11:37:22.000000000 +0900
+++ linux-2.4.20/arch/ppc/boot/simple/Makefile	2004-12-21 12:27:03.000000000 +0900
@@ -13,6 +13,9 @@
 # under  the terms of  the GNU General  Public License as published by the
 # Free Software Foundation;  either version 2 of the  License, or (at your
 # option) any later version.
+#
+#	PlatHome <openlab.plathome.co.jp>
+#		- added for OpenBlockS 50
 
 USE_STANDARD_AS_RULE		:= true
 
@@ -146,6 +149,7 @@
 obj-$(CONFIG_MBX)		+= iic.o
 obj-$(CONFIG_RPXCLASSIC)	+= iic.o
 obj-$(CONFIG_RPXLITE)		+= iic.o
+obj-$(CONFIG_OBS50)		+= iic.o
 ifeq ($(CONFIG_XILINX_ML300),y)
 EXTRA_CFLAGS			+= -I$(TOPDIR)/arch/ppc/platforms/xilinx_ocp \
 					-I$(TOPDIR)/drivers/i2c/xilinx_iic
diff -Naru linux-2.4.20.orig/arch/ppc/boot/simple/embed_config.c linux-2.4.20/arch/ppc/boot/simple/embed_config.c
--- linux-2.4.20.orig/arch/ppc/boot/simple/embed_config.c	2002-12-11 11:37:52.000000000 +0900
+++ linux-2.4.20/arch/ppc/boot/simple/embed_config.c	2004-12-21 12:27:03.000000000 +0900
@@ -9,6 +9,15 @@
  * under  the terms of  the GNU General  Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Add the board information structure for Century's board
+ *	2001-12-25 ozawa CONFIG_OBSS
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Added for OpenBlockS 50
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 
 #include <linux/types.h>
@@ -24,6 +33,26 @@
 #ifdef CONFIG_40x
 #include <asm/io.h>
 #endif
+#ifdef CONFIG_OBS200
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+#include <asm/serial.h>
+#endif
+#ifdef CONFIG_OBS50
+#include <asm/spinlock.h>
+#include <linux/time.h>
+#include <linux/mc146818rtc.h>
+#include <asm/commproc.h>
+#endif
+
+#if defined(CONFIG_OBS200) || defined(CONFIG_OBS50)
+#ifdef CONFIG_SERIAL_CONSOLE_BAUD
+#define SERIAL_BAUD    CONFIG_SERIAL_CONSOLE_BAUD
+#else
+#define SERIAL_BAUD    9600
+#endif /* CONFIG_SERIAL_CONSOLE_BAUD */
+#endif /* CONFIG_OBS200 || CONFIG_OBS50 */
+
 extern unsigned long timebase_period_ns;
 
 /* For those boards that don't provide one.
@@ -629,6 +658,60 @@
 }
 #endif /* ADS8260 */
 
+#ifdef CONFIG_OBS50
+#define	M24C16_ADDR	0xa0
+#define	DS1307_ADDR	0xd0
+void
+embed_config(bd_t *bd)
+{
+	u_char  *cp;
+	int     i;
+	u_char		eebuf[128];
+	unsigned int	year, mon, day, hour, min, sec;
+	unsigned long	time;
+
+	/* get mac address from iic serial eeprom */
+	i = 0x780; /* last 128[byte] */
+	iic_read(M24C16_ADDR | (i >> 7), eebuf, i, 128);
+
+	cp = (u_char *)&eebuf[0x58];
+	for (i = 0; i < 6; i++)
+		bd->bi_enetaddr[i] = cp[i];
+
+	cp = (u_char *)&eebuf[0x5e];
+	for (i = 0; i < 6; i++)
+		bd->bi_enet1addr[i] = cp[i];
+
+	/* get time from iic serial rtc */
+	iic_read(DS1307_ADDR, eebuf, 0, 8);
+	sec = eebuf[0];
+	min = eebuf[1];
+	hour = eebuf[2];
+	day = eebuf[4];
+	mon = eebuf[5];
+	year = eebuf[6];
+	BCD_TO_BIN(sec);
+	BCD_TO_BIN(min);
+	BCD_TO_BIN(hour);
+	BCD_TO_BIN(day);
+	BCD_TO_BIN(mon);
+	BCD_TO_BIN(year);
+	year += ((year >= 70) ? 1900 : 2000);
+	time = mktime(year, mon, day, hour, min, sec);
+	((volatile immap_t *)IMAP_ADDR)->im_sitk.sitk_rtck = KAPWR_KEY;
+	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_rtc = time;
+	((volatile immap_t *)IMAP_ADDR)->im_sitk.sitk_rtck = ~KAPWR_KEY;
+
+	/* The rest of this should come from the environment as well.
+	*/
+	bd->bi_memstart = 0;
+	bd->bi_memsize = (16 * 1024 * 1024);
+	bd->bi_intfreq = 49152000;
+	bd->bi_busfreq = 49152000;
+	bd->bi_baudrate = SERIAL_BAUD;
+}
+#endif /* CONFIG_OBS50 */
+
 #ifdef CONFIG_WILLOW
 void
 embed_config(bd_t **bdp)
@@ -858,6 +941,46 @@
 }
 #endif /* CONFIG_XILINX_ML300 */
 
+#if defined(CONFIG_OBS200)
+
+extern void (outb)(int port, unsigned char val);
+
+void
+embed_config(bd_t **bdp)
+{
+	bd_t	*bd;
+
+	bd = &bdinfo;
+	*bdp = bd;
+
+	switch (*OBSS_RAM_SIZE) {
+		case 4: case 8: case 16: case 32: case 64: case 128:
+			bd->bi_memsize = *OBSS_RAM_SIZE * 0x00100000; break;
+		default:
+			bd->bi_memsize = 64 * 0x00100000;	/* assume 64MB */
+	}
+	bd->bi_intfreq = 0x0bebc200;				/* 200MHz */
+	bd->bi_busfreq = 0x05f5e100;				/* 100MHz */
+	bd->bi_pci_busfreq = 0x01f78a40;			/*  33MHz */
+	bd->bi_enetaddr[0] = OBSS_ENET_MACADDR[0];
+	bd->bi_enetaddr[1] = OBSS_ENET_MACADDR[1];
+	bd->bi_enetaddr[2] = OBSS_ENET_MACADDR[2];
+	bd->bi_enetaddr[3] = OBSS_ENET_MACADDR[3];
+	bd->bi_enetaddr[4] = OBSS_ENET_MACADDR[4];
+	bd->bi_enetaddr[5] = OBSS_ENET_MACADDR[5];
+
+	/* preinit UART0 */
+	/* Input clock. */
+	(outb)(UART0_IO_BASE+UART_LCR, 0x80);
+	(outb)(UART0_IO_BASE+UART_DLL, (BASE_BAUD / SERIAL_BAUD));
+	(outb)(UART0_IO_BASE+UART_DLM, (BASE_BAUD / SERIAL_BAUD) >> 8);
+	/* 8 data, 1 stop, no parity */
+	(outb)(UART0_IO_BASE+UART_LCR, 0x03);
+	/* RTS/DTR */
+	(outb)(UART0_IO_BASE+UART_MCR, 0x03);
+}
+#else /* CONFIG_OBS200 */
+
 #ifdef CONFIG_IBM_OPENBIOS
 /* This could possibly work for all treeboot roms.
 */
@@ -940,6 +1063,7 @@
 }
 #endif /* CONFIG_BEECH */
 #endif /* CONFIG_IBM_OPENBIOS */
+#endif /* CONFIG_OBS200 */
 
 #ifdef CONFIG_EP405
 #include <linux/serial_reg.h>
diff -Naru linux-2.4.20.orig/arch/ppc/boot/simple/m8xx_tty.c linux-2.4.20/arch/ppc/boot/simple/m8xx_tty.c
--- linux-2.4.20.orig/arch/ppc/boot/simple/m8xx_tty.c	2002-12-11 11:39:49.000000000 +0900
+++ linux-2.4.20/arch/ppc/boot/simple/m8xx_tty.c	2004-12-21 12:27:03.000000000 +0900
@@ -12,6 +12,11 @@
  * Later versions (at least 1.4, maybe earlier) of the MBX EPPC-Bug
  * use COM1 instead of SMC1 as the console port.  This kinda sucks
  * for the rest of the kernel, so here we force the use of SMC1 again.
+ *
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Added for OpenBlockS 50
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 #include <linux/config.h>
 #include <linux/types.h>
@@ -19,6 +24,7 @@
 #include <asm/mpc8xx.h>
 #include <asm/commproc.h>
 
+#ifndef CONFIG_OBS50
 #ifdef CONFIG_MBX
 #define MBX_CSR1	((volatile u_char *)0xfa100000)
 #define CSR1_COMEN	(u_char)0x02
@@ -298,3 +304,300 @@
 serial_close(unsigned long com_port)
 {
 }
+
+#else /* CONFIG_OBS50 */
+
+#define PROFF_CONS	PROFF_SCC1
+#define CPM_CR_CH_CONS	CPM_CR_CH_SCC1
+#define SCC_INDEX	0
+
+/*
+ * for OpenBlockS 50 
+ *
+ *	input:
+ *		MODCK[1-2] = "11"	... x5 clock mode(default)
+ *		EXTCLK     = 4.096 [MHz]
+ *	result:
+ *		OSCCLK     = 4.096 [MHz]
+ *		VCOOUT     = 49.152 [MHz] = OSCCLK x (11 + 1)
+ *		GCLK1/2/C  = 49.152 [MHz]
+ *		GCLK1/2_50 = 49.152 [MHz]
+ *		CLKOUT     = 49.152 [MHz]
+ *		BRGCLK     = 49.152 [MHz]
+ *		SYNCCLK    = 49.152 [MHz]
+ *		TMBCLK     =  3.072 [MHz] = GCLK2 / 16
+ *		PITRTCLK   =  8.000 [kHz] = EXTCLK / 512
+ */
+static void
+init_cpm(bd_t *bd)
+{
+	volatile	cpm8xx_t	*cp;
+	volatile	immap_t		*immap;
+	
+	immap = (immap_t *)IMAP_ADDR;
+	cp = (cpm8xx_t *)&(immap->im_cpm);
+
+	/* CPM reset already done in iic_read() */
+#if 0
+	cp->cp_cpcr = 0x8001;
+#endif
+
+	/* SCC1 for serial port. */
+
+	/* Port A for SCC1 serial port. */
+	immap->im_ioport.iop_paodr &=  ~0x0003;
+	immap->im_ioport.iop_padir &=  ~0x0003;
+	immap->im_ioport.iop_papar |=   0x0003;
+
+	/* Port B */
+#if 0
+	cp->cp_pbodr  =  0;
+#endif
+	cp->cp_pbdat  =  0x3c00b;
+	cp->cp_pbdir |=  0x3c00f;	/* I/O port. 7-SEG LED output */
+	cp->cp_pbpar &= ~0x3c00f;
+
+	/* Port C */
+#if 0
+	immap->im_ioport.iop_pcdat = 0;
+#endif
+	immap->im_ioport.iop_pcdir &= ~0x030;
+#if 0
+	immap->im_ioport.iop_pcint = 0;
+#endif
+	immap->im_ioport.iop_pcso  &= ~0x030;
+	immap->im_ioport.iop_pcpar &= ~0x030;
+
+	/* BRG */
+
+	cp->cp_brgc1 =
+		((((bd->bi_intfreq /** 1000000*/)/16)/ bd->bi_baudrate) << 1)
+		| CPM_BRG_EN;
+
+	/* Enable SDMA. */
+	immap->im_sdma.sdma_sdsr = 0x83;
+	immap->im_siu_conf.sc_sdcr = 0x00000001;
+
+	/*
+	 * SI Global Mode Register
+	 *	ENB (4)		= 0	...disable TDMb
+	 *	ENA (5)		= 0	...disable TDMa
+	 *	RDM (6-7)	= 0	...RAM division mode.Static.
+	 */
+	cp->cp_sigmr = 0;
+
+	/*
+	 * Set the value of SI Mode Register
+	 *	SMC2,SMC2CS,SDMb,RFSDb          (0-7)   = 0 000(BRG1) 00 00
+	 *	DSCb,CRTb,STZb,CEb,FEb,GMb,TFSDb(8-15)  = 000000 00
+	 *	SMC1,SMC1CS,SDMa,RFSDa          (16-23) = 0 000(BRG1) 00 00
+	 *	DSCa,CRTa,STZa,CEa,FEa,GMa,TFSDa(24-31) = 000000 00
+	 */
+	cp->cp_simode = 0x00000000;
+
+	/*
+	 * SI Clock Route Register
+	 *	GR4,SC4,R4CS,T4CS(0-7)		= 00 000 000 (BRG1:BRG1)
+	 *	GR3,SC3,R3CS,T3CS(8-15)		= 00 000 000 (BRG1:BRG1)
+	 *	GR2,SC2,R2CS,T2CS(16-23)	= 00 000 000 (BRG1:BRG1)
+	 *	GR1,SC1,R1CS,T1CS(24-31)	= 00 000 000 (BRG1:BRG1)
+	 */
+	cp->cp_sicr = 0x0;	/* FIXME */
+}
+
+static void
+init_scc1uart(void)
+{
+	uint		dp_addr, mem_addr;
+	volatile	cbd_t		*bdp;
+	volatile	cpm8xx_t	*cp;
+	volatile	scc_t		*scp;
+	volatile	scc_uart_t	*sup;
+#if 0
+	cp = cpmp;	/* Get pointer to Communication Processor */
+#endif
+	cp = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+
+	scp = &cp->cp_scc[SCC_INDEX];
+	sup = (scc_uart_t *)&cp->cp_dparam[PROFF_CONS];
+
+	/* Allocate space for two buffer descriptors in the DP ram. */
+	dp_addr = 0x0800;	/* m8xx_cpm_dpalloc(sizeof(cbd_t) * 2); */
+	
+	/* Allocate space for two 2 byte FIFOs in the host memory. */
+	mem_addr = 0x880;	/* m8xx_cpm_hostalloc(8); */
+
+	/* Set the physical address of the host memory buffers 
+	 * in the buffer descriptors.
+	 */
+	bdp = (cbd_t *)&cp->cp_dpmem[dp_addr];
+
+#if 0
+	dp->cbd_bufaddr = __pa(mem_addr);
+	(bdp+1)->cbd_bufaddr = __pa(mem_addr+4);
+#endif
+	bdp->cbd_bufaddr = mem_addr;
+	(bdp+1)->cbd_bufaddr = mem_addr+4;
+
+	/* For the receive, set empty and wrap. For transmit, set wrap. */
+	bdp->cbd_sc = BD_SC_EMPTY | BD_SC_WRAP;
+	(bdp+1)->cbd_sc = BD_SC_WRAP;
+
+	/* Set up the uart parameters in the parameter ram. */
+	sup->scc_genscc.scc_rbase = dp_addr;
+	sup->scc_genscc.scc_tbase = dp_addr + sizeof(cbd_t);
+
+	/* Set up the uart parameters in the parameter ram. */
+	sup->scc_genscc.scc_rfcr = SMC_EB;
+	sup->scc_genscc.scc_tfcr = SMC_EB;
+
+	/* Set this to 1 for now, so we get single
+	 * character interrupts.  Using idle charater
+	 * time requires some additional tuning.
+	 */
+	sup->scc_genscc.scc_mrblr = 1;
+	sup->scc_maxidl = 0;
+	sup->scc_brkcr = 1;
+	sup->scc_parec = 0;
+	sup->scc_frmec = 0;
+	sup->scc_nosec = 0;
+	sup->scc_brkec = 0;
+	sup->scc_uaddr1 = 0;
+	sup->scc_uaddr2 = 0;
+	sup->scc_toseq = 0;
+	sup->scc_char1 = 0x8000;
+	sup->scc_char2 = 0x8000;
+	sup->scc_char3 = 0x8000;
+	sup->scc_char4 = 0x8000;
+	sup->scc_char5 = 0x8000;
+	sup->scc_char6 = 0x8000;
+	sup->scc_char7 = 0x8000;
+	sup->scc_char8 = 0x8000;
+	sup->scc_rccm = 0xc0ff;
+
+	/* Send the CPM an initialize command. */
+	cp->cp_cpcr = mk_cr_cmd(CPM_CR_CH_CONS, CPM_CR_INIT_TRX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG) {
+		*(volatile unsigned long *)0xff000ac4 ^= 2;
+	}
+	
+	/* Set UART mode, 8 bit, no parity, one stop.
+	 * Enable receive and transmit.
+	 */
+	scp->scc_gsmrh = 0;
+	scp->scc_gsmrl =
+		(SCC_GSMRL_MODE_UART | SCC_GSMRL_TDCR_16 | SCC_GSMRL_RDCR_16);
+
+	/* Disable all interrupts and clear all pending events. */
+	scp->scc_sccm = 0;
+	scp->scc_scce = 0xffff;
+	scp->scc_dsr = 0x7e7e;
+	scp->scc_pmsr = 0x3000;
+
+	scp->scc_gsmrl |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);
+}
+
+void
+serial_putc(void *ignored, const char c)
+{
+	volatile cbd_t		*bdp;
+	volatile cpm8xx_t	*cp;
+	volatile scc_uart_t	*sup;
+#if 0
+	if (c == '\n')
+		serial_putc(0, '\r');
+#endif
+	cp  = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+	sup = (scc_uart_t *)&cp->cp_dparam[PROFF_CONS];
+	bdp = (cbd_t *)&cp->cp_dpmem[sup->scc_genscc.scc_tbase];
+
+	/* Wait for last character to go. */
+	while (bdp->cbd_sc & BD_SC_READY)
+		;
+	*((char *)bdp->cbd_bufaddr) = c;
+	bdp->cbd_datlen = 1;
+	bdp->cbd_sc |= BD_SC_READY;
+}
+
+char
+serial_getc(void *ignored)
+{
+	volatile cbd_t		*rbdf;
+	volatile cpm8xx_t	*cp;
+	volatile scc_uart_t	*sup;
+	volatile char		*buf;
+	char			c;
+
+	cp  = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+	sup = (scc_uart_t *)&cp->cp_dparam[PROFF_CONS];
+	rbdf = (cbd_t *)&cp->cp_dpmem[sup->scc_genscc.scc_rbase];
+
+	/* Wait for character to show up. */
+	buf = (char *)rbdf->cbd_bufaddr;
+	while (rbdf->cbd_sc & BD_SC_EMPTY)
+		;
+	c = *buf;
+	rbdf->cbd_sc |= BD_SC_EMPTY;
+	
+	return c;
+}
+
+int
+serial_tstc(void *ignored)
+{
+	volatile cbd_t		*rbdf;
+	volatile cpm8xx_t	*cp;
+	volatile scc_uart_t	*sup;
+
+	cp  = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+	sup = (scc_uart_t *)&cp->cp_dparam[PROFF_CONS];
+	rbdf = (cbd_t *)&cp->cp_dpmem[sup->scc_genscc.scc_rbase];
+
+	return !(rbdf->cbd_sc & BD_SC_EMPTY);
+}
+
+void puthex(unsigned long val);
+
+void
+serial_init(bd_t *bd)
+{
+	volatile immap_t	*immap;
+
+	immap = (immap_t *)IMAP_ADDR;
+
+	/* siu initial */
+
+	/* TBS, RTDIV and RTSEL */
+	immap->im_clkrst.car_sccr = 0x03800000;
+	/* MF = 11 */
+	immap->im_clkrst.car_plprcr = 11 * (0x80000000 >> 11);
+	/* SWTC max, BMT max, BME, SWRI and SWP */
+	immap->im_siu_conf.sc_sypcr = 0xFFFF0000 | 0xFF00 | 0x83;
+	immap->im_sit.sit_tbscr = TBSCR_TBE;	/* for udelay() */
+
+	/* for boot time console */
+	init_cpm(bd);
+	init_scc1uart();	/* use SCC1 port as UART */
+
+	/* CPM Interrupt Configuration */
+	immap->im_cpic.cpic_cicr =
+		(CICR_SCD_SCC4 | CICR_SCC_SCC3 | CICR_SCB_SCC2 | CICR_SCA_SCC1) |
+		 ((5/2) << 13) | CICR_HP_MASK;
+	immap->im_cpic.cpic_cimr = 0;
+	immap->im_cpic.cpic_cipr = 0x00000000;
+	immap->im_cpic.cpic_cisr = 0xFFFFFFFF;
+
+	serial_putc(0, '\n');
+	serial_putc(0, '\n');
+}
+
+void
+serial_close(unsigned long com_port)
+{
+}
+
+#endif /* CONFIG_OBS50 */
+
+	
+	
+
diff -Naru linux-2.4.20.orig/arch/ppc/boot/simple/misc-embedded.c linux-2.4.20/arch/ppc/boot/simple/misc-embedded.c
--- linux-2.4.20.orig/arch/ppc/boot/simple/misc-embedded.c	2002-12-11 11:40:29.000000000 +0900
+++ linux-2.4.20/arch/ppc/boot/simple/misc-embedded.c	2004-12-21 12:27:03.000000000 +0900
@@ -12,6 +12,15 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  *
+ *	Century <www.centurysys.co.jp>
+ *		- Set the root file system and board memory size
+ *		- Move command line args higher on memory for larger kernels
+ *	2001-12-25 ozawa CONFIG_OBSS
+ *	2002-03-21 ozawa restructuring for OpenBlockSS
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *		- Added for OpenBlockS 50
+ *		- Added for OpenBlockS 266
  */
 
 #include <linux/config.h>
@@ -21,10 +30,17 @@
 #include <asm/ibm4xx.h>
 #include <asm/mmu.h>
 #include <asm/mpc8xx.h>
+#ifdef CONFIG_OBS50
+#include <asm/8xx_immap.h>
+#endif
 #include <asm/mpc8260.h>
 #include <asm/page.h>
 #include <asm/processor.h>
 #include <asm/residual.h>
+#if defined(CONFIG_OBS200)
+#include <asm/segled_obs200.h>
+#define OPNT ((volatile unsigned char *)(0x40000000))
+#endif
 
 #include "nonstdio.h"
 #include "zlib.h"
@@ -59,8 +75,61 @@
 #ifdef CONFIG_CMDLINE_BOOL
 char compiled_string[] = CONFIG_CMDLINE;
 #endif
+#ifdef CONFIG_OBS50
+char ramroot_string[] = "root=/dev/ram ramdisk_size=6400";
+char hdroot_string[] = "root=/dev/hda1";
+#else
 char ramroot_string[] = "root=/dev/ram";
+#endif
+#ifdef CONFIG_OBS200
+char netroot_string[] = "root=/dev/hda1";
+#else
 char netroot_string[] = "root=/dev/nfs rw ip=on";
+#endif
+
+#ifdef CONFIG_OBS266
+char eeprom_root_string[30] = { 0 };
+static int get_root_parameter(bd_t *b, char *str)
+{
+	int i;
+	char *p = str;
+
+	if (b == NULL) return 1;	/* something error */
+
+#if 0	/* for debug */
+	puts("\n[");
+	for (i = 0; i < sizeof(b->bi_r_version); i++) {
+		puts(" ");
+		puthex(b->bi_r_version[i]);
+	}
+	puts("]\n");
+#endif
+	for (i = 0; i < sizeof(b->bi_r_version); i++) {
+		if (b->bi_r_version[i] == '\0') goto found;
+	}
+	return 2;	/* no null termination */
+found:
+	*p = '\0';
+	for (i += 1; i < sizeof(b->bi_r_version); i++) {
+		*p++ = b->bi_r_version[i];
+		if (b->bi_r_version[i] == '\0') {
+			if (p == str) return 3; /* Maybe old ROM Monitor... */
+			return 0;	/* OK */
+		}
+	}
+	return 4;	/* too long */
+}
+
+static int is_pushsw(bd_t *b)
+{
+#define PUSHSW_INT	26
+	if (mfdcr(DCRN_UIC_SR(UIC0)) & (1 << (31 - PUSHSW_INT))) {
+		b->bi_s_version[0] = '\0';
+		return 1;
+	}
+	return 0;
+}
+#endif
 
 /* Serial port to use. */
 unsigned long com_port;
@@ -76,6 +145,12 @@
 extern void flush_instruction_cache(void);
 extern void gunzip(void *, int, unsigned char *, int *);
 extern void embed_config(bd_t **bp);
+#ifdef CONFIG_OBS200
+extern void _printk(char const *fmt, ...);
+#endif
+#ifdef CONFIG_OBS50
+extern void serial_close(unsigned long com_port);
+#endif
 
 unsigned long
 decompress_kernel(unsigned long load_addr, int num_words, unsigned long cksum, bd_t *bp)
@@ -88,9 +163,39 @@
 	 * initialize the serial console port.
 	 */
 	embed_config(&bp);
+#if defined(CONFIG_OBS200)
+	/* Display a zero */
+	*OPNT = (unsigned char)~(SL_V0);
+#endif
 #ifdef CONFIG_SERIAL_CONSOLE
 	com_port = serial_init(0, bp);
 #endif
+#ifdef CONFIG_OBS200
+	_printk("[decompress_kernel] Ramsize %dMB (0x%08x)\n",
+		bp->bi_memsize/0x00100000, bp->bi_memsize);
+#ifdef CONFIG_CMDLINE_BOOL
+	initrd_size = 0;
+#else
+	switch (*OBSS_BOOT_MODE) {
+		case 0:
+			puts("[decompress_kernel] Entering initrd mode. Root FS: ram disk\n");
+			initrd_size = (unsigned long)(&__ramdisk_end)
+				- (unsigned long)(&__ramdisk_begin);
+			bp->bi_r_version[0] = 0x01;
+			break;
+		case 1:
+			puts("[decompress_kernel] Entering hard disk mode. Root FS: hard disk\n");
+			initrd_size = 0;
+			bp->bi_r_version[0] = 0x00;
+			break;
+		default:
+			puts("[decompress_kernel] Entering recover mode. Root FS: ram disk\n");
+			initrd_size = (unsigned long)(&__ramdisk_end)
+				- (unsigned long)(&__ramdisk_begin);
+			bp->bi_r_version[0] = 0x00;
+	}
+#endif	/* CONFIG_CMDLINE_BOOL */
+#endif	/* CONFIG_OBS200 */
 
 	/* copy board data */
 	if (bp)
@@ -130,8 +235,10 @@
 	zimage_size = (unsigned long)(&__image_end) -
 			(unsigned long)(&__image_begin);
 
+#ifndef CONFIG_OBS200
 	initrd_size = (unsigned long)(&__ramdisk_end) -
 		(unsigned long)(&__ramdisk_begin);
+#endif
 
 	/*
 	 * The zImage and initrd will be between start and _end, so they've
@@ -156,7 +263,9 @@
 
 	puts("avail ram:     "); puthex((unsigned long)avail_ram); puts(" ");
 	puthex((unsigned long)end_avail); puts("\n");
+#ifndef CONFIG_OBS50
 	puts("\nLinux/PPC load: ");
+#endif
 	cp = cmd_line;
 	/* This is where we try and pick the right command line for booting.
 	 * If we were given one at compile time, use it.  It Is Right.
@@ -166,10 +275,47 @@
 #ifdef CONFIG_CMDLINE_BOOL
 	memcpy (cmd_line, compiled_string, sizeof(compiled_string));
 #else
+#ifdef CONFIG_OBS50
+	/* DipSW setup */
+	((immap_t *)IMAP_ADDR)->im_ioport.iop_papar &= ~0xc000;
+	((immap_t *)IMAP_ADDR)->im_ioport.iop_padir &= ~0xc000;
+
+	if (initrd_size) {
+		/*
+		 * Kernel command line select by DipSW.
+		 * hdroot or ramroot.
+		 */
+		puts("check dipsw:   ");
+		if ((((immap_t *)IMAP_ADDR)->im_ioport.iop_padat & 0xc000) != 0x0000) {
+			puts("hdroot\n");
+			memcpy (cmd_line, hdroot_string, sizeof(hdroot_string));
+		} else {
+			puts("ramroot\n");
+			memcpy (cmd_line, ramroot_string, sizeof(ramroot_string));
+		}
+	} else {
+		/*
+		 * Not initrd, pick up hdroot.
+		 * FIXME: I want nfsroot.
+		 */
+		memcpy (cmd_line, hdroot_string, sizeof(hdroot_string));
+	}
+#else
 	if ( initrd_size )
 		memcpy (cmd_line, ramroot_string, sizeof(ramroot_string));
 	else
 		memcpy (cmd_line, netroot_string, sizeof(netroot_string));
+#endif /* CONFIG_OBS50 */
+#endif
+#ifdef CONFIG_OBS50
+	puts("\nLinux/PPC load: ");
+#endif
+#ifdef CONFIG_OBS266
+	if (!is_pushsw(hold_residual) && get_root_parameter(bp, eeprom_root_string) == 0) {
+		int len = strlen(eeprom_root_string);
+		memcpy (cmd_line, "root=/dev/", 10);
+		memcpy (cmd_line + 10, eeprom_root_string, len + 1);
+	}
 #endif
 	while ( *cp )
 		putc(*cp++);
@@ -178,7 +324,12 @@
 	 * If they have a console, allow them to edit the command line.
 	 * Otherwise, don't bother wasting the five seconds.
 	 */
-	while (timer++ < 5*1000) {
+#ifdef CONFIG_OBS266
+#define BOOT_WAIT_TIME (400)	/* real 2sec */
+#else
+#define BOOT_WAIT_TIME (5*1000)
+#endif
+	while (timer++ < BOOT_WAIT_TIME) {
 		if (tstc()) {
 			while ((ch = getc()) != '\n' && ch != '\r') {
 				if (ch == '\b' || ch == '\177') {
@@ -207,6 +358,10 @@
 
 	gunzip(0, 0x400000, zimage_start, &zimage_size);
 	flush_instruction_cache();
+#if defined(CONFIG_OBS200)
+	/* Display a one */
+	*OPNT = (unsigned char)~(SL_V1);
+#endif
 	puts("done.\n");
 	{
 		struct bi_record *rec;
diff -Naru linux-2.4.20.orig/arch/ppc/config.in linux-2.4.20/arch/ppc/config.in
--- linux-2.4.20.orig/arch/ppc/config.in	2002-12-11 11:37:22.000000000 +0900
+++ linux-2.4.20/arch/ppc/config.in	2004-12-21 12:27:03.000000000 +0900
@@ -3,6 +3,12 @@
 # For a description of the syntax of this configuration file,
 # see Documentation/kbuild/config-language.txt.
 #
+#	PlatHome <openlab.plathome.co.jp>
+#		- Added CONFIG_OBS50
+#		- Added CONFIG_OBS2xx
+#		- Added CONFIG_OBS200
+#		- Added CONFIG_OBS266
+#
 define_bool CONFIG_UID16 n
 define_bool CONFIG_RWSEM_GENERIC_SPINLOCK n
 define_bool CONFIG_RWSEM_XCHGADD_ALGORITHM y
@@ -79,6 +85,8 @@
 	 CPCI405	CONFIG_CPCI405 		\
 	 EP405/EP405PC	CONFIG_EP405 		\
 	 Oak		CONFIG_OAK 		\
+	 OpenBlockS200	CONFIG_OBS200		\
+	 OpenBlockS266	CONFIG_OBS266		\
 	 Rainier	CONFIG_RAINIER		\
 	 Redwood-4	CONFIG_REDWOOD_4 	\
 	 Redwood-5	CONFIG_REDWOOD_5 	\
@@ -86,7 +94,7 @@
 	 Sycamore	CONFIG_SYCAMORE		\
 	 Tivo		CONFIG_TIVO 		\
 	 Walnut		CONFIG_WALNUT		\
-	 Xilinx-ML300	CONFIG_XILINX_ML300"	Walnut
+	 Xilinx-ML300	CONFIG_XILINX_ML300"	OpenBlockS266
 
    if [ "$CONFIG_EP405" = "y" ]; then
       bool 'EP405PC Support' CONFIG_EP405PC
@@ -130,7 +138,8 @@
 	 CCM		CONFIG_CCM		\
 	 LANTEC		CONFIG_LANTEC		\
 	 MBX		CONFIG_MBX		\
-	 WinCept	CONFIG_WINCEPT"		RPX-Lite
+	 WinCept	CONFIG_WINCEPT		\
+	 OpenBlockS50	CONFIG_OBS50"		OpenBlockS50
 
   if [ "$CONFIG_TQM823L" = "y" -o \
        "$CONFIG_TQM850L" = "y" -o \
@@ -289,6 +298,30 @@
     define_bool CONFIG_403GCX y
     define_bool CONFIG_IBM_OPENBIOS y
   fi
+  if [ "$CONFIG_EBK405GPR" = "y" ]; then
+    define_bool CONFIG_405GP y
+    define_bool CONFIG_BIOS_FIXUP y
+    define_bool CONFIG_IBM_OPENBIOS y
+    define_bool CONFIG_IBM405_ERR77 y
+    define_bool CONFIG_IBM_OCP y
+  fi
+  if [ "$CONFIG_OBS200" = "y" ]; then
+    define_bool CONFIG_405GP y
+    define_bool CONFIG_BIOS_FIXUP y
+    define_bool CONFIG_IBM_OPENBIOS y
+    define_bool CONFIG_IBM405_ERR77 y
+    define_bool CONFIG_IBM_OCP y
+    define_bool CONFIG_OBS2xx y
+    define_int CONFIG_SERIAL_CONSOLE_BAUD 9600
+  fi
+  if [ "$CONFIG_OBS266" = "y" ]; then
+    define_bool CONFIG_405GP y
+    define_bool CONFIG_BIOS_FIXUP y
+    define_bool CONFIG_IBM_OPENBIOS y
+    define_bool CONFIG_IBM405_ERR77 y
+    define_bool CONFIG_IBM_OCP y
+    define_bool CONFIG_OBS2xx y
+  fi
   if [ "$CONFIG_REDWOOD_4" = "y" -o "$CONFIG_REDWOOD_5" = "y" \
   	-o "$CONFIG_REDWOOD_6" = "y" ]; then
     define_bool CONFIG_STB03xxx y
@@ -348,6 +381,11 @@
 if [ "$CONFIG_8xx" = "y" -o "$CONFIG_8260" = "y" ]; then
     define_bool CONFIG_EMBEDDEDBOOT y
 fi
+if [ "$CONFIG_8xx" = "y" ]; then
+  if [ "$CONFIG_OBS50" = "y" ]; then
+    	define_int CONFIG_SERIAL_CONSOLE_BAUD 9600
+  fi
+fi
 endmenu
 
 mainmenu_option next_comment
diff -Naru linux-2.4.20.orig/arch/ppc/configs/ebk405gpr_defconfig linux-2.4.20/arch/ppc/configs/ebk405gpr_defconfig
--- linux-2.4.20.orig/arch/ppc/configs/ebk405gpr_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/configs/ebk405gpr_defconfig	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,538 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+# CONFIG_UID16 is not set
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Platform support
+#
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_440 is not set
+# CONFIG_POWER3 is not set
+# CONFIG_8xx is not set
+# CONFIG_PPC_ISERIES is not set
+CONFIG_4xx=y
+# CONFIG_PPC_STD_MMU is not set
+# CONFIG_ASH is not set
+# CONFIG_CEDER is not set
+# CONFIG_BEECH is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_RAINIER is not set
+# CONFIG_REDWOOD_4 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_TIVO is not set
+# CONFIG_WALNUT is not set
+CONFIG_EBK405GPR=y
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_ALL_PPC is not set
+# CONFIG_SMP is not set
+# CONFIG_MATH_EMULATION is not set
+CONFIG_405GP=y
+CONFIG_BIOS_FIXUP=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM_OCP=y
+# CONFIG_PM is not set
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_GEN550_KGDB=y
+CONFIG_IBM405_ERR51=y
+CONFIG_NOT_COHERENT_CACHE=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_OCP_PROC=y
+
+#
+# General setup
+#
+# CONFIG_HIGHMEM is not set
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_PCI=y
+# CONFIG_PC_KEYBOARD is not set
+CONFIG_NET=y
+CONFIG_SYSCTL=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_KCORE_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_KERNEL_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_PCI_NAMES is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+CONFIG_PPC_RTC=y
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+# CONFIG_IDE is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MACE is not set
+# CONFIG_BMAC is not set
+# CONFIG_GMAC is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Backplane Networking
+#
+# CONFIG_NPNET is not set
+
+#
+# On-chip net devices
+#
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Console drivers
+#
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL=y
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_IBM_OCP is not set
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_PROC is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+CONFIG_IBM_OCP_GPIO=y
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# IBM 4xx options
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Library routines
+#
+# CONFIG_ZLIB_INFLATE is not set
+# CONFIG_ZLIB_DEFLATE is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_SERIAL_TEXT_DEBUG=y
diff -Naru linux-2.4.20.orig/arch/ppc/configs/openblocks200_defconfig linux-2.4.20/arch/ppc/configs/openblocks200_defconfig
--- linux-2.4.20.orig/arch/ppc/configs/openblocks200_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/configs/openblocks200_defconfig	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,1043 @@
+#
+# Automatically generated make config: don't edit
+#
+# CONFIG_UID16 is not set
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
+
+#
+# Platform support
+#
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_440 is not set
+# CONFIG_POWER3 is not set
+# CONFIG_8xx is not set
+# CONFIG_PPC_ISERIES is not set
+CONFIG_4xx=y
+# CONFIG_PPC_STD_MMU is not set
+# CONFIG_ASH is not set
+# CONFIG_CEDER is not set
+# CONFIG_BEECH is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_EBK405GPR is not set
+# CONFIG_OAK is not set
+CONFIG_OBS200=y
+# CONFIG_OBS266 is not set
+# CONFIG_RAINIER is not set
+# CONFIG_REDWOOD_4 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_TIVO is not set
+# CONFIG_WALNUT is not set
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_ALL_PPC is not set
+# CONFIG_SMP is not set
+CONFIG_MATH_EMULATION=y
+CONFIG_405GP=y
+CONFIG_BIOS_FIXUP=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM_OCP=y
+CONFIG_OBS2xx=y
+CONFIG_SERIAL_CONSOLE_BAUD=9600
+CONFIG_PM=y
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_GEN550_KGDB=y
+CONFIG_IBM405_ERR51=y
+CONFIG_NOT_COHERENT_CACHE=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_OCP_PROC=y
+
+#
+# General setup
+#
+# CONFIG_HIGHMEM is not set
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_PCI=y
+# CONFIG_PC_KEYBOARD is not set
+CONFIG_NET=y
+CONFIG_SYSCTL=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_KCORE_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_KERNEL_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_PCI_NAMES=y
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+CONFIG_CARDBUS=y
+CONFIG_TCIC=y
+CONFIG_I82092=y
+CONFIG_I82365=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+CONFIG_PPC_RTC=y
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Cryptography support (CryptoAPI)
+#
+# CONFIG_CRYPTO is not set
+# CONFIG_CIPHERS is not set
+# CONFIG_DIGESTS is not set
+# CONFIG_CRYPTODEV is not set
+# CONFIG_CRYPTOLOOP is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+# CONFIG_NET_NEIGH_DEBUG is not set
+# CONFIG_NET_RESTRICTED_REUSE is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPIP_IPV6=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+CONFIG_IP_NF_FTP=y
+CONFIG_IP_NF_IRC=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_LIMIT=y
+CONFIG_IP_NF_MATCH_MAC=y
+CONFIG_IP_NF_MATCH_PKTTYPE=y
+CONFIG_IP_NF_MATCH_MARK=y
+CONFIG_IP_NF_MATCH_MULTIPORT=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_DSCP=y
+CONFIG_IP_NF_MATCH_AH_ESP=y
+CONFIG_IP_NF_MATCH_LENGTH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_TCPMSS=y
+CONFIG_IP_NF_MATCH_HELPER=y
+CONFIG_IP_NF_MATCH_STATE=y
+CONFIG_IP_NF_MATCH_CONNTRACK=y
+CONFIG_IP_NF_MATCH_UNCLEAN=y
+CONFIG_IP_NF_MATCH_OWNER=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_MIRROR=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_NAT_LOCAL=y
+CONFIG_IP_NF_NAT_SNMP_BASIC=y
+CONFIG_IP_NF_NAT_IRC=y
+CONFIG_IP_NF_NAT_FTP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_TOS=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_DSCP=y
+CONFIG_IP_NF_TARGET_MARK=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_TARGET_TCPMSS=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_DEBUG is not set
+CONFIG_IPV6_DROP_FAKE_V4MAPPED=y
+CONFIG_IPV6_RESTRICTED_DOUBLE_BIND=y
+# CONFIG_IPV6_6TO4_NEXTHOP is not set
+# CONFIG_IPV6_PRIVACY is not set
+CONFIG_IPV6_ANYCAST=y
+CONFIG_IPV6_ANYCAST_GROUP=y
+# CONFIG_IPV6_ISATAP is not set
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MLD6_ALL_DONE is not set
+# CONFIG_IPV6_NODEINFO is not set
+
+#
+#   IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IPV6_IPSEC is not set
+CONFIG_IPV6_IPSEC_TUNNEL=y
+# CONFIG_IPV6_IPV6_TUNNEL is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+CONFIG_ATALK=y
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IBM_OCP_IDE is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+
+#
+# SCSI support
+#
+CONFIG_SCSI=m
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_SD_EXTRA_DEVS=40
+CONFIG_CHR_DEV_ST=m
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SR_EXTRA_DEVS=2
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_DMA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NCR53C7xx is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_NCR53C8XX is not set
+# CONFIG_SCSI_SYM53C8XX is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+CONFIG_SCSI_PCMCIA=y
+CONFIG_PCMCIA_AHA152X=m
+CONFIG_PCMCIA_FDOMAIN=m
+CONFIG_PCMCIA_NINJA_SCSI=m
+CONFIG_PCMCIA_QLOGIC=m
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MACE is not set
+# CONFIG_BMAC is not set
+# CONFIG_GMAC is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_PCNET32_VMWARE is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_APRICOT is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_TULIP is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_DGRS is not set
+# CONFIG_DM9102 is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_LNE390 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NE3210 is not set
+# CONFIG_ES3210 is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+CONFIG_8139TOO_TUNE_TWISTER=y
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_SUNDANCE_MMIO is not set
+# CONFIG_TLAN is not set
+# CONFIG_TC35815 is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_RHINE_MMIO is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Backplane Networking
+#
+# CONFIG_NPNET is not set
+
+#
+# On-chip net devices
+#
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_STRIP is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_ARLAN is not set
+# CONFIG_AIRONET4500 is not set
+# CONFIG_AIRONET4500_NONCS is not set
+# CONFIG_AIRONET4500_PROC is not set
+# CONFIG_AIRO is not set
+# CONFIG_HERMES is not set
+# CONFIG_PLX_HERMES is not set
+# CONFIG_PCI_HERMES is not set
+
+#
+# Wireless Pcmcia cards support
+#
+# CONFIG_PCMCIA_HERMES is not set
+# CONFIG_AIRO_CS is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+CONFIG_PCMCIA_3C589=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_PCMCIA_PCNET=m
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_ARCNET_COM20020_CS is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_PCMCIA_XIRTULIP is not set
+CONFIG_NET_PCMCIA_RADIO=y
+CONFIG_PCMCIA_RAYCS=m
+CONFIG_PCMCIA_NETWAVE=m
+CONFIG_PCMCIA_WAVELAN=m
+# CONFIG_AIRONET4500_CS is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Console drivers
+#
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+
+#
+# Macintosh device drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL=y
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+CONFIG_N_HDLC=y
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_OBS200_PUSHSW=y
+CONFIG_OBS200_SLED=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_IBM_OCP_GPIO is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+CONFIG_PCMCIA_SERIAL_CS=m
+CONFIG_SYNCLINK_CS=m
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+
+#
+# Video For Linux
+#
+CONFIG_VIDEO_PROC_FS=y
+# CONFIG_I2C_PARPORT is not set
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_TUNER_3036 is not set
+# CONFIG_VIDEO_STRADIS is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_ZORAN_BUZ is not set
+# CONFIG_VIDEO_ZORAN_DC10 is not set
+# CONFIG_VIDEO_ZORAN_LML33 is not set
+# CONFIG_VIDEO_ZR36120 is not set
+# CONFIG_VIDEO_MEYE is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_GEMTEK_PCI is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+# CONFIG_RADIO_MIROPCM20 is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_ROOT_NFS is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+CONFIG_NLS_CODEPAGE_932=y
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# IBM 4xx options
+#
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_LONG_TIMEOUT is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+CONFIG_USB_ACM=y
+CONFIG_USB_PRINTER=y
+
+#
+# USB Human Interface Devices (HID)
+#
+# CONFIG_USB_HID is not set
+# CONFIG_USB_HIDINPUT is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+CONFIG_USB_SCANNER=y
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_DABUSB is not set
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Library routines
+#
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
diff -Naru linux-2.4.20.orig/arch/ppc/configs/openblocks266_defconfig linux-2.4.20/arch/ppc/configs/openblocks266_defconfig
--- linux-2.4.20.orig/arch/ppc/configs/openblocks266_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/configs/openblocks266_defconfig	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,1084 @@
+# $ssdlinux: linux-ppc-obs.diff,v 1.3 2004/12/21 05:53:53 todoroki Exp $
+#
+# Automatically generated make config: don't edit
+#
+# CONFIG_UID16 is not set
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
+
+#
+# Platform support
+#
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_440 is not set
+# CONFIG_POWER3 is not set
+# CONFIG_8xx is not set
+# CONFIG_PPC_ISERIES is not set
+CONFIG_4xx=y
+# CONFIG_PPC_STD_MMU is not set
+# CONFIG_ASH is not set
+# CONFIG_CEDER is not set
+# CONFIG_BEECH is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_EBK405GPR is not set
+# CONFIG_OAK is not set
+# CONFIG_OBS200 is not set
+CONFIG_OBS266=y
+# CONFIG_RAINIER is not set
+# CONFIG_REDWOOD_4 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_TIVO is not set
+# CONFIG_WALNUT is not set
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_ALL_PPC is not set
+# CONFIG_SMP is not set
+CONFIG_MATH_EMULATION=y
+CONFIG_405GP=y
+CONFIG_BIOS_FIXUP=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM_OCP=y
+CONFIG_OBS2xx=y
+CONFIG_PM=y
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_GEN550_KGDB=y
+CONFIG_IBM405_ERR51=y
+CONFIG_NOT_COHERENT_CACHE=y
+CONFIG_PPC4xx_DMA=y
+CONFIG_PPC4xx_EDMA=y
+CONFIG_OCP_PROC=y
+
+#
+# General setup
+#
+# CONFIG_HIGHMEM is not set
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_PCI=y
+# CONFIG_PC_KEYBOARD is not set
+CONFIG_NET=y
+CONFIG_SYSCTL=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_KCORE_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_KERNEL_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_PCI_NAMES=y
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+CONFIG_CARDBUS=y
+CONFIG_TCIC=y
+CONFIG_I82092=y
+CONFIG_I82365=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+CONFIG_PPC_RTC=y
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+# CONFIG_MTD_CFI_NOSWAP is not set
+CONFIG_MTD_CFI_BE_BYTE_SWAP=y
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_CFI_B1=y
+CONFIG_MTD_CFI_B2=y
+CONFIG_MTD_CFI_B4=y
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_REDWOOD=y
+# CONFIG_MTD_DBOX2 is not set
+# CONFIG_MTD_CFI_FLAGADM is not set
+# CONFIG_MTD_PCI is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Cryptography support (CryptoAPI)
+#
+# CONFIG_CRYPTO is not set
+# CONFIG_CIPHERS is not set
+# CONFIG_DIGESTS is not set
+# CONFIG_CRYPTODEV is not set
+# CONFIG_CRYPTOLOOP is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+# CONFIG_NET_NEIGH_DEBUG is not set
+# CONFIG_NET_RESTRICTED_REUSE is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPIP_IPV6=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+CONFIG_SYN_COOKIES=y
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+CONFIG_IP_NF_FTP=y
+CONFIG_IP_NF_IRC=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_LIMIT=y
+CONFIG_IP_NF_MATCH_MAC=y
+CONFIG_IP_NF_MATCH_PKTTYPE=y
+CONFIG_IP_NF_MATCH_MARK=y
+CONFIG_IP_NF_MATCH_MULTIPORT=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_DSCP=y
+CONFIG_IP_NF_MATCH_AH_ESP=y
+CONFIG_IP_NF_MATCH_LENGTH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_TCPMSS=y
+CONFIG_IP_NF_MATCH_HELPER=y
+CONFIG_IP_NF_MATCH_STATE=y
+CONFIG_IP_NF_MATCH_CONNTRACK=y
+CONFIG_IP_NF_MATCH_UNCLEAN=y
+CONFIG_IP_NF_MATCH_OWNER=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_MIRROR=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_NAT_LOCAL=y
+CONFIG_IP_NF_NAT_SNMP_BASIC=y
+CONFIG_IP_NF_NAT_IRC=y
+CONFIG_IP_NF_NAT_FTP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_TOS=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_DSCP=y
+CONFIG_IP_NF_TARGET_MARK=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_TARGET_TCPMSS=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_DEBUG is not set
+CONFIG_IPV6_DROP_FAKE_V4MAPPED=y
+CONFIG_IPV6_RESTRICTED_DOUBLE_BIND=y
+# CONFIG_IPV6_6TO4_NEXTHOP is not set
+# CONFIG_IPV6_PRIVACY is not set
+CONFIG_IPV6_ANYCAST=y
+CONFIG_IPV6_ANYCAST_GROUP=y
+# CONFIG_IPV6_ISATAP is not set
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MLD6_ALL_DONE is not set
+# CONFIG_IPV6_NODEINFO is not set
+
+#
+#   IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IPV6_IPSEC is not set
+CONFIG_IPV6_IPSEC_TUNNEL=y
+# CONFIG_IPV6_IPV6_TUNNEL is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+CONFIG_ATALK=y
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_IDEDISK_STROKE=y
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+CONFIG_BLK_DEV_IDEPCI=y
+# CONFIG_IDEPCI_SHARE_IRQ is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+CONFIG_IDEDMA_ONLYDISK=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_PCI_WIP is not set
+# CONFIG_BLK_DEV_IDEDMA_TIMEOUT is not set
+# CONFIG_IDEDMA_NEW_DRIVE_LISTINGS is not set
+CONFIG_BLK_DEV_ADMA=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_AEC62XX_TUNING is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_WDC_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_CMD680 is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_HPT34X_AUTODMA is not set
+CONFIG_BLK_DEV_HPT366=y
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_PDC202XX is not set
+# CONFIG_PDC202XX_BURST is not set
+# CONFIG_PDC202XX_FORCE is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_BLK_DEV_SL82C105 is not set
+# CONFIG_IBM_OCP_IDE is not set
+# CONFIG_IDE_CHIPSETS is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_DMA_NONPCI is not set
+CONFIG_BLK_DEV_IDE_MODES=y
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+
+#
+# SCSI support
+#
+CONFIG_SCSI=m
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_SD_EXTRA_DEVS=40
+CONFIG_CHR_DEV_ST=m
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SR_EXTRA_DEVS=2
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_DMA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NCR53C7xx is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_NCR53C8XX is not set
+# CONFIG_SCSI_SYM53C8XX is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+CONFIG_SCSI_PCMCIA=y
+CONFIG_PCMCIA_AHA152X=m
+CONFIG_PCMCIA_FDOMAIN=m
+CONFIG_PCMCIA_NINJA_SCSI=m
+CONFIG_PCMCIA_QLOGIC=m
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MACE is not set
+# CONFIG_BMAC is not set
+# CONFIG_GMAC is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_PCNET32_VMWARE is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_APRICOT is not set
+# CONFIG_CS89x0 is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_DGRS is not set
+# CONFIG_DM9102 is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_LNE390 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NE3210 is not set
+# CONFIG_ES3210 is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_SUNDANCE_MMIO is not set
+# CONFIG_TLAN is not set
+# CONFIG_TC35815 is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_RHINE_MMIO is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Backplane Networking
+#
+# CONFIG_NPNET is not set
+
+#
+# On-chip net devices
+#
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_STRIP is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_ARLAN is not set
+# CONFIG_AIRONET4500 is not set
+# CONFIG_AIRONET4500_NONCS is not set
+# CONFIG_AIRONET4500_PROC is not set
+# CONFIG_AIRO is not set
+# CONFIG_HERMES is not set
+# CONFIG_PLX_HERMES is not set
+# CONFIG_PCI_HERMES is not set
+
+#
+# Wireless Pcmcia cards support
+#
+# CONFIG_PCMCIA_HERMES is not set
+# CONFIG_AIRO_CS is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+CONFIG_PCMCIA_3C589=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_PCMCIA_PCNET=m
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_ARCNET_COM20020_CS is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_PCMCIA_XIRTULIP is not set
+CONFIG_NET_PCMCIA_RADIO=y
+CONFIG_PCMCIA_RAYCS=m
+CONFIG_PCMCIA_NETWAVE=m
+CONFIG_PCMCIA_WAVELAN=m
+# CONFIG_AIRONET4500_CS is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Console drivers
+#
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+
+#
+# Macintosh device drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL=y
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+CONFIG_N_HDLC=y
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+CONFIG_I2C_IBM_OCP=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_PROC is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_X1226_RTC=y
+CONFIG_I2C_EEPROM=y
+CONFIG_OBS266_PUSHSW=y
+CONFIG_OBS266_LED=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_IBM_OCP_GPIO is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+CONFIG_PCMCIA_SERIAL_CS=m
+CONFIG_SYNCLINK_CS=m
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+
+#
+# Video For Linux
+#
+CONFIG_VIDEO_PROC_FS=y
+# CONFIG_I2C_PARPORT is not set
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_TUNER_3036 is not set
+# CONFIG_VIDEO_STRADIS is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_ZORAN_BUZ is not set
+# CONFIG_VIDEO_ZORAN_DC10 is not set
+# CONFIG_VIDEO_ZORAN_LML33 is not set
+# CONFIG_VIDEO_ZR36120 is not set
+# CONFIG_VIDEO_MEYE is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_GEMTEK_PCI is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+# CONFIG_RADIO_MIROPCM20 is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+CONFIG_JBD_DEBUG=y
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# IBM 4xx options
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Library routines
+#
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_HIGHMEM=y
+CONFIG_DEBUG_SLAB=y
+CONFIG_DEBUG_IOVIRT=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_WAITQ is not set
+# CONFIG_KGDB is not set
+# CONFIG_XMON is not set
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
diff -Naru linux-2.4.20.orig/arch/ppc/configs/openblocks50_defconfig linux-2.4.20/arch/ppc/configs/openblocks50_defconfig
--- linux-2.4.20.orig/arch/ppc/configs/openblocks50_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/configs/openblocks50_defconfig	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,636 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+# CONFIG_UID16 is not set
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
+
+#
+# Platform support
+#
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_440 is not set
+# CONFIG_POWER3 is not set
+CONFIG_8xx=y
+# CONFIG_PPC_ISERIES is not set
+# CONFIG_PPC_STD_MMU is not set
+CONFIG_SERIAL_CONSOLE=y
+CONFIG_NOT_COHERENT_CACHE=y
+# CONFIG_RPXLITE is not set
+# CONFIG_RPXCLASSIC is not set
+# CONFIG_BSEIP is not set
+# CONFIG_FADS is not set
+# CONFIG_TQM823L is not set
+# CONFIG_TQM850L is not set
+# CONFIG_TQM855L is not set
+# CONFIG_TQM860L is not set
+# CONFIG_FPS850L is not set
+# CONFIG_SPD823TS is not set
+# CONFIG_IVMS8 is not set
+# CONFIG_IVML24 is not set
+# CONFIG_SM850 is not set
+# CONFIG_HERMES_PRO is not set
+# CONFIG_IP860 is not set
+# CONFIG_LWMON is not set
+# CONFIG_PCU_E is not set
+# CONFIG_CCM is not set
+# CONFIG_LANTEC is not set
+# CONFIG_MBX is not set
+# CONFIG_WINCEPT is not set
+CONFIG_OBS50=y
+# CONFIG_ALL_PPC is not set
+# CONFIG_SMP is not set
+CONFIG_MATH_EMULATION=y
+CONFIG_EMBEDDEDBOOT=y
+CONFIG_SERIAL_CONSOLE_BAUD=9600
+
+#
+# General setup
+#
+# CONFIG_HIGHMEM is not set
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+# CONFIG_PCI_QSPAN is not set
+# CONFIG_PCI is not set
+CONFIG_NET=y
+CONFIG_SYSCTL=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_KCORE_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_KERNEL_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+# CONFIG_PPC_RTC is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=6144
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Cryptography support (CryptoAPI)
+#
+# CONFIG_CRYPTO is not set
+# CONFIG_CIPHERS is not set
+# CONFIG_DIGESTS is not set
+# CONFIG_CRYPTODEV is not set
+# CONFIG_CRYPTOLOOP is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+# CONFIG_NET_NEIGH_DEBUG is not set
+# CONFIG_NET_RESTRICTED_REUSE is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPIP_IPV6=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+CONFIG_SYN_COOKIES=y
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_MAC=m
+# CONFIG_IP_NF_MATCH_PKTTYPE is not set
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_DSCP is not set
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+# CONFIG_IP_NF_MATCH_HELPER is not set
+CONFIG_IP_NF_MATCH_STATE=m
+# CONFIG_IP_NF_MATCH_CONNTRACK is not set
+CONFIG_IP_NF_MATCH_UNCLEAN=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_MIRROR=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+# CONFIG_IP_NF_NAT_LOCAL is not set
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_COMPAT_IPCHAINS=m
+CONFIG_IP_NF_NAT_NEEDED=y
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_DEBUG is not set
+CONFIG_IPV6_DROP_FAKE_V4MAPPED=y
+CONFIG_IPV6_RESTRICTED_DOUBLE_BIND=y
+# CONFIG_IPV6_6TO4_NEXTHOP is not set
+# CONFIG_IPV6_PRIVACY is not set
+CONFIG_IPV6_ANYCAST=y
+CONFIG_IPV6_ANYCAST_GROUP=y
+# CONFIG_IPV6_ISATAP is not set
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MLD6_ALL_DONE is not set
+# CONFIG_IPV6_NODEINFO is not set
+
+#
+#   IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IPV6_IPSEC is not set
+CONFIG_IPV6_IPSEC_TUNNEL=y
+# CONFIG_IPV6_IPV6_TUNNEL is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+CONFIG_BLK_DEV_MPC8xx_IDE=y
+# CONFIG_IDE_8xx_PCCARD is not set
+# CONFIG_IDE_8xx_DIRECT is not set
+CONFIG_IDE_EXT_DIRECT=y
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+CONFIG_BLK_DEV_IDE_MODES=y
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MACE is not set
+# CONFIG_BMAC is not set
+# CONFIG_GMAC is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Console drivers
+#
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_OBS50_PUSHSW=y
+CONFIG_OBS50_SLED=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_ROOT_NFS is not set
+CONFIG_NFSD=y
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# MPC8xx CPM Options
+#
+CONFIG_SCC_ENET=y
+# CONFIG_SCC1_ENET is not set
+CONFIG_SCC2_ENET=y
+# CONFIG_SCC3_ENET is not set
+CONFIG_FEC_ENET=y
+CONFIG_USE_MDIO=y
+CONFIG_ENET_BIG_BUFFERS=y
+# CONFIG_SMC2_UART is not set
+CONFIG_USE_SCC_IO=y
+CONFIG_8xx_COPYBACK=y
+# CONFIG_8xx_CPU6 is not set
+# CONFIG_UCODE_PATCH is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Library routines
+#
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
diff -Naru linux-2.4.20.orig/arch/ppc/kernel/Makefile linux-2.4.20/arch/ppc/kernel/Makefile
--- linux-2.4.20.orig/arch/ppc/kernel/Makefile	2002-12-11 11:40:25.000000000 +0900
+++ linux-2.4.20/arch/ppc/kernel/Makefile	2004-12-21 12:27:03.000000000 +0900
@@ -8,6 +8,9 @@
 # unless it's something special (ie not a .c file).
 #
 # Note 2! The CFLAGS definitions are now in the main makefile...
+#
+#	PlatHome <openlab.plathome.co.jp>
+#		- Added CONFIG_OBS200, CONFIG_OBS50 
 
 USE_STANDARD_AS_RULE	:= true
 
@@ -104,6 +107,7 @@
 					pci_auto.o indirect_pci.o
 obj-$(CONFIG_MVME5100)		+= open_pic.o todc_time.o indirect_pci.o \
 					i8259.o pci_auto.o pplus_common.o
+obj-$(CONFIG_OBS50)		+= rtcbak.o i2clib.o
 obj-$(CONFIG_PAL4)		+= todc_time.o indirect_pci.o pci_auto.o
 obj-$(CONFIG_PCORE)		+= mpc10x_common.o todc_time.o i8259.o \
 					indirect_pci.o pci_auto.o
diff -Naru linux-2.4.20.orig/arch/ppc/kernel/i2clib.c linux-2.4.20/arch/ppc/kernel/i2clib.c
--- linux-2.4.20.orig/arch/ppc/kernel/i2clib.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/kernel/i2clib.c	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,332 @@
+/* @@ES TANIA */
+/*
+ *	I2C utilities.
+ *
+ *	Written for Century Systems, Inc. Embedded Server
+ *		for EEPROM/RTC access.
+ *	2000.6.5
+ *	T. Oka
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *  Modified by Century Systems Inc.(http://www.centurysys.co.jp/)
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Removed i2clib.h
+ *
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/8xx_immap.h>
+
+#define DBGON(x)	x
+#define DBGOFF(x)
+
+
+#define I2C_ACK_WT		(2000L)
+#define I2C_INIT_WT		(200L)
+
+/* Pointer to the Communications Processor (GLOBAL within this module). */
+static volatile cpm8xx_t	*cp;
+
+/*-----------------------------------------------------------------------------
+ *	Local prototypes.
+ *----------------------------------------------------------------------------*/
+static void i2c_wait(unsigned long wt);
+static void i2c_start(unsigned long wt);
+static void i2c_stop(unsigned long wt);
+static int i2c_put(unsigned char *buf, unsigned int len, unsigned long wt);
+static unsigned char i2c_get(unsigned long wt);
+
+
+/*-----------------------------------------------------------------------------
+ *	Initializes parallel port B register for SCL and SDA control.
+ *----------------------------------------------------------------------------*/
+void __init i2c_init(void)
+{
+	unsigned long	flags;
+	unsigned long	i;
+
+	/* Get pointer to Communication Processor */
+	cp = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+
+	save_flags(flags);
+	cli();
+
+	cp->cp_pbpar &= ~(0x0030);	/* SCL and SDA general purpose I/O */
+	cp->cp_pbodr |= 0x0030;		/* SCL, SDA open drain */
+	cp->cp_pbdir |= 0x0030;		/* SCL (and SDA for now) output */
+	cp->cp_pbdat |= 0x0030;		/* SCL (and SDA) high */
+	DBGOFF(printk("[i2c_init] Ch Dh output\n");)
+
+	restore_flags(flags);
+
+	DBGOFF(printk("[i2c_init] w%lu\n", I2C_INIT_WT);)
+	for (i = 0; i <= I2C_INIT_WT; i++) {}
+}	/* i2c_init() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static void i2c_wait(unsigned long wt)
+{
+	unsigned long	i;
+
+#ifdef TODO
+ - should do this with jiffies instead to work when cpu changes?
+ - also should let other tasks run during this?
+ - in this case must be careful that interrupts are not disabled when this routine is called otherwise jiffies won't be changed and other tasks won't run
+ - this assumes no other tasks manipulating SCL and SDA though - s/b ok - once basically working with interrupts disabled, make a copy then fix
+- what about udelay()? nanosleep()?
+#endif
+	DBGOFF(printk(" w%lu ", wt);)
+	for (i = 0; i <= wt; i++) {}
+}	/* i2c_wait() */
+
+/*-----------------------------------------------------------------------------
+ *	Performs start condition.
+ *	Expects SCL and SDA high, SDA output.
+ *	Leaves SCL low in preparation for data transfer.
+ *----------------------------------------------------------------------------*/
+static void i2c_start(unsigned long wt)
+{
+	DBGOFF(printk("S");)
+
+	i2c_wait(wt);
+	DBGOFF(printk(" Dl ");)
+	cp->cp_pbdat &= ~(0x0010);	/* SDA -> low */
+	i2c_wait(wt);
+	DBGOFF(printk(" Cl ");)
+	cp->cp_pbdat &= ~(0x0020);	/* SCL -> low */
+	i2c_wait(wt);
+	DBGOFF(printk(" endS\n");)
+}	/* i2c_start() */
+
+/*-----------------------------------------------------------------------------
+ *	Performs stop condition.
+ *	Expects SDA output and high.
+ *	Leaves SCL and SDA high to indicate bus not busy.
+ *----------------------------------------------------------------------------*/
+static void i2c_stop(unsigned long wt)
+{
+	DBGOFF(printk("P");)
+
+	i2c_wait(wt);
+	DBGOFF(printk(" Ch Dl ");)
+	cp->cp_pbdat &= ~(0x0010);	/* SDA -> low */
+	cp->cp_pbdat |= 0x0020;		/* SCL -> high */
+	i2c_wait(wt);
+	DBGOFF(printk(" Dh ");)
+	cp->cp_pbdat |= 0x0010;		/* SDA -> high */
+	i2c_wait(wt);
+	DBGOFF(printk(" endP\n");)
+}	/* i2c_stop() */
+
+/*-----------------------------------------------------------------------------
+ *	Expects SCL low and SDA output.
+ *	Leaves SCL low.
+ *----------------------------------------------------------------------------*/
+static int i2c_put(unsigned char *buf, unsigned int len, unsigned long wt)
+{
+	unsigned int	j;
+	unsigned char	mask, ack;
+
+	DBGOFF(printk("p");)
+	for (j = 0; j < len; j++) {
+		for (mask = 0x80; mask > 0x00; mask >>= 1) {
+			/* SCL is expected to be low here for data transfer */
+			DBGOFF(printk(" (lSCL) ");)
+
+			if (buf[j] & mask) {
+				DBGOFF(printk(" D1 ");)
+				cp->cp_pbdat |= 0x0010;		/* SDA high */
+			}
+			else {
+				DBGOFF(printk(" D0 ");)
+				cp->cp_pbdat &= ~(0x0010);	/* SDA low */
+			}
+
+			i2c_wait(wt);	/* tSU:DAT at least 250 ns */
+			DBGOFF(printk(" Ch ");)
+			cp->cp_pbdat |= 0x0020;		/* SCL -> high */
+			i2c_wait(wt);	/* hold SDA stable with clock high */
+
+			/* SCL low for next data transfer */
+			DBGOFF(printk(" Cl ");)
+			cp->cp_pbdat &= ~(0x0020);
+			i2c_wait(wt);
+		}	/* for each bit */
+
+		/* setup SDA as input to receive ACK */
+		DBGOFF(printk(" SDA input ");)
+		cp->cp_pbdir &= ~(0x0010);
+
+		/* generate clock pulse for ack */
+		DBGOFF(printk(" Ch ");)
+		cp->cp_pbdat |= 0x0020;		/* SCL -> high */
+		i2c_wait(wt);
+		i2c_wait(wt);	/* sample ACK near end of clock period */
+
+		ack = cp->cp_pbdat;	/* sample ACK */
+		DBGOFF(if (ack & 0x0010) printk(" no ack! ");)
+
+		/* SCL low for next data transfer */
+		DBGOFF(printk(" Cl ");)
+		cp->cp_pbdat &= ~(0x0020);
+		i2c_wait(wt);
+
+		/* reverse SDA direction back to output */
+		DBGOFF(printk(" SDA output ");)
+		cp->cp_pbdir |= 0x0010;
+		i2c_wait(wt);
+
+		/* leave SDA high */	/* added 2000.6.20 */
+		DBGOFF(printk(" Dh ");)
+		cp->cp_pbdat |= 0x0010;
+		i2c_wait(wt);
+
+		if (ack & 0x0010) {	/* ACK not returned */
+			DBGOFF(printk("byte %d no ack\n", j);)
+			DBGOFF(printk("%02x no ack\n", buf[j]);)
+			DBGOFF(printk("*");)	/* SINGLECH */
+			return (-1);
+		}
+		DBGOFF(else printk("%02x ok\n", buf[j]);)
+	}	/* for len bytes */
+	DBGOFF(printk(" endp\n");)
+
+	DBGOFF(printk("$");)	/* SINGLECH */
+	return (0);
+}	/* i2c_put() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static unsigned char i2c_get(unsigned long wt)
+{
+	unsigned char	mask, rv = 0x00;
+
+	DBGOFF(printk("g");)
+
+	/* setup SDA as input to receive data */
+	DBGOFF(printk(" SDA input ");)
+	cp->cp_pbdir &= ~(0x0010);
+	i2c_wait(wt);
+
+	for (mask = 0x80; mask > 0x00; mask >>= 1) {
+		DBGOFF(printk(" Ch ");)
+		cp->cp_pbdat |= 0x0020;		/* SCL high */
+		i2c_wait(wt);
+
+		/* sample data */
+		if (cp->cp_pbdat & 0x0010) {
+			DBGOFF(printk(" D1 ");)
+			rv |= mask;		/* SDA is high */
+		}
+		/* else bit remains 0 */
+		DBGOFF(else printk(" D0 ");)
+
+		DBGOFF(printk(" Cl ");)
+		cp->cp_pbdat &= ~(0x0020);	/* SCL -> low */
+		i2c_wait(wt);
+	}	/* for each bit */
+
+	/* reverse SDA direction back to output */
+	DBGOFF(printk(" SDA output ");)
+	cp->cp_pbdir |= 0x0010;
+	i2c_wait(wt);
+
+	/* leave SDA high */	/* added 2000.6.20 */
+	DBGOFF(printk(" Dh ");)
+	cp->cp_pbdat |= 0x0010;
+	i2c_wait(wt);
+
+	DBGOFF(printk(" endg\n");)
+
+	DBGOFF(printk(" [got %02x] ", rv);)
+	return (rv);
+}	/* i2c_get() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+unsigned char i2c_rd(unsigned char dev_id, unsigned int offset, unsigned long wt)
+{
+	unsigned char	buf[2];
+	int		rv;
+
+	DBGOFF(printk("r");)
+	DBGOFF(printk("[i2c_rd] offset %u\n", offset);)
+
+	DBGOFF({
+	printk("\n");
+	printk("PBPAR 0x%x\t", cp->cp_pbpar);
+	printk("PBDIR 0x%x\t", cp->cp_pbdir);
+	printk("PBODR 0x%x\t", cp->cp_pbodr);
+	printk("PBDAT 0x%x\t", cp->cp_pbdat);
+	printk("\n");
+	})
+
+	buf[0] = dev_id;
+	buf[1] = (unsigned char) offset;
+	DBGOFF(printk(" write %02x%02x ", buf[0], buf[1]);)
+
+	i2c_start(wt);
+	rv = i2c_put(buf, 2, wt);
+	i2c_stop(wt);
+
+	if (rv) {
+		DBGOFF(printk("[i2c_rd] 1\n");)
+		return (0x00);
+	}
+
+	buf[0] |= 0x01;		/* R/W bit ==> read */
+	i2c_start(wt);
+	rv = i2c_put(buf, 1, wt);
+
+	if (rv) {
+		i2c_stop(wt);
+		DBGOFF(printk("[i2c_rd] 2\n");)
+		return (0x00);
+	}
+
+	buf[0] = i2c_get(wt);
+	i2c_stop(wt);
+
+	return (buf[0]);
+}	/* i2c_rd() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+void i2c_wr(unsigned char dev_id, unsigned int offset, unsigned char val, unsigned long wt)
+{
+	unsigned char	buf[3];
+	int		rv;
+	unsigned long	ackwait;
+
+	buf[0] = dev_id;
+	buf[1] = (unsigned char) offset;
+	buf[2] = val;
+	DBGOFF(printk(" w%02x%02x%02x ", buf[0], buf[1], buf[2]);)
+
+	i2c_start(wt);
+	rv = i2c_put(buf, 3, wt);
+	i2c_stop(wt);
+
+	if (!rv) {
+		ackwait = 0L;
+		do {
+			i2c_start(wt);
+			rv = i2c_put(buf, 1, wt);
+			i2c_stop(wt);
+			if (rv == 0) {
+				DBGOFF(printk("[i2c_wr] got ack\n");)
+				break;
+			}
+		} while (++ackwait < I2C_ACK_WT);
+		DBGON(if (ackwait >= I2C_ACK_WT) printk("[i2c_wr] no ack!");)
+	}
+	DBGOFF(else printk("[i2c_wr] 1\n");)
+}	/* i2c_wr() */
diff -Naru linux-2.4.20.orig/arch/ppc/kernel/m8xx_setup.c linux-2.4.20/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.20.orig/arch/ppc/kernel/m8xx_setup.c	2002-12-11 11:39:43.000000000 +0900
+++ linux-2.4.20/arch/ppc/kernel/m8xx_setup.c	2004-12-21 12:27:03.000000000 +0900
@@ -8,6 +8,9 @@
  *  Modified by Cort Dougan (cort@cs.nmt.edu)
  *  Modified for MBX using prep/chrp/pmac functions by Dan (dmalek@jlc.net)
  *  Further modified for generic 8xx by Dan.
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added for OpenBlockS 50
  */
 
 /*
@@ -61,6 +64,11 @@
 extern void m8xx_cpm_reset(uint);
 extern void rpxfb_alloc_pages(void);
 
+#ifdef CONFIG_OBS50
+extern void obs_init(unsigned long r3, unsigned long r4, unsigned long r5,
+		unsigned long r6, unsigned long r7);
+#endif
+
 void __init
 m8xx_setup_arch(void)
 {
@@ -251,8 +259,8 @@
 
 	bp = (bd_t *)__res;
 
-	seq_printf(m, "clock\t\t: %dMHz\n"
-		   "bus clock\t: %dMHz\n",
+	seq_printf(m, "clock\t\t: %luMHz\n"
+		   "bus clock\t: %luMHz\n",
 		   bp->bi_intfreq / 1000000,
 		   bp->bi_busfreq / 1000000);
 
@@ -407,4 +415,7 @@
 #if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
 	m8xx_ide_init();
 #endif
+#if CONFIG_OBS50
+	obs_init(r3, r4, r5, r6, r7);
+#endif
 }
diff -Naru linux-2.4.20.orig/arch/ppc/kernel/ppc4xx_pic.c linux-2.4.20/arch/ppc/kernel/ppc4xx_pic.c
--- linux-2.4.20.orig/arch/ppc/kernel/ppc4xx_pic.c	2002-12-11 11:39:05.000000000 +0900
+++ linux-2.4.20/arch/ppc/kernel/ppc4xx_pic.c	2004-12-21 12:27:03.000000000 +0900
@@ -12,6 +12,9 @@
  *
  *      Juky 24, 2002 - Armin
  *      fixed level setting for cascaded UIC, thanks Eugene
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added for OpenBlockSS 266
  */
 
 /*
@@ -161,6 +164,15 @@
 #ifdef UIC_DEBUG
 	printk("ppc405_uic_enable - irq %d word %d bit 0x%x\n", irq, word, bit);
 #endif
+
+#ifdef CONFIG_OBS266
+#define PUSHSW_INT 26
+	if (irq == PUSHSW_INT) {
+		/* printk(__FUNCTION__ ": TR=0x%08x\n", mfdcr(DCRN_UIC_TR(UIC0))); */
+		mtdcr(DCRN_UIC_TR(UIC0), 1 << (31 - PUSHSW_INT));
+		mtdcr(DCRN_UIC_SR(UIC0), 1 << (31 - PUSHSW_INT));
+	}
+#endif
 	ppc_cached_irq_mask[word] |= 1 << (31 - bit);
 	switch (word) {
 	case 0:
diff -Naru linux-2.4.20.orig/arch/ppc/kernel/ppc4xx_setup.c linux-2.4.20/arch/ppc/kernel/ppc4xx_setup.c
--- linux-2.4.20.orig/arch/ppc/kernel/ppc4xx_setup.c	2002-12-11 11:40:51.000000000 +0900
+++ linux-2.4.20/arch/ppc/kernel/ppc4xx_setup.c	2004-12-21 12:27:03.000000000 +0900
@@ -27,6 +27,10 @@
  *	History: 04/18/02 - Armin
  *	added ash to setting CETE bit in calibrate() 
  *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added for OpenBlockS 266
+ *		- Added UPS control for OpenBlockS 266
+ *
  */
 
 #include <linux/config.h>
@@ -89,6 +93,12 @@
 extern void board_setup_irq(void);
 extern void board_init(void);
 
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+#include <linux/delay.h>
+extern int obsled_out(int);
+#define BLINK_MSEC (1000)
+#endif
+
 /* Global Variables */
 unsigned char __res[sizeof (bd_t)];
 
@@ -204,7 +214,17 @@
 {
 	printk("System Halted\n");
 	__cli();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	UPS_poff();
+	while (1) {
+		obsled_out(7);
+		mdelay(BLINK_MSEC);
+		obsled_out(0);
+		mdelay(BLINK_MSEC);
+	}
+#else
 	while (1) ;
+#endif
 }
 
 static void
@@ -212,7 +232,17 @@
 {
 	printk("System Halted\n");
 	__cli();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	UPS_poff();
+	while (1) {
+		obsled_out(7);
+		mdelay(BLINK_MSEC);
+		obsled_out(0);
+		mdelay(BLINK_MSEC);
+	}
+#else
 	while (1) ;
+#endif
 }
 
 static void __init
@@ -241,7 +271,8 @@
 	bd_t *bip = (bd_t *) __res;
 
 #if defined(CONFIG_WALNUT) || defined(CONFIG_CEDER) 	\
-	|| defined(CONFIG_ASH) || defined(CONFIG_SYCAMORE)
+	|| defined(CONFIG_ASH) || defined(CONFIG_SYCAMORE) \
+	|| defined(CONFIG_EBK405GPR) || defined(CONFIG_OBS266)
 	/* Openbios sets cpu  timers to CPU clk
 	 * we want to use the external clk 
 	 * DCR CHCR1 (aka CPC0_CR1) bit CETE to 1 */
diff -Naru linux-2.4.20.orig/arch/ppc/kernel/rtcbak.c linux-2.4.20/arch/ppc/kernel/rtcbak.c
--- linux-2.4.20.orig/arch/ppc/kernel/rtcbak.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/kernel/rtcbak.c	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,385 @@
+/* @@ES TANIA */
+/*=============================================================================
+ *	Routines to get and set the system time from/to a Dallas DS1307/8
+ *	Real Time Clock chip.  Useful for MPC860-compatible boards which
+ *	do not supply "keep-alive" power to the CPU RTC registers.
+ *
+ *	Written for Century Systems' Embedded Server
+ *	2000.6.5
+ *	T. Oka
+ *	Century Systems, Inc.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * Modified by Century Systems Inc.(http://www.centurysys.co.jp/)
+ *
+ *============================================================================*/
+
+/*-----------------------------------------------------------------------------
+ *	RTC_REBOOT_NOTIFY (2000.6.16):
+ *	Kept for possible future use, but currently does not work
+ *	as intended.  It was designed to provide a method of saving
+ *	the current Linux time at shutdown, but for reasons as
+ *	yet unknown, the notification function is not consistently
+ *	called (seems to depend on the method used to shut down).
+ *----------------------------------------------------------------------------*/
+#undef RTC_REBOOT_NOTIFY
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/spinlock.h>
+#include <linux/mc146818rtc.h>
+#ifdef RTC_REBOOT_NOTIFY
+# include <linux/notifier.h>
+# include <linux/reboot.h>
+#endif
+
+#ifndef BCD_TO_BIN
+# define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+# define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+/*-----------------------------------------------------------------------------
+ *	Define RTC_EPOCH_1970 to interpret the RTC 00..99 year as 1970..2069.
+ *	If undefined, the RTC year will be treated as an offset from a
+ *	configurable epoch.
+ *----------------------------------------------------------------------------*/
+#define RTC_EPOCH_1970
+
+#define RTC_DEFAULT_EPOCH	(2000)
+
+#define RTC_HW_WAIT		(200L)
+
+/* Identifies the DS1307/8 device on the bus. */
+#define RTC_DEV_ID		(0xd0)
+
+#define RTC_HW_INIT()		i2c_init()
+#define RTC_HW_RD(offset)	i2c_rd(RTC_DEV_ID, (offset), RTC_HW_WAIT)
+#define RTC_HW_WR(offset, val)	i2c_wr(RTC_DEV_ID, (offset), (val), RTC_HW_WAIT)
+
+/*-----------------------------------------------------------------------------
+ *	Offsets of RTC registers.
+ *	NOTE:  day of week register (offset 3) not used
+ *----------------------------------------------------------------------------*/
+#define RTC_REG_SEC	(0x00)
+#define RTC_REG_MIN	(0x01)
+#define RTC_REG_HOUR	(0x02)
+#define RTC_REG_DATE	(0x04)
+#define RTC_REG_MON	(0x05)
+#define RTC_REG_YEAR	(0x06)
+#define RTC_REG_CTRL	(0x07)
+
+extern void i2c_init(void);
+extern unsigned char i2c_rd(unsigned char, unsigned int, unsigned long);
+extern void i2c_wr(unsigned char, unsigned int, unsigned char, unsigned long);
+
+unsigned long rtcbak_get_time(void);
+void rtcbak_set_time(unsigned long);
+
+/*-----------------------------------------------------------------------------
+ *	Local prototypes.
+ *----------------------------------------------------------------------------*/
+
+#ifndef RTC_EPOCH_1970
+static int rtcbak_is_valid_epoch(unsigned int epoch);
+static unsigned int rtcbak_get_epoch(void);
+static void rtcbak_set_epoch(unsigned int epoch);
+#endif
+
+#ifdef RTC_REBOOT_NOTIFY
+int rtcbak_on_shutdown(struct notifier_block *this, unsigned long code, void *unused);
+#else /* RTC_REBOOT_NOTIFY */
+void rtcbak_on_shutdown(void);
+#endif /* RTC_REBOOT_NOTIFY */
+
+#ifdef RTC_REBOOT_NOTIFY
+/*-----------------------------------------------------------------------------
+ *	Structure used for shutdown/reboot notification.
+ *----------------------------------------------------------------------------*/
+static struct notifier_block rtcbak_notifier = {rtcbak_on_shutdown, NULL, 0};
+#endif
+
+/*-----------------------------------------------------------------------------
+ *	Returns the date/time read from the RTC chip, converted to
+ *	seconds since 1970-01-01 00:00:00.
+ *
+ *	CAUTION:
+ *	Uses mktime() to perform the conversion, and thus is subject
+ *	to any overflow problems that function has.
+ *----------------------------------------------------------------------------*/
+unsigned long rtcbak_get_time(void)
+{
+	unsigned int	yr, mo, dt, hr, mn, sc;
+	unsigned int	tmp;	/* used in converting hours to 24-hour clock */
+	unsigned long	flags;
+
+	save_flags(flags);
+	cli();
+	yr = (unsigned int) RTC_HW_RD(RTC_REG_YEAR);
+	mo = (unsigned int) RTC_HW_RD(RTC_REG_MON);
+	dt = (unsigned int) RTC_HW_RD(RTC_REG_DATE);
+	hr = (unsigned int) RTC_HW_RD(RTC_REG_HOUR);
+	mn = (unsigned int) RTC_HW_RD(RTC_REG_MIN);
+	sc = (unsigned int) RTC_HW_RD(RTC_REG_SEC);
+	restore_flags(flags);
+
+	/* mask out unused or other-purpose bits */
+	mo &= 0x0000001f;
+	dt &= 0x0000003f;
+	if ((hr & 0x00000060) == 0x00000060) {
+		/* 12-hour mode, P.M. - convert to 24-hour format */
+		tmp = hr & 0x0000001f;
+		BCD_TO_BIN(tmp);
+		tmp += 12;
+		BIN_TO_BCD(tmp);	/* reverse back to BCD for below */
+		hr = tmp;
+	}
+	else {
+		/* 24-hour clock or
+			12-hour A.M. (A.M. bit is 0 so can use same mask) */
+		if ((hr & 0x00000070) == 0x00000030) {
+			/* this probably should not happen, but it does... */
+			hr &= 0x0000001f;
+		}
+		hr &= 0x0000003f;
+	}
+	mn &= 0x0000007f;
+	sc &= 0x0000007f;	/* mask out CH bit */
+
+	BCD_TO_BIN(yr);
+	BCD_TO_BIN(mo);
+	BCD_TO_BIN(dt);
+	BCD_TO_BIN(hr);
+	BCD_TO_BIN(mn);
+	BCD_TO_BIN(sc);
+
+	/* do not use bad values from the RTC */
+	if ((yr > 99) || (mo < 1 || mo > 12) || (dt < 1 || dt > 31) ||
+					(hr > 23) || (mn > 59) || (sc > 59)) {
+		/* illegal value */
+		return (mktime(1970, 1, 1, 0, 0, 0));	/* EARLY RETURN */
+	}
+
+#ifdef RTC_EPOCH_1970
+	/*
+	 *	The 00..99 year range supported by the chip is used
+	 *	as an offset from 1970.
+	 */
+	yr += ((yr <= 69) ? 2000 : 1900);
+#else
+	/*
+	 *	The 00..99 year range supported by the chip is used
+	 *	as an offset from the current epoch.
+	 */
+	yr += rtcbak_get_epoch();
+#endif
+
+	return (mktime(yr, mo, dt, hr, mn, sc));
+}	/* rtcbak_get_time() */
+
+/*-----------------------------------------------------------------------------
+ *	Sets the given date/time to the RTC chip.
+ *
+ *	tv_sec is interpreted as the number of seconds since
+ *	1970-0101 00:00:00 UTC.
+ *
+ *	CAUTION:
+ *	Uses to_tm() to perform the conversion, and thus is subject
+ *	to any overflow problems that function has.
+ *----------------------------------------------------------------------------*/
+void rtcbak_set_time(unsigned long tv_sec)
+{
+	struct rtc_time	rtc;
+	unsigned long	flags;
+	unsigned char	yr, mo, dt, hr, mn, sc;
+	unsigned int	year;
+#ifndef RTC_EPOCH_1970
+	unsigned int	new_epoch;
+#endif
+
+	/* convert to a Gregorian date (includes leap year adjustments, etc.) */
+	to_tm(tv_sec, &rtc);
+
+#ifdef RTC_EPOCH_1970
+	if ((rtc.tm_year < 1970) || (rtc.tm_year > 2069)) {
+		/* year out of range 1970..2069 */
+		return;		/* EARLY RETURN */
+	}
+	else {
+		year = rtc.tm_year;
+		year -= ((year < 2000) ? 1900 : 2000);
+	}
+#else
+	year = (unsigned int) rtc.tm_year;
+	new_epoch = year - (year % 100);
+
+	if (rtcbak_get_epoch() == new_epoch) {
+		year -= new_epoch;
+	}
+	else {
+		if (rtcbak_is_valid_epoch(new_epoch)) {
+			rtcbak_set_epoch(new_epoch);
+			year -= new_epoch;
+		}
+		else {
+			/* illegal epoch! */
+			/* old epoch value will be used */
+			year %= 100;
+		}
+	}	/* epoch has changed */
+#endif
+	/* year is now a 00..99 offset from the (possibly new) epoch */
+
+	yr = year;
+	mo = rtc.tm_mon;
+	dt = rtc.tm_mday;
+	hr = rtc.tm_hour;
+	mn = rtc.tm_min;
+	sc = rtc.tm_sec;
+
+	/* do not set bad values to the RTC */
+	if ((yr > 99) || (mo < 1 || mo > 12) || (dt < 1 || dt > 31) ||
+					(hr > 23) || (mn > 59) || (sc > 59)) {
+		/* illegal value ignored */
+		return;		/* EARLY RETURN */
+	}
+
+	/* convert to Binary-Coded Decimal format used by RTC chip */
+	BIN_TO_BCD(yr);
+	BIN_TO_BCD(mo);
+	BIN_TO_BCD(dt);
+	BIN_TO_BCD(hr);
+	BIN_TO_BCD(mn);
+	BIN_TO_BCD(sc);
+
+	hr &= ~(0x40);		/* need 24-hour clock */
+	sc &= ~0x80;		/* make sure oscillator enabled (CH) */
+
+	/* write it to the RTC chip */
+	save_flags(flags);
+	cli();
+	RTC_HW_WR(RTC_REG_YEAR, yr);
+	RTC_HW_WR(RTC_REG_MON, mo);
+	RTC_HW_WR(RTC_REG_DATE, dt);
+	RTC_HW_WR(RTC_REG_HOUR, hr);
+	RTC_HW_WR(RTC_REG_MIN, mn);
+	RTC_HW_WR(RTC_REG_SEC, sc);
+	restore_flags(flags);
+
+}	/* rtcbak_set_time() */
+
+#ifndef RTC_EPOCH_1970
+/*-----------------------------------------------------------------------------
+ *	Determines if value is acceptable as an epoch (not out of range
+ *	for conversion functions).
+ *----------------------------------------------------------------------------*/
+int rtcbak_is_valid_epoch(unsigned int epoch)
+{
+	if (epoch > 1900) {
+		return (1);
+	}
+	return (0);
+}	/* rtcbak_is_valid_epoch() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+unsigned int rtcbak_get_epoch(void)
+{
+	unsigned int	epoch;
+	int		fd;
+
+#ifdef TODO
+	epoch = read from file or get from parameter?;
+#else
+	epoch = RTC_DEFAULT_EPOCH;
+#endif
+	if (!rtcbak_is_valid_epoch(epoch)) {
+		epoch = RTC_DEFAULT_EPOCH;
+	}
+
+	return (epoch);
+}	/* rtcbak_get_epoch() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+void rtcbak_set_epoch(unsigned int epoch)
+{
+	/* TODO write epoch to file or parameter */
+}	/* rtcbak_set_epoch() */
+#endif
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+void __init rtcbak_init(void)
+{
+	unsigned long	flags;
+	unsigned char	tmp;	/* temporarily holds register value */
+	struct timeval	tv;
+
+	printk(KERN_INFO "RTC Backup utility\n");
+
+	save_flags(flags);
+	cli();
+
+	RTC_HW_INIT();	/* initialize hardware */
+
+	/* make sure oscillator is enabled */
+	tmp = RTC_HW_RD(RTC_REG_SEC);
+	if (tmp & 0x80) {
+		tmp &= ~(0x80);		/* clear CH bit */
+		RTC_HW_WR(RTC_REG_SEC, tmp);
+	}
+
+	/* initialize control register */
+	RTC_HW_WR(RTC_REG_CTRL, 0x00);	/* OUT low, SQW disabled, freq 1 Hz */
+
+	restore_flags(flags);
+
+	tv.tv_usec = 0;
+	tv.tv_sec = rtcbak_get_time();
+	do_settimeofday(&tv);
+
+#ifdef RTC_REBOOT_NOTIFY
+	/*
+	 *	Arrange to be notified at shutdown so that we can update the
+	 *	Dallas RTC with the current system time.
+ 	 *
+	 *	One of the reasons for doing it this way is so that the saved
+	 *	value is consistent with the automatic adjustments Linux makes
+	 *	to keep the time accurate.  Another is epoch wraps.
+	 */
+	register_reboot_notifier(&rtcbak_notifier);
+#endif
+}	/* rtcbak_init() */
+
+#ifdef RTC_REBOOT_NOTIFY
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+int rtcbak_on_shutdown(struct notifier_block *this, unsigned long code, void *unused)
+{
+	struct timeval	xtv;
+
+	/* get current system time value */
+	do_gettimeofday(&xtv);
+
+	/* write it to the RTC chip */
+	rtcbak_set_time(xtv.tv_sec);
+
+	return (NOTIFY_DONE);
+}	/* rtcbak_on_shutdown() */
+#endif
+
+#ifndef RTC_REBOOT_NOTIFY
+void rtcbak_on_shutdown(void) {}
+#endif /* RTC_REBOOT_NOTIFY */
+
+module_init(rtcbak_init);
+module_exit(rtcbak_on_shutdown);
diff -Naru linux-2.4.20.orig/arch/ppc/kernel/todc_time.c linux-2.4.20/arch/ppc/kernel/todc_time.c
--- linux-2.4.20.orig/arch/ppc/kernel/todc_time.c	2002-12-11 11:39:06.000000000 +0900
+++ linux-2.4.20/arch/ppc/kernel/todc_time.c	2004-12-21 12:27:03.000000000 +0900
@@ -13,6 +13,9 @@
  * under  the terms of  the GNU General Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
+ *
+ * 	PlatHome <openlab.plathome.co.jp>
+ *		- Modified for OpenBlockS 266
  */
 #include <linux/errno.h>
 #include <linux/init.h>
@@ -194,14 +197,28 @@
 todc_time_init(void)
 {
 	static u_char	not_initialized = 1;
+#ifdef CONFIG_OBS266
+	static char tmpbuf[10];
+	ppc_md.progress("todc_time_init:start\n", 0x332);
+	if(todc_info) {
+		sprintf(tmpbuf, "%x\n", (u32)todc_info->nvram_data);
+		ppc_md.progress(tmpbuf , 0x332);
+	}
+#endif
 
 	/* Make sure clocks are running */
 	if (not_initialized) {
 		u_char	cntl_b;
 
 		cntl_b = todc_read_val(todc_info->control_b);
+#ifdef CONFIG_OBS266
+		ppc_md.progress("todc_time_init:read_val\n", 0x332);
+#endif
 
 		if (todc_info->rtc_type == TODC_TYPE_MC146818) {
+#ifdef CONFIG_OBS266
+			ppc_md.progress("todc_time_init:MC146818\n", 0x332);
+#endif
 			if ((cntl_b & 0x70) != 0x20) {
 				printk(KERN_INFO "TODC %s %s\n",
 					"real-time-clock was stopped.",
@@ -215,6 +232,9 @@
 		else if (todc_info->rtc_type == TODC_TYPE_DS1501) {
 			u_char	month;
 
+#ifdef CONFIG_OBS266
+			ppc_md.progress("todc_time_init:DS1501\n", 0x332);
+#endif
 			todc_info->enable_read = TODC_DS1501_CNTL_B_TE;
 			todc_info->enable_write = TODC_DS1501_CNTL_B_TE;
 
@@ -234,6 +254,9 @@
 		else { /* must be a m48txx type */
 			u_char	cntl_a;
 
+#ifdef CONFIG_OBS266
+			ppc_md.progress("todc_time_init:M48TXX\n", 0x332);
+#endif
 			todc_info->enable_read = TODC_MK48TXX_CNTL_A_R;
 			todc_info->enable_write = TODC_MK48TXX_CNTL_A_W;
 
@@ -261,6 +284,9 @@
 		not_initialized = 0;
 	}
 
+#ifdef CONFIG_OBS266
+	ppc_md.progress("todc_time_init:end\n", 0x332);
+#endif
 
 	return 0;
 }
diff -Naru linux-2.4.20.orig/arch/ppc/kernel/traps.c linux-2.4.20/arch/ppc/kernel/traps.c
--- linux-2.4.20.orig/arch/ppc/kernel/traps.c	2002-12-11 11:39:18.000000000 +0900
+++ linux-2.4.20/arch/ppc/kernel/traps.c	2004-12-21 12:27:03.000000000 +0900
@@ -13,6 +13,9 @@
  *
  *  Modified by Cort Dougan (cort@cs.nmt.edu)
  *  and Paul Mackerras (paulus@cs.anu.edu.au)
+ *
+ * 	PlatHome <openlab.plathome.co.jp>
+ *		- Added dump_stack() as dummy.
  */
 
 /*
@@ -467,3 +470,9 @@
 void __init trap_init(void)
 {
 }
+
+void dump_stack(void)
+{
+	printk(KERN_NOTICE
+		"This architecture does not implement dump_stack()\n");
+}
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/Makefile linux-2.4.20/arch/ppc/platforms/Makefile
--- linux-2.4.20.orig/arch/ppc/platforms/Makefile	2002-12-11 11:36:58.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/Makefile	2004-12-21 14:22:29.000000000 +0900
@@ -8,6 +8,10 @@
 # unless it's something special (ie not a .c file).
 #
 # Note 2! The CFLAGS definitions are now in the main makefile...
+#
+#	PlatHome <openlab.plathome.co.jp>
+#		- Added CONFIG_OBS200
+#		- Added CONFIG_OBS266
 
 USE_STANDARD_AS_RULE	:= true
 
@@ -36,6 +40,10 @@
 obj-$(CONFIG_REDWOOD_5)		+= redwood5.o ibmstb4.o
 obj-$(CONFIG_REDWOOD_6)		+= redwood6.o ibmstbx25.o
 obj-$(CONFIG_WALNUT)		+= walnut.o ibm405gp.o
+obj-$(CONFIG_EBK405GPR)		+= ebk405gpr.o ibm405gpr.o
+obj-$(CONFIG_OBS50)		+= obs50_setup.o obs50_time.o
+obj-$(CONFIG_OBS200)		+= openblocks200.o ibm405gp.o
+obj-$(CONFIG_OBS266)		+= openblocks266.o ibm405gpr.o
 obj-$(CONFIG_ASH)		+= ash.o ibmnp405h.o
 obj-$(CONFIG_RAINIER)		+= rainier.o ibmnp4gs.o
 obj-$(CONFIG_APUS)		+= apus_setup.o
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/ebk405gpr.c linux-2.4.20/arch/ppc/platforms/ebk405gpr.c
--- linux-2.4.20.orig/arch/ppc/platforms/ebk405gpr.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/ebk405gpr.c	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,258 @@
+/*
+ *
+ *    Copyright (c) 2003 AXE,Inc.
+ *    ebk405gpr.c: Based on walnut.c
+ *
+ *    Copyrigh t(c) 1999-2000 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000-2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: walnut.c
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      IBM PowerPC 4xx based boards. Adapted from original
+ *      code by Gary Thomas, Cort Dougan <cort@fsmlabs.com>, and Dan Malek
+ *      <dan@net4x.com>.
+ *
+ *      History: 11/09/2001 - armin
+ *      added board_init to add in additional instuctions needed during platfrom_init
+ *
+ *      01/22/2002 - Armin
+ *      converted pci to ocp
+ *
+ *
+ * Please read the COPYING file for all license details.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/pci.h>
+#include <linux/rtc.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/todc.h>
+#include <platforms/ibm_ocp.h>
+
+#define DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+void *kb_cs;
+void *kb_data;
+void *ebk405gpr_rtc_base;
+
+/* Some IRQs unique to EBK405GPr.
+ * Used by the generic 405 PCI setup functions in ppc4xx_pci.c
+ */
+int __init
+ppc405_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	    /*
+	     *      PCI IDSEL/INTPIN->INTLINE
+	     *      A       B       C       D
+	     */
+	{
+		{28, 28, 28, 28},	/* IDSEL 1 - PCI slot 1 */
+		{29, 29, 29, 29},	/* IDSEL 2 - PCI slot 2 */
+		{30, 30, 30, 30},	/* IDSEL 3 - PCI slot 3 */
+		{31, 31, 31, 31},	/* IDSEL 4 - PCI slot 4 */
+	};
+
+	const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+
+void __init
+board_setup_arch(void)
+{
+#define EBK405GPR_PS2_BASE		0xF0100000
+#define EBK405GPR_FPGA_BASE	0xF0300000
+
+	void *fpga_brdc;
+	unsigned char fpga_brdc_data;
+	void *fpga_enable;
+	void *fpga_polarity;
+	void *fpga_status;
+	void *fpga_trigger;
+	
+	kb_data = ioremap(EBK405GPR_PS2_BASE, 8);
+	if (!kb_data) {
+		printk(KERN_CRIT
+		       "ebk405gpr_setup_arch() kb_data ioremap failed\n");
+		return;
+	}
+
+	kb_cs = kb_data + 1;
+
+	fpga_status = ioremap(EBK405GPR_FPGA_BASE, 8);
+	if (!fpga_status) {
+		printk(KERN_CRIT
+		       "ebk405gpr_setup_arch() fpga_status ioremap failed\n");
+		return;
+	}
+
+
+	fpga_enable = fpga_status + 1;
+	fpga_polarity = fpga_status + 2;
+	fpga_trigger = fpga_status + 3;
+	fpga_brdc = fpga_status + 4;
+
+	/* split the keyboard and mouse interrupts */
+	fpga_brdc_data = readb(fpga_brdc);
+	fpga_brdc_data |= 0x80;
+	writeb(fpga_brdc_data, fpga_brdc);
+	writeb(0x3, fpga_enable);
+
+	writeb(0x3, fpga_polarity);
+
+	writeb(0x3, fpga_trigger);
+
+	/* RTC step for the EBK405GPr */
+	ebk405gpr_rtc_base = (void *) EBK405GPR_RTC_VADDR;
+	TODC_INIT(TODC_TYPE_DS1743, ebk405gpr_rtc_base, ebk405gpr_rtc_base,
+		  ebk405gpr_rtc_base, 8);
+
+	/* Identify the system */
+	printk("IBM EBK405GPr port\n");
+	/* printk("IBM Walnut port (C) 2000-2002 MontaVista Software, Inc. (source@mvista.com)\n"); */
+}
+
+void __init
+bios_fixup(struct pci_controller *hose, struct pcil0_regs *pcip)
+{
+
+	unsigned int bar_response, bar;
+	/*
+	 * Expected PCI mapping:
+	 *
+	 *  PLB addr             PCI memory addr
+	 *  ---------------------       ---------------------
+	 *  0000'0000 - 7fff'ffff <---  0000'0000 - 7fff'ffff
+	 *  8000'0000 - Bfff'ffff --->  8000'0000 - Bfff'ffff
+	 *
+	 *  PLB addr             PCI io addr
+	 *  ---------------------       ---------------------
+	 *  e800'0000 - e800'ffff --->  0000'0000 - 0001'0000
+	 *
+	 * The following code is simplified by assuming that the bootrom
+	 * has been well behaved in following this mapping.
+	 */
+
+#ifdef DEBUG
+	int i;
+
+	printk("ioremap PCLIO_BASE = 0x%x\n", pcip);
+	printk("PCI bridge regs before fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+
+	/* added for IBM boot rom version 1.15 bios bar changes  -AK */
+
+	/* Disable region first */
+	out_le32((void *) &(pcip->pmm[0].ma), 0x00000000);
+	/* PLB starting addr, PCI: 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].la), 0x80000000);
+	/* PCI start addr, 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].pcila), PPC405_PCI_MEM_BASE);
+	/* 512MB range of PLB to PCI */
+	out_le32((void *) &(pcip->pmm[0].pciha), 0x00000000);
+	/* Enable no pre-fetch, enable region */
+	out_le32((void *) &(pcip->pmm[0].ma), ((0xffffffff -
+						(PPC405_PCI_UPPER_MEM -
+						 PPC405_PCI_MEM_BASE)) | 0x01));
+
+	/* Disable region one */
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm1ms), 0x00000000);
+
+	/* Disable region two */
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm2ms), 0x00000000);
+
+	/* Zero config bars */
+	for (bar = PCI_BASE_ADDRESS_1; bar <= PCI_BASE_ADDRESS_2; bar += 4) {
+		early_write_config_dword(hose, hose->first_busno,
+					 PCI_FUNC(hose->first_busno), bar,
+					 0x00000000);
+		early_read_config_dword(hose, hose->first_busno,
+					PCI_FUNC(hose->first_busno), bar,
+					&bar_response);
+		DBG("BUS %d, device %d, Function %d bar 0x%8.8x is 0x%8.8x\n",
+		    hose->first_busno, PCI_SLOT(hose->first_busno),
+		    PCI_FUNC(hose->first_busno), bar, bar_response);
+	}
+	/* end work arround */
+
+#ifdef DEBUG
+	printk("PCI bridge regs after fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+}
+
+void __init
+board_io_mapping(void)
+{
+	io_block_mapping(EBK405GPR_RTC_VADDR,
+			 EBK405GPR_RTC_PADDR, EBK405GPR_RTC_SIZE, _PAGE_IO);
+}
+
+void __init
+board_setup_irq(void)
+{
+}
+
+void __init
+board_init(void)
+{
+	ppc_md.time_init = todc_time_init;
+	ppc_md.set_rtc_time = todc_set_rtc_time;
+	ppc_md.get_rtc_time = todc_get_rtc_time;
+	ppc_md.nvram_read_val = todc_direct_read_val;
+	ppc_md.nvram_write_val = todc_direct_write_val;
+}
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/ebk405gpr.h linux-2.4.20/arch/ppc/platforms/ebk405gpr.h
--- linux-2.4.20.orig/arch/ppc/platforms/ebk405gpr.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/ebk405gpr.h	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,92 @@
+/*
+ *
+ *    Copyright (c) 2003 AXE,Inc.
+ *    ebk405gpr.h: Based on walnut.h
+ *
+ *    Copyright (c) 1999 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000 MontaVista Software Inc.
+ *	PPC405 modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	frank_rowand@mvista.com or source@mvista.com
+ * 	   	debbie_chu@mvista.com
+ *
+ *    Module name: ppc405.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      based boards.
+ *
+ *      This includes:
+ *
+ *         405GP "Walnut" evaluation board
+ *
+ * Please read the COPYING file for all license details.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_EBK405GPR_H__
+#define __ASM_EBK405GPR_H__
+
+/* We have a 405GPr core */
+#include <platforms/ibm405gpr.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * Data structure defining board information maintained by the boot
+ * ROM on IBM's "EBK405GPr" evaluation board. An effort has been made to
+ * keep the field names consistent with the 8xx 'bd_t' board info
+ * structures.
+ */
+
+typedef struct board_info {
+	unsigned char	 bi_s_version[4];	/* Version of this structure */
+	unsigned char	 bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	 bi_memsize;		/* DRAM installed, in bytes */
+	unsigned char	 bi_enetaddr[6];	/* Local Ethernet MAC address */
+	unsigned char	 bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
+	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+} bd_t;
+
+/* Some 4xx parts use a different timebase frequency from the internal clock.
+*/
+#define bi_tbfreq bi_intfreq
+
+
+/* Memory map for the IBM "EBK405GPr" 405GPr evaluation board.
+ * Generic 4xx plus RTC.
+ */
+
+extern void *ebk405gpr_rtc_base;
+#define EBK405GPR_RTC_PADDR	((uint)0xf0000000)
+#define EBK405GPR_RTC_VADDR	EBK405GPR_RTC_PADDR
+#define EBK405GPR_RTC_SIZE	((uint)8*1024)
+
+/* ps2 keyboard and mouse */
+#define KEYBOARD_IRQ		25
+#define AUX_IRQ			26
+
+#ifdef CONFIG_PPC405GP_INTERNAL_CLOCK
+#define BASE_BAUD		201600
+#else
+#define BASE_BAUD		691200
+#endif
+
+#define EBK405GPR_PS2_BASE	0xF0100000
+#define EBK405GPR_FPGA_BASE	0xF0300000
+
+
+extern void *kb_cs;
+extern void *kb_data;
+#define kbd_read_input()	readb(kb_data)
+#define kbd_read_status()	readb(kb_cs)
+#define kbd_write_output(val)	writeb(val, kb_data)
+#define kbd_write_command(val)	writeb(val, kb_cs)
+
+#define PPC4xx_MACHINE_NAME	"IBM EBK405GPr"
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_EBK405GPR_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/ibm405gp.h linux-2.4.20/arch/ppc/platforms/ibm405gp.h
--- linux-2.4.20.orig/arch/ppc/platforms/ibm405gp.h	2002-12-11 11:40:08.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/ibm405gp.h	2004-12-21 12:27:03.000000000 +0900
@@ -93,7 +93,9 @@
 #define PPC4xx_ONB_IO_SIZE	((uint)4*1024)
 
 /* serial port defines */
-#define RS_TABLE_SIZE	2
+/*     #define RS_TABLE_SIZE   2  */
+/* Add 2 more Table for pcmcia 2003/06/26 todoroki@platc2.co.jp */
+#define RS_TABLE_SIZE  4
 
 #define UART0_INT	0
 #define UART1_INT	1
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/ibm405gpr.h linux-2.4.20/arch/ppc/platforms/ibm405gpr.h
--- linux-2.4.20.orig/arch/ppc/platforms/ibm405gpr.h	2002-12-11 11:38:53.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/ibm405gpr.h	2004-12-21 12:27:03.000000000 +0900
@@ -77,7 +77,9 @@
 #define PPC4xx_ONB_IO_SIZE	((uint)4*1024)
 
 /* serial port defines */
-#define RS_TABLE_SIZE	2
+/*     #define RS_TABLE_SIZE   2  */
+/* Add 2 more Table for pcmcia 2003/06/26 todoroki@platc2.co.jp */
+#define RS_TABLE_SIZE  4
 
 #define UART0_INT	0
 #define UART1_INT	1
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/obs50.h linux-2.4.20/arch/ppc/platforms/obs50.h
--- linux-2.4.20.orig/arch/ppc/platforms/obs50.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/obs50.h	2004-12-21 13:00:06.000000000 +0900
@@ -0,0 +1,63 @@
+/*
+ * for OpenBlockS 50
+ * Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ */
+
+/*
+ * A collection of structures, addresses, and values associated with
+ * the Plat'Home OpenBlockS. Copied from the IVMS stuff.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_OBS50_H__
+#define __ASM_OBS50_H__
+
+#include <linux/config.h>
+
+#include <asm/ppcboot.h>
+
+/* Memory map
+ */
+#define	CFG_ATA_BASE_ADDR	((unsigned)0x80000000)
+#define	CFG_ATA_SIZE		((uint)4000)
+#define	CFG_ATA_SUB_BASE_ADDR	((unsigned)0x80200000)
+#define	CFG_ATA_SUB_SIZE	((uint)4000)
+#define	IMAP_ADDR		((uint)0xFF000000)
+#define IMAP_SIZE		((uint)(64 * 1024))
+
+/* Interrupt assignments.
+ */
+#define FEC_INTERRUPT	3		/* = SIU_LEVEL1 */
+#define CPM_INTERRUPT	5		/* = SIU_LEVEL2 */
+#define IDE0_INTERRUPT	8		/* = SIU_IRQ4 */
+#define PHY_INTERRUPT	10		/* = SIU_IRQ5 */
+
+/* override the default number of IDE hardware interfaces */
+#define	MAX_HWIFS	1
+
+/*
+ * Definitions for IDE0 Interface
+ */
+/* main area */
+#define IDE0_BASE_OFFSET		0	/* Base offset (dummy) */
+#define IDE0_DATA_REG_OFFSET		0x00000010
+#define IDE0_ERROR_REG_OFFSET		0x00000012
+#define IDE0_NSECTOR_REG_OFFSET		0x00000014
+#define IDE0_SECTOR_REG_OFFSET		0x00000016
+#define IDE0_LCYL_REG_OFFSET		0x00000018
+#define IDE0_HCYL_REG_OFFSET		0x0000001A
+#define IDE0_SELECT_REG_OFFSET		0x0000001C
+#define IDE0_STATUS_REG_OFFSET		0x0000001E
+/* sub area */
+#define IDE0_CONTROL_REG_OFFSET		0x0000000C
+#define IDE0_IRQ_REG_OFFSET		0x0000000E	/* not used */
+
+/* We don't use the 8259. */
+#define NR_8259_INTS	0
+
+/* ata register manipulation */
+#define OUT_WORD(w,p)	outw_p((w),(p))
+#define IN_WORD(p)	(short)inw_p(p)
+
+#endif /* __ASM_OBS50_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/obs50_setup.c linux-2.4.20/arch/ppc/platforms/obs50_setup.c
--- linux-2.4.20.orig/arch/ppc/platforms/obs50_setup.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/obs50_setup.c	2004-12-21 14:00:26.000000000 +0900
@@ -0,0 +1,210 @@
+/*
+ * arch/ppc/platforms/obs50_setup.c
+ *
+ * Setup routines for OpenBlockS. Essentially, this file is extracted from the
+ * modified version of drivers/ide/ide-m8xx.c by katsunori.murase@nifty.ne.jp.
+ *
+ * S.Adachi (adachi@aa.ap.titech.ac.jp, 2003/07/21)
+ *
+ * Copyright 2003 Satoshi Adachi
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/tty.h>
+#include <linux/major.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/init.h>
+#include <linux/blk.h>
+#include <linux/ioport.h>
+#include <linux/ide.h>
+#include <linux/bootmem.h>
+#include <linux/delay.h>
+
+#include <asm/mpc8xx.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/residual.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/ide.h>
+#include <asm/8xx_immap.h>
+#include <asm/machdep.h>
+#include <asm/irq.h>
+
+#include <platforms/obs50_time.h>
+
+static
+void obs_ide_init_hwif_ports (hw_regs_t *hw, ide_ioreg_t data_port,
+			      ide_ioreg_t ctrl_port, int *irq);
+
+#undef DEBUG
+/* #define DEBUG */
+
+/* ------------------------------------------------------------------------- */
+
+static int
+obs_show_cpuinfo(struct seq_file *m)
+{
+  seq_printf(m, "machine\t\t: OpenBlockS 50\n");
+  return 0;
+}
+
+static void
+obs_power_off(void)
+{
+  for (;;);
+}
+
+static void
+obs_halt(void)
+{
+  for (;;);
+}
+
+void __init
+obs_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	 unsigned long r6, unsigned long r7)
+{
+  ppc_md.show_cpuinfo	= obs_show_cpuinfo;
+  ppc_md.power_off	= obs_power_off;
+  ppc_md.halt		= obs_halt;
+
+  ppc_md.time_init	= obs_time_init;
+  ppc_md.set_rtc_time	= obs_set_rtc_time;
+  ppc_md.get_rtc_time	= obs_get_rtc_time;
+
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+  ppc_ide_md.ide_init_hwif	= obs_ide_init_hwif_ports;
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+extern void ide_interrupt_ack (void *dev);
+extern void m8xx_ide_tuneproc(ide_drive_t *drive, u8 pio);
+
+typedef	struct ide_ioport_desc {
+  unsigned long	base_off;		/* Offset to PCMCIA memory	*/
+  ide_ioreg_t reg_off[IDE_NR_PORTS];	/* controller register offsets	*/
+  int irq;				/* IRQ				*/
+} ide_ioport_desc_t;
+
+/* In the next line, do not use "extern ide_ioport_t *ioport_dsc;".
+   It leads to "ioport_dsc == 0"!!!. */
+extern ide_ioport_desc_t ioport_dsc[];
+
+#define OBSIDE_VERSION_INFO "IDE driver for OBS Version 1.2.0"
+#define	OBS_IDE_RESET	(0x0008)	/* in Port C bit3 */
+
+static
+void obs_ide_init_hwif_ports (hw_regs_t *hw, ide_ioreg_t data_port,
+			      ide_ioreg_t ctrl_port, int *irq)
+{
+  ide_ioreg_t *p = hw->io_ports;
+  int i;
+  static unsigned long ide_base = 0;
+  static unsigned long ide_sub_base = 0;
+  unsigned long base;
+
+  *p = 0;
+  if (irq)
+    *irq = 0;
+
+  printk(KERN_INFO OBSIDE_VERSION_INFO "\n");
+
+  if (!ide_base) {
+ 
+    /* reset-pin setup */
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcpar &= ~OBS_IDE_RESET;
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdir |=  OBS_IDE_RESET;
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcso  &= ~OBS_IDE_RESET;
+
+    /* IDE RESET off, on, wait, off */
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat |=  OBS_IDE_RESET;
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat &= ~OBS_IDE_RESET;
+    udelay(100);
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat |=  OBS_IDE_RESET;
+    udelay(10);
+
+    /* IDE wake up */
+    for (i = 0; i < 1000; i++) {
+      /* FIXME: WDT clear in here */
+      udelay(100);
+    }
+
+    /* io area mapping */
+    ide_base = (unsigned long)
+      ioremap(CFG_ATA_BASE_ADDR, CFG_ATA_SIZE);
+    ide_sub_base = (unsigned long)
+      ioremap(CFG_ATA_SUB_BASE_ADDR, CFG_ATA_SUB_SIZE);
+  }
+
+  if (data_port >= MAX_HWIFS)
+    return;
+
+  base = ide_base;
+  
+  for (i = 0; i < IDE_NR_PORTS - 1; ++i) {
+    if (i == IDE_CONTROL_OFFSET) {
+      base = ide_sub_base;
+    }
+#ifdef DEBUG
+    printk ("IDE port[%d]: %08lx + %08lx = %08lx\n",
+	    i,
+	    base,
+	    ioport_dsc[data_port].reg_off[i],
+	    base + ioport_dsc[data_port].reg_off[i]);
+#endif
+    *p++ = base + ioport_dsc[data_port].reg_off[i];
+  }
+
+  /* 0x1e:status[BSY] check */
+  for (i = 0; i < 10000; i++) { 
+    udelay(400);
+    if ((*((volatile ushort *)hw->io_ports[IDE_STATUS_OFFSET])
+	 & BUSY_STAT) == 0) {
+      break;
+    }
+  }
+
+  printk ("IDE init %s\n", (i >= 10000) ? "timeout" : "done");
+
+  if (irq) {
+    /* direct connected IDE drive, i.e. external IRQ */
+    *irq = ioport_dsc[data_port].irq;
+  }
+
+  /* register routine to tune PIO mode */
+  ide_hwifs[data_port].tuneproc = m8xx_ide_tuneproc;
+
+  hw->ack_intr = (ide_ack_intr_t *) ide_interrupt_ack;
+  /* Enable Harddisk Interrupt,
+   * and make it edge sensitive
+   */
+  /* (11-18) Set edge detect for irq, no wakeup from low power mode */
+  ((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel |=
+    (0x80000000 >> ioport_dsc[data_port].irq);
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* ------------------------------------------------------------------------- */
+/*   *END*                                                                   */
+/* ------------------------------------------------------------------------- */
+
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/obs50_time.c linux-2.4.20/arch/ppc/platforms/obs50_time.c
--- linux-2.4.20.orig/arch/ppc/platforms/obs50_time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/obs50_time.c	2004-12-21 13:00:06.000000000 +0900
@@ -0,0 +1,392 @@
+/* @@ES TANIA */
+/*=============================================================================
+ *	Routines to get and set the system time from/to a Dallas DS1307/8
+ *	Real Time Clock chip.  Useful for MPC860-compatible boards which
+ *	do not supply "keep-alive" power to the CPU RTC registers.
+ *
+ *	Written for Century Systems' Embedded Server
+ *	2000.6.5
+ *	T. Oka
+ *	Century Systems, Inc.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * Modified by Century Systems Inc.(http://www.centurysys.co.jp/)
+ *
+ *============================================================================*/
+
+/*-----------------------------------------------------------------------------
+ *	RTC_REBOOT_NOTIFY (2000.6.16):
+ *	Kept for possible future use, but currently does not work
+ *	as intended.  It was designed to provide a method of saving
+ *	the current Linux time at shutdown, but for reasons as
+ *	yet unknown, the notification function is not consistently
+ *	called (seems to depend on the method used to shut down).
+ *----------------------------------------------------------------------------*/
+#undef RTC_REBOOT_NOTIFY
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/spinlock.h>
+#include <linux/mc146818rtc.h>
+#ifdef RTC_REBOOT_NOTIFY
+# include <linux/notifier.h>
+# include <linux/reboot.h>
+#endif
+#include <platforms/obs50_time.h>
+
+#include <asm/time.h> /* For to_tm() */
+#include <asm/errno.h>
+
+#ifndef BCD_TO_BIN
+# define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+# define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+/*-----------------------------------------------------------------------------
+ *	Define RTC_EPOCH_1970 to interpret the RTC 00..99 year as 1970..2069.
+ *	If undefined, the RTC year will be treated as an offset from a
+ *	configurable epoch.
+ *----------------------------------------------------------------------------*/
+#define RTC_EPOCH_1970
+
+#define RTC_DEFAULT_EPOCH	(2000)
+
+#define RTC_HW_WAIT		(200L)
+
+/* Identifies the DS1307/8 device on the bus. */
+#define RTC_DEV_ID		(0xd0)
+
+#define RTC_HW_INIT()		i2c_init()
+#define RTC_HW_RD(offset)	i2c_rd(RTC_DEV_ID, (offset), RTC_HW_WAIT)
+#define RTC_HW_WR(offset, val)	i2c_wr(RTC_DEV_ID, (offset), (val), RTC_HW_WAIT)
+
+/*-----------------------------------------------------------------------------
+ *	Offsets of RTC registers.
+ *	NOTE:  day of week register (offset 3) not used
+ *----------------------------------------------------------------------------*/
+#define RTC_REG_SEC	(0x00)
+#define RTC_REG_MIN	(0x01)
+#define RTC_REG_HOUR	(0x02)
+#define RTC_REG_DATE	(0x04)
+#define RTC_REG_MON	(0x05)
+#define RTC_REG_YEAR	(0x06)
+#define RTC_REG_CTRL	(0x07)
+
+extern void i2c_init(void);
+extern unsigned char i2c_rd(unsigned char, unsigned int, unsigned long);
+extern void i2c_wr(unsigned char, unsigned int, unsigned char, unsigned long);
+
+unsigned long obs_get_rtc_time(void);
+int obs_set_rtc_time(unsigned long);
+long obs_time_init(void);
+
+/*-----------------------------------------------------------------------------
+ *	Local prototypes.
+ *----------------------------------------------------------------------------*/
+
+#ifndef RTC_EPOCH_1970
+static int obs_is_valid_epoch(unsigned int epoch);
+static unsigned int obsk_get_epoch(void);
+static void obs_set_epoch(unsigned int epoch);
+#endif
+
+#ifdef RTC_REBOOT_NOTIFY
+int obs_on_shutdown(struct notifier_block *this, unsigned long code, void *unused);
+#else /* RTC_REBOOT_NOTIFY */
+void obs_on_shutdown(void);
+#endif /* RTC_REBOOT_NOTIFY */
+
+#ifdef RTC_REBOOT_NOTIFY
+/*-----------------------------------------------------------------------------
+ *	Structure used for shutdown/reboot notification.
+ *----------------------------------------------------------------------------*/
+static struct notifier_block rtcbak_notifier = {obs_on_shutdown, NULL, 0};
+#endif
+
+/*-----------------------------------------------------------------------------
+ *	Returns the date/time read from the RTC chip, converted to
+ *	seconds since 1970-01-01 00:00:00.
+ *
+ *	CAUTION:
+ *	Uses mktime() to perform the conversion, and thus is subject
+ *	to any overflow problems that function has.
+ *----------------------------------------------------------------------------*/
+unsigned long obs_get_rtc_time(void)
+{
+	unsigned int	yr, mo, dt, hr, mn, sc;
+	unsigned int	tmp;	/* used in converting hours to 24-hour clock */
+	unsigned long	flags;
+
+	save_flags(flags);
+	cli();
+	yr = (unsigned int) RTC_HW_RD(RTC_REG_YEAR);
+	mo = (unsigned int) RTC_HW_RD(RTC_REG_MON);
+	dt = (unsigned int) RTC_HW_RD(RTC_REG_DATE);
+	hr = (unsigned int) RTC_HW_RD(RTC_REG_HOUR);
+	mn = (unsigned int) RTC_HW_RD(RTC_REG_MIN);
+	sc = (unsigned int) RTC_HW_RD(RTC_REG_SEC);
+	restore_flags(flags);
+
+	/* mask out unused or other-purpose bits */
+	mo &= 0x0000001f;
+	dt &= 0x0000003f;
+	if ((hr & 0x00000060) == 0x00000060) {
+		/* 12-hour mode, P.M. - convert to 24-hour format */
+		tmp = hr & 0x0000001f;
+		BCD_TO_BIN(tmp);
+		tmp += 12;
+		BIN_TO_BCD(tmp);	/* reverse back to BCD for below */
+		hr = tmp;
+	}
+	else {
+		/* 24-hour clock or
+			12-hour A.M. (A.M. bit is 0 so can use same mask) */
+		if ((hr & 0x00000070) == 0x00000030) {
+			/* this probably should not happen, but it does... */
+			hr &= 0x0000001f;
+		}
+		hr &= 0x0000003f;
+	}
+	mn &= 0x0000007f;
+	sc &= 0x0000007f;	/* mask out CH bit */
+
+	BCD_TO_BIN(yr);
+	BCD_TO_BIN(mo);
+	BCD_TO_BIN(dt);
+	BCD_TO_BIN(hr);
+	BCD_TO_BIN(mn);
+	BCD_TO_BIN(sc);
+
+	/* do not use bad values from the RTC */
+	if ((yr > 99) || (mo < 1 || mo > 12) || (dt < 1 || dt > 31) ||
+					(hr > 23) || (mn > 59) || (sc > 59)) {
+		/* illegal value */
+		return (mktime(1970, 1, 1, 0, 0, 0));	/* EARLY RETURN */
+	}
+
+#ifdef RTC_EPOCH_1970
+	/*
+	 *	The 00..99 year range supported by the chip is used
+	 *	as an offset from 1970.
+	 */
+	yr += ((yr <= 69) ? 2000 : 1900);
+#else
+	/*
+	 *	The 00..99 year range supported by the chip is used
+	 *	as an offset from the current epoch.
+	 */
+	yr += obs_get_epoch();
+#endif
+
+	return (mktime(yr, mo, dt, hr, mn, sc));
+}	/* obs_set_rtc_time() */
+
+/*-----------------------------------------------------------------------------
+ *	Sets the given date/time to the RTC chip.
+ *
+ *	tv_sec is interpreted as the number of seconds since
+ *	1970-0101 00:00:00 UTC.
+ *
+ *	CAUTION:
+ *	Uses to_tm() to perform the conversion, and thus is subject
+ *	to any overflow problems that function has.
+ *----------------------------------------------------------------------------*/
+int obs_set_rtc_time(unsigned long tv_sec)
+{
+	struct rtc_time	rtc;
+	unsigned long	flags;
+	unsigned char	yr, mo, dt, hr, mn, sc;
+	unsigned int	year;
+#ifndef RTC_EPOCH_1970
+	unsigned int	new_epoch;
+#endif
+
+	/* convert to a Gregorian date (includes leap year adjustments, etc.) */
+	to_tm(tv_sec, &rtc);
+
+#ifdef RTC_EPOCH_1970
+	if ((rtc.tm_year < 1970) || (rtc.tm_year > 2069)) {
+		/* year out of range 1970..2069 */
+		return (-EINVAL);	/* EARLY RETURN */
+	}
+	else {
+		year = rtc.tm_year;
+		year -= ((year < 2000) ? 1900 : 2000);
+	}
+#else
+	year = (unsigned int) rtc.tm_year;
+	new_epoch = year - (year % 100);
+
+	if (obs_get_epoch() == new_epoch) {
+		year -= new_epoch;
+	}
+	else {
+		if (obs_is_valid_epoch(new_epoch)) {
+			obs_set_epoch(new_epoch);
+			year -= new_epoch;
+		}
+		else {
+			/* illegal epoch! */
+			/* old epoch value will be used */
+			year %= 100;
+		}
+	}	/* epoch has changed */
+#endif
+	/* year is now a 00..99 offset from the (possibly new) epoch */
+
+	yr = year;
+	mo = rtc.tm_mon;
+	dt = rtc.tm_mday;
+	hr = rtc.tm_hour;
+	mn = rtc.tm_min;
+	sc = rtc.tm_sec;
+
+	/* do not set bad values to the RTC */
+	if ((yr > 99) || (mo < 1 || mo > 12) || (dt < 1 || dt > 31) ||
+					(hr > 23) || (mn > 59) || (sc > 59)) {
+		/* illegal value ignored */
+		return (-EINVAL);	/* EARLY RETURN */
+	}
+
+	/* convert to Binary-Coded Decimal format used by RTC chip */
+	BIN_TO_BCD(yr);
+	BIN_TO_BCD(mo);
+	BIN_TO_BCD(dt);
+	BIN_TO_BCD(hr);
+	BIN_TO_BCD(mn);
+	BIN_TO_BCD(sc);
+
+	hr &= ~(0x40);		/* need 24-hour clock */
+	sc &= ~0x80;		/* make sure oscillator enabled (CH) */
+
+	/* write it to the RTC chip */
+	save_flags(flags);
+	cli();
+	RTC_HW_WR(RTC_REG_YEAR, yr);
+	RTC_HW_WR(RTC_REG_MON, mo);
+	RTC_HW_WR(RTC_REG_DATE, dt);
+	RTC_HW_WR(RTC_REG_HOUR, hr);
+	RTC_HW_WR(RTC_REG_MIN, mn);
+	RTC_HW_WR(RTC_REG_SEC, sc);
+	restore_flags(flags);
+
+	return (0);
+}	/* obs_set_rtc_time() */
+
+#ifndef RTC_EPOCH_1970
+/*-----------------------------------------------------------------------------
+ *	Determines if value is acceptable as an epoch (not out of range
+ *	for conversion functions).
+ *----------------------------------------------------------------------------*/
+int obs_is_valid_epoch(unsigned int epoch)
+{
+	if (epoch > 1900) {
+		return (1);
+	}
+	return (0);
+}	/* obs_is_valid_epoch() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+unsigned int obs_get_epoch(void)
+{
+	unsigned int	epoch;
+	int		fd;
+
+#ifdef TODO
+	epoch = read from file or get from parameter?;
+#else
+	epoch = RTC_DEFAULT_EPOCH;
+#endif
+	if (!obs_is_valid_epoch(epoch)) {
+		epoch = RTC_DEFAULT_EPOCH;
+	}
+
+	return (epoch);
+}	/* obs_get_epoch() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+void obs_set_epoch(unsigned int epoch)
+{
+	/* TODO write epoch to file or parameter */
+}	/* obs_set_epoch() */
+#endif
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+long __init obs_time_init(void)
+{
+	unsigned long	flags;
+	unsigned char	tmp;	/* temporarily holds register value */
+	struct timeval	tv;
+
+	printk(KERN_INFO "RTC Backup utility\n");
+
+	save_flags(flags);
+	cli();
+
+	RTC_HW_INIT();	/* initialize hardware */
+
+	/* make sure oscillator is enabled */
+	tmp = RTC_HW_RD(RTC_REG_SEC);
+	if (tmp & 0x80) {
+		tmp &= ~(0x80);		/* clear CH bit */
+		RTC_HW_WR(RTC_REG_SEC, tmp);
+	}
+
+	/* initialize control register */
+	RTC_HW_WR(RTC_REG_CTRL, 0x00);	/* OUT low, SQW disabled, freq 1 Hz */
+
+	restore_flags(flags);
+
+	tv.tv_usec = 0;
+	tv.tv_sec = obs_get_rtc_time();
+	do_settimeofday(&tv);
+
+#ifdef RTC_REBOOT_NOTIFY
+	/*
+	 *	Arrange to be notified at shutdown so that we can update the
+	 *	Dallas RTC with the current system time.
+ 	 *
+	 *	One of the reasons for doing it this way is so that the saved
+	 *	value is consistent with the automatic adjustments Linux makes
+	 *	to keep the time accurate.  Another is epoch wraps.
+	 */
+	register_reboot_notifier(&obs_notifier);
+#endif
+	return (0);
+}	/* obs_time_init() */
+
+#ifdef RTC_REBOOT_NOTIFY
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+int obs_on_shutdown(struct notifier_block *this, unsigned long code, void *unused)
+{
+	struct timeval	xtv;
+
+	/* get current system time value */
+	do_gettimeofday(&xtv);
+
+	/* write it to the RTC chip */
+	obs_set_time(xtv.tv_sec);
+
+	return (NOTIFY_DONE);
+}	/* rtcbak_on_shutdown() */
+#endif
+
+#ifndef RTC_REBOOT_NOTIFY
+void obs_on_shutdown(void) {}
+#endif /* RTC_REBOOT_NOTIFY */
+
+/* module_init(rtcbak_init); */
+/* module_exit(rtcbak_on_shutdown); */
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/obs50_time.h linux-2.4.20/arch/ppc/platforms/obs50_time.h
--- linux-2.4.20.orig/arch/ppc/platforms/obs50_time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/obs50_time.h	2004-12-21 13:00:06.000000000 +0900
@@ -0,0 +1,34 @@
+/*
+ * arch/ppc/platforms/obs50_time.h
+ *
+ * This header file is extracted from the corresponding C source file
+ * obs_time.c, which is written by
+ *
+ *    T. Oka
+ *    Century Systems, Inc.
+ *    
+ * Copyright 2003 S.Adachi
+ *    
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version. 
+ */ 
+
+#ifndef __PLATFORMS_OBS50_TIME_H__
+#define __PLATFORMS_OBS50_TIME_H__
+
+extern unsigned long obs_get_rtc_time(void);
+extern int obs_set_rtc_time(unsigned long tv_sec);
+extern int obs_is_valid_epoch(unsigned int epoch);
+extern unsigned int obs_get_epoch(void);
+extern void obs_set_epoch(unsigned int epoch);
+extern long __init obs_time_init(void);
+
+#ifdef RTC_REBOOT_NOTIFY
+extern int obs_on_shutdown(struct notifier_block *this, unsigned long code, void *unused);
+#else /* RTC_REBOOT_NOTIFY */
+extern void obs_on_shutdown(void);
+#endif /* RTC_REBOOT_NOTIFY */
+
+#endif /* __PLATFORMS_OBS50_TIME_H__ */
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/openblocks200.c linux-2.4.20/arch/ppc/platforms/openblocks200.c
--- linux-2.4.20.orig/arch/ppc/platforms/openblocks200.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/openblocks200.c	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,572 @@
+/*
+ *
+ *    Copyright (c) 2002 OZAWA Takahiro <obss@ozawa.cc>
+ *      derived from walnut.c and ppc4xx_setup.c
+ *
+ *    Copyrigh t(c) 1999-2000 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000-2001 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: openbloks200.c
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      IBM PowerPC 4xx based boards. Adapted from original
+ *      code by Gary Thomas, Cort Dougan <cort@fsmlabs.com>, and Dan Malek
+ *      <dan@net4x.com>.
+ *
+ *      History: 11/09/2001 - armin
+ *      added board_init to add in additional instuctions needed during platfrom_init
+ *
+ *      01/22/2002 - Armin
+ *      converted pci to ocp
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Alter the IRQ mapping to suit Century's board
+ *		- EEPROM support
+ *		- RTC support
+ *		- Century's IDE support
+ *      2002-03-21 - ozawa
+ *	      split OpenBlockSS's logic from walnut.c and ppc4xx_setup.c
+ *      2002-06-17 - ozawa
+ *		brush up rtc
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- rename openblokss.c to obs200.c
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- rename obs200.c openbloks200.c
+ *
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/pci.h>
+#include <linux/rtc.h>
+#include <linux/ide.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <platforms/ibm_ocp.h>
+
+#define IIC0_MDBUF	((volatile unsigned char *)(IIC0_BASE + 0x00))
+#define IIC0_SDBUF	((volatile unsigned char *)(IIC0_BASE + 0x02))
+#define IIC0_LMADR	((volatile unsigned char *)(IIC0_BASE + 0x04))
+#define IIC0_HMADR	((volatile unsigned char *)(IIC0_BASE + 0x05))
+#define IIC0_CNTL	((volatile unsigned char *)(IIC0_BASE + 0x06))
+#define IIC0_MDCNTL	((volatile unsigned char *)(IIC0_BASE + 0x07))
+#define IIC0_STS	((volatile unsigned char *)(IIC0_BASE + 0x08))
+#define IIC0_EXTSTS	((volatile unsigned char *)(IIC0_BASE + 0x09))
+#define IIC0_LSADR	((volatile unsigned char *)(IIC0_BASE + 0x0a))
+#define IIC0_HSADR	((volatile unsigned char *)(IIC0_BASE + 0x0b))
+#define IIC0_CLKDIV	((volatile unsigned char *)(IIC0_BASE + 0x0c))
+#define IIC0_INTRMSK	((volatile unsigned char *)(IIC0_BASE + 0x0d))
+#define IIC0_XFRCNT	((volatile unsigned char *)(IIC0_BASE + 0x0e))
+#define IIC0_XTCNTLSS	((volatile unsigned char *)(IIC0_BASE + 0x0f))
+#define IIC0_DIRECTCNTL	((volatile unsigned char *)(IIC0_BASE + 0x10))
+
+#define EEPROMTimeOut 16
+#define EEPROMDeviceCode 0xa0
+#define RTCDeviceCode 0xd0
+
+static void EEPROMInit (void);
+static int EEPROMDone(void);
+static int EEPROMWriteByte(unsigned char DeviceCode, unsigned short address, unsigned char data);
+static int EEPROMReadByte(unsigned char DeviceCode, unsigned short address, unsigned char *data);
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+/* Some IRQs unique to OpenBlockSS.
+ * Used by the generic 405 PCI setup functions in ppc4xx_pci.c
+ */
+int __init
+ppc405_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	/*
+	 *      PCI IDSEL/INTPIN->INTLINE
+	 *      A       B       C       D
+	 */
+	{
+                {28, 28, 28, 28},       /* IDSEL 7 - PCI slot 1 */
+                {26, 26, 26, 26},       /* IDSEL 8 - PCI slot 2 */
+                {27, 27, 27, 27},       /* IDSEL 9 - PCI slot 3 */
+        };
+	const long min_idsel = 7, max_idsel = 9, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+
+/* note that board_setup_arch is called from init's start_kernel
+   via ppc4xx_setup_arch */
+void __init
+board_setup_arch(void)
+{
+#ifdef CONFIG_IDE
+#define IDE_INIT_TIMEOUT 100
+        volatile unsigned short *cmdsts = (volatile unsigned short *)OBSS_ATACTRL_ADDR;
+        volatile unsigned short *base = (volatile unsigned short *)OBSS_ATAREG_ADDR;
+        int i;
+        unsigned short stat;
+
+        /* RESET IDE i/f pAsic */
+        printk("[board_setup_arch] Initializing IDE I/F\n");
+        mtdcr(DCRN_CHCR1, (mfdcr(DCRN_CHCR1) | 0x00004000));
+        mdelay(5);
+        *cmdsts = 0x0001;
+        mdelay(5);
+        *cmdsts = 0x0002;
+        mdelay(5);
+        *cmdsts = 0x4000;
+        DBG("[board_setup_arch] Byte swap %x\n", *cmdsts);
+
+        /* map IDE regs & wait  */
+        DBG("[board_setup_arch] Waiting for IDE devices\n");
+        for(i=0; i<IDE_INIT_TIMEOUT; i++)
+        {
+                mdelay(5);
+                mdelay(5);
+                stat = *(base + (IDE_STATUS_OFFSET-IDE_DATA_OFFSET));
+                if( (stat & 0x8000) == 0) break;    /* reset complete */
+        }
+        if(i>= IDE_INIT_TIMEOUT)
+                printk("[board_setup_arch] IDE devices TIMEOUT\n");
+#endif  /* CONFIG_IDE */
+}
+
+
+void __init
+bios_fixup(struct pci_controller *hose, void *pcil0_base)
+{
+
+	unsigned int bar_response, bar;
+	struct pcil0_regs *pcip;
+	/*
+	 * Expected PCI mapping:
+	 *
+	 *  PLB addr             PCI memory addr
+	 *  ---------------------       ---------------------
+	 *  0000'0000 - 7fff'ffff <---  0000'0000 - 7fff'ffff
+	 *  8000'0000 - Bfff'ffff --->  8000'0000 - Bfff'ffff
+	 *
+	 *  PLB addr             PCI io addr
+	 *  ---------------------       ---------------------
+	 *  e800'0000 - e800'ffff --->  0000'0000 - 0001'0000
+	 *
+	 * The following code is simplified by assuming that the bootrom
+	 * has been well behaved in following this mapping.
+	 */
+
+#ifdef DEBUG
+	int i;
+	pcip = (struct pcil0_regs *) pcil0_base;
+
+	printk("ioremap PCLIO_BASE = 0x%x\n", pcip);
+	printk("PCI bridge regs before fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#else
+	pcip = (struct pcil0_regs *) pcil0_base;
+#endif
+
+	/* added for IBM boot rom version 1.15 bios bar changes  -AK */
+
+	/* Disable region first */
+	out_le32((void *) &(pcip->pmm[0].ma), 0x00000000);
+	/* PLB starting addr, PCI: 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].la), 0x80000000);
+	/* PCI start addr, 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].pcila), PPC405_PCI_MEM_BASE);
+	/* 512MB range of PLB to PCI */
+	out_le32((void *) &(pcip->pmm[0].pciha), 0x00000000);
+	/* Enable no pre-fetch, enable region */
+	out_le32((void *) &(pcip->pmm[0].ma), ((0xffffffff -
+						(PPC405_PCI_UPPER_MEM -
+						 PPC405_PCI_MEM_BASE)) | 0x01));
+
+	/* Disable region one */
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm1ms), 0x00000000);
+
+	/* Disable region two */
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm2ms), 0x00000000);
+
+	/* Zero config bars */
+	for (bar = PCI_BASE_ADDRESS_1; bar <= PCI_BASE_ADDRESS_2; bar += 4) {
+		early_write_config_dword(hose, hose->first_busno,
+					 PCI_FUNC(hose->first_busno), bar,
+					 0x00000000);
+		early_read_config_dword(hose, hose->first_busno,
+					PCI_FUNC(hose->first_busno), bar,
+					&bar_response);
+		DBG("BUS %d, device %d, Function %d bar 0x%8.8x is 0x%8.8x\n",
+		    hose->first_busno, PCI_SLOT(hose->first_busno),
+		    PCI_FUNC(hose->first_busno), bar, bar_response);
+	}
+	/* end work arround */
+
+#ifdef DEBUG
+	printk("PCI bridge regs after fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+}
+
+/* note that board_io_mapping is called from MMU_init of mm/init.c
+   via m4xx_map_io */
+void __init
+board_io_mapping(void)
+{
+	DBG("[board_io_mapping] Mapping seg-LED, ATA\n");
+	io_block_mapping(OBSS_SEGLED_ADDR, OBSS_SEGLED_ADDR,
+	  OBSS_SEGLED_SIZE, _PAGE_IO);
+	io_block_mapping(OBSS_ATAREG_ADDR, OBSS_ATAREG_ADDR,
+	  OBSS_ATAREG_SIZE, _PAGE_IO);
+	io_block_mapping(OBSS_ATACTRL_ADDR, OBSS_ATACTRL_ADDR,
+	  OBSS_ATACTRL_SIZE, _PAGE_IO);
+}
+
+#define IRQ25AND31     ((1<<(31-25))|(1<<(31-31)))
+void __init
+board_setup_irq(void)
+{
+        DBG("[board_setup_irq] set irq 25 and 31 are level-sensitive\n");
+        /* irq31(405eth re-link) and irq25(push sw) are leve-sensitive */
+        mtdcr(DCRN_UIC_TR(UIC0), mfdcr(DCRN_UIC_TR(UIC0)) | IRQ25AND31);
+        /* if level-sensitive interrupt, then clear bit in the status register */
+        DBG("[board_setup_irq] clear status register for level-sensitive irqs\n");
+        mtdcr(DCRN_UIC_SR(UIC0), ~(mfdcr(DCRN_UIC_TR(UIC0))));
+}
+
+static void
+EEPROMInit ()
+{
+	writeb(0x00, IIC0_LMADR);	/* clear low master addr */
+	writeb(0x00, IIC0_HMADR);	/* clear high master addr */
+	writeb(0x00, IIC0_LSADR);	/* clear low slave addr */
+	writeb(0x00, IIC0_HSADR);	/* clear high slave addr */
+	writeb(0x0A, IIC0_STS);		/* clear status */
+	writeb(0x8F, IIC0_EXTSTS);	/* clear extended status */
+	writeb(0x04, IIC0_CLKDIV);	/* set clock division */
+	writeb(0x00, IIC0_INTRMSK);	/* disable interrupt */
+	writeb(0x00, IIC0_XFRCNT);	/* clear transfer count */
+	writeb(0xF0, IIC0_EXTSTS);	/* clear extended control and status */
+	writeb(0x43, IIC0_MDCNTL);	/* set mode control */
+	writeb(0x00, IIC0_CNTL);	/* clear control */
+}
+
+static int
+EEPROMWriteByte(unsigned char DeviceCode, unsigned short address, unsigned char data)
+{
+	writeb(0x0A, IIC0_STS);		/* clear status */
+
+	writeb(readb(IIC0_MDCNTL)|0x40, IIC0_MDCNTL);	/* flush master data buffer */
+	writeb(DeviceCode, IIC0_LMADR);		/* transmit device code */
+	writeb(address, IIC0_MDBUF);		/* transmit address */
+	writeb(data, IIC0_MDBUF);			/* transmit datum */
+	writeb(0x11, IIC0_CNTL);	/* start transmission */
+	if (EEPROMDone() != 0) return -1;
+	return 0;
+}
+
+static int
+EEPROMReadByte(unsigned char DeviceCode, unsigned short address, unsigned char *data)
+{
+	writeb(0x0A, IIC0_STS);		/* clear status */
+
+	writeb(readb(IIC0_MDCNTL)|0x40, IIC0_MDCNTL);	/* flush master data buffer */
+	writeb(DeviceCode, IIC0_LMADR);		/* transmit device code */
+	writeb(address, IIC0_MDBUF);		/* transmit address */
+	writeb(0x01, IIC0_CNTL);	/* start transmission */
+	if (EEPROMDone() != 0) return -1;
+
+	writeb(readb(IIC0_MDCNTL)|0x40, IIC0_MDCNTL);	/* flush master data buffer */
+	writeb(DeviceCode|0x01, IIC0_LMADR);	/* transmit device code */
+	writeb(0x03, IIC0_CNTL);	/* start transmission */
+	if (EEPROMDone() != 0) return -1;
+
+	*data = readb(IIC0_MDBUF);
+	return 0;
+}
+
+static int
+EEPROMDone()
+{
+	int i;
+	unsigned char status;
+
+	for (i = EEPROMTimeOut; i > 0; i--)
+	{
+		status = readb(IIC0_STS);
+		if ((status & 0x01) == 0x00)
+		{
+			writeb(0x0A, IIC0_STS);		/* clear status */
+			if (status & 0x04) return -2;	/* error */
+			return(0);
+		}
+		udelay(100);
+	}
+	return(-1);
+}
+
+
+static long
+obss_time_init(void)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~IBM_CPM_IIC0);
+	EEPROMInit();
+	return 0;
+}
+
+
+static int
+obss_set_rtc_time(unsigned long nowtime)
+{
+	struct rtc_time   tm;
+	unsigned char     tmp;
+	unsigned short	  address = 0x0000;
+	int 		  r_code;
+
+	to_tm(nowtime, &tm);
+
+	tmp = tm.tm_sec ;  tm.tm_sec  = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_min ;  tm.tm_min  = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_hour;  tm.tm_hour = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_wday;  tm.tm_wday = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_mday;  tm.tm_mday = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_mon ;  tm.tm_mon  = ((tmp / 10) << 4) + (tmp % 10);
+	tm.tm_year -= 2000;
+	tmp = tm.tm_year;  tm.tm_year = ((tmp / 10) << 4) + (tmp % 10);
+
+	DBG("[obss_set_rtc_time] Seconds %d %d\n", tm.tm_sec, (tm.tm_sec & 0x7f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_sec & 0x7f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Minutes %d %d\n", tm.tm_min, (tm.tm_min & 0x7f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_min & 0x7f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Hours %d %d\n", tm.tm_hour, (tm.tm_hour & 0x7f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_hour & 0x3f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Wday %d %d\n", tm.tm_wday, (tm.tm_wday & 0x1f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_wday & 0x1f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Mday %d %d\n", tm.tm_mday, (tm.tm_mday & 0x3f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_mday & 0x3f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Month %d %d\n", tm.tm_mon, (tm.tm_mon & 0x1f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_mon & 0x1f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Year %d %d\n", tm.tm_year, tm.tm_year);
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_year));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	return 0;
+}
+
+static unsigned long
+obss_get_rtc_time(void)
+{
+	unsigned char tmp;
+	unsigned int year, mon, mday, day, hour, min, sec;
+	unsigned short address = 0x0000;
+	int r_code;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	sec = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	min = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	hour = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	day = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	mday = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	mon = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	year = tmp;
+	sec     = sec & 0x7f;
+	min     = min & 0x7f;
+	hour    = hour & 0x3f;
+	mon     = mon & 0x1f;
+	mday    = mday & 0x3f;
+
+	tmp = sec    ;  sec     = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = min    ;  min     = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = hour   ;  hour    = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = mday   ;  mday    = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = mon    ;  mon     = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = year   ;  year    = (tmp &0xf) + ((tmp >> 4) * 10);
+	year += 2000;
+
+	DBG("[obss_get_rtc_time] Year %d Month %d Day %d Hour %d Min %d Sec %d %u\n", year, mon, mday, hour, min, sec, mktime(year, mon, mday, hour, min, sec));
+	return mktime(year, mon, mday, hour, min, sec);
+}
+
+static void
+obss_ide_init_hwif_ports(hw_regs_t *hw, ide_ioreg_t data_port, ide_ioreg_t ctrl_port, int *irq)
+{
+        int i;
+        ide_ioreg_t reg, base;
+
+        if (data_port != 0) return;     /* ignore it if the default attribute is defined */
+
+        base = (ide_ioreg_t)ioremap(OBSS_ATAREG_ADDR, OBSS_ATAREG_SIZE);
+        if (base == 0) panic("[obss_ide_init_hwif_ports] ioremap failed\n");
+
+        for (i=IDE_DATA_OFFSET, reg=base; i<=IDE_STATUS_OFFSET; i++, reg+=2)
+        {
+                hw->io_ports[i] = reg;
+                DBG("[obss_ide_init_hwif_ports] FROM DATA OFFSET %d %x\n",
+			i, hw->io_ports[i]);
+        }
+
+        hw->io_ports[IDE_CONTROL_OFFSET] = base + 0x1c;
+        DBG("[obss_ide_init_hwif_ports] IDE CONTROL %x\n", hw->io_ports[IDE_CONTROL_OFFSET]);
+
+        if (irq) *irq = OBSS_ATA0_IRQ;
+}
+
+/* note that board_init is called before the mmu is initialized */
+void __init
+board_init(void)
+{
+#ifdef CONFIG_PPC_RTC
+        ppc_md.time_init = obss_time_init;
+        ppc_md.set_rtc_time = obss_set_rtc_time;
+        ppc_md.get_rtc_time = obss_get_rtc_time;
+#endif  /* CONFIG_PPC_RTC */
+#ifdef CONFIG_IDE
+        ppc_ide_md.ide_init_hwif = obss_ide_init_hwif_ports;
+#endif  /* CONFIG_IDE */
+
+}
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/openblocks200.h linux-2.4.20/arch/ppc/platforms/openblocks200.h
--- linux-2.4.20.orig/arch/ppc/platforms/openblocks200.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/openblocks200.h	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,123 @@
+/*
+ *
+ *    Copyright (c) 2002 OZAWA Takahiro <obss@ozawa.cc>
+ *      derived from walnut.h
+ *
+ *    Copyright (c) 1999 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000 MontaVista Software Inc.
+ *	PPC405 modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	frank_rowand@mvista.com or source@mvista.com
+ * 	   	debbie_chu@mvista.com
+ *
+ *    Module name: openbloks200.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      based boards.
+ *
+ *      This includes:
+ *
+ *         Plat'Home "OpenBlockS 200" micro server
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added bi_s_version[],bi_r_version[] in 'typedef struct board_info'
+ *		- rename openblokss.h to obs200.h
+ *		- rename obs200.h openbloks200.h
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_OBSS_H__
+#define __ASM_OBSS_H__
+
+/* We have a 405GP core */
+#include <platforms/ibm405gp.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * Data structure defining board information maintained by the
+ * embed_config() for OpenBlockSS while booting.
+ * ROM on IBM's "Walnut" evaluation board. An effort has been made to
+ * keep the field names consistent with the 8xx 'bd_t' board info
+ * structures.
+ */
+
+typedef struct board_info {
+	unsigned char	 bi_s_version[4];	/* Version of this structure */
+	unsigned char	 bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned char	 bi_enetaddr[6];	/* Local Ethernet MAC address */
+	unsigned char	 bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
+	unsigned int	 bi_mem;		/* DRAM installed, in mega bytes */
+	unsigned int	 bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	 bi_mode;		/* 0: Ramdisk, 1: Harddisk */
+	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+} bd_t;
+
+/* Some 4xx parts use a different timebase frequency from the internal clock.
+*/
+#define bi_tbfreq bi_intfreq
+
+/* OpenBlockSS specific definitions. */
+
+/* irq */
+#define OBSS_PSH_IRQ		25
+#define OBSS_ATA0_IRQ		29
+#define OBSS_PDOWN_IRQ		30
+#define OBSS_ETH_RELINK_IRQ	31
+
+/* ata register manipulation */
+#define HAVE_ARCH_OUT_BYTE
+#define OUT_BYTE(dat,port)	(out_le16((volatile unsigned short *)port, dat & 0xFF))
+#define OUT_WORD(dat,port)	(out_be16((volatile unsigned short *)port, dat & 0xFFFF))
+
+#define HAVE_ARCH_IN_BYTE
+#define IN_BYTE(port)		(in_le16((volatile unsigned short *)port) & 0xFF)
+#define IN_WORD(port)		in_be16((volatile unsigned short *)port)
+
+/* i/o map */
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+/* 0x00100000 (6-byte): 405GP internal ethernet mac address */
+#define OBSS_ENET_MACADDR	((unsigned char *)(0x00100000))
+/* 0x00100006 (8-bit):  Boot mode: 0=ramdisk, 1=hdd, other=recovery(ramdisk) */
+#define OBSS_BOOT_MODE		((unsigned char *)0x00100006)
+/* 0x00100007 (8-bit):  RAM size: 4, 8, 16, 32, 64, 128=nn MB, other=unknown */
+#define OBSS_RAM_SIZE		((unsigned char *)0x00100007)
+/* 0x40000000 (8-bit):  7-segment LED (see segled.h) */
+#define OBSS_SEGLED_ADDR	((uint)0x40000000)
+#define OBSS_SEGLED_SIZE	((uint)4*1024)
+/* 0x60000000 (+0x00..0x0F: ATA registers(even byte aligned), +0x1C: ATA control register) */
+#define OBSS_ATAREG_ADDR	((uint)0x60000000)
+#define OBSS_ATAREG_SIZE	((uint)4*1024)
+/* 0x70000000 (2-byte?: ATA host controller register) */
+#define OBSS_ATACTRL_ADDR	((uint)0x70000000)
+#define OBSS_ATACTRL_SIZE	((uint)4*1024)
+
+/* overwrite default in include/asm-ppc/ide.h */
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define	MAX_HWIFS	1
+
+#define BASE_BAUD		460800
+#define PPC4xx_MACHINE_NAME	"Plat'Home OpenBlockSS"
+
+/* overwrite PM sleeper in arch/ppc/platforms/ibm405gp.h */
+#undef DFLT_IBM4xx_PM
+#define DFLT_IBM4xx_PM		~(IBM_CPM_PCI | IBM_CPM_CPU | IBM_CPM_DMA \
+					| IBM_CPM_OPB | IBM_CPM_EBC \
+					| IBM_CPM_SDRAM0 | IBM_CPM_PLB \
+					| IBM_CPM_UIC | IBM_CPM_TMRCLK \
+					| IBM_CPM_IIC0 | IBM_CPM_UART0 | IBM_CPM_UART1 \
+					| IBM_CPM_EMAC0 | 0x00010000 | 0x00008000) /* enet rm, tm unit */
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_OBSS_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/openblocks266.c linux-2.4.20/arch/ppc/platforms/openblocks266.c
--- linux-2.4.20.orig/arch/ppc/platforms/openblocks266.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/openblocks266.c	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,345 @@
+/*
+ *
+ *    Copyright (c) 2003 AXE,Inc.
+ *    openblocks266.c: Based on walnut.c
+ *
+ *    Copyrigh t(c) 1999-2000 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000-2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: openblocks266.c
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      IBM PowerPC 4xx based boards. Adapted from original
+ *      code by Gary Thomas, Cort Dougan <cort@fsmlabs.com>, and Dan Malek
+ *      <dan@net4x.com>.
+ *
+ *      History: 11/09/2001 - armin
+ *      added board_init to add in additional instuctions needed during platfrom_init
+ *
+ *      01/22/2002 - Armin
+ *      converted pci to ocp
+ *
+ *
+ * Please read the COPYING file for all license details.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/pci.h>
+#include <linux/rtc.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/todc.h>
+#include <platforms/ibm_ocp.h>
+#include <asm/delay.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+void *kb_cs;
+void *kb_data;
+void *openblocks266_rtc_base;
+
+/* Some IRQs unique to OpenBlockS266.
+ * Used by the generic 405 PCI setup functions in ppc4xx_pci.c
+ */
+int __init
+ppc405_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	    /*
+	     *      PCI IDSEL/INTPIN->INTLINE
+	     *      A       B       C       D
+	     */
+	{
+		{28, 28, 28, 28},	/* IDSEL 1 - PCI slot 1 */
+		{29, 29, 29, 29},	/* IDSEL 2 - PCI slot 2 */
+		{30, 30, 30, 30},	/* IDSEL 3 - PCI slot 3 */
+		{31, 31, 31, 31},	/* IDSEL 4 - PCI slot 4 */
+	};
+
+	const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+
+void __init
+board_setup_arch(void)
+{
+#define OBS266_PS2_BASE		0xF0100000
+#define OBS266_FPGA_BASE	0xF0300000
+
+	void *fpga_brdc;
+	void *fpga_enable;
+	void *fpga_polarity;
+	void *fpga_status;
+	void *fpga_trigger;
+	
+	kb_data = ioremap(OBS266_PS2_BASE, 8);
+	if (!kb_data) {
+		printk(KERN_CRIT
+		       "openblocks266_setup_arch() kb_data ioremap failed\n");
+		return;
+	}
+
+	kb_cs = kb_data + 1;
+
+	fpga_status = ioremap(OBS266_FPGA_BASE, 8);
+	if (!fpga_status) {
+		printk(KERN_CRIT
+		       "openblocks266_setup_arch() fpga_status ioremap failed\n");
+		return;
+	}
+
+
+	fpga_enable = fpga_status + 1;
+	fpga_polarity = fpga_status + 2;
+	fpga_trigger = fpga_status + 3;
+	fpga_brdc = fpga_status + 4;
+
+	/* Identify the system */
+	printk("OpenBlockS port\n");
+	/* printk("IBM Walnut port (C) 2000-2002 MontaVista Software, Inc. (source@mvista.com)\n"); */
+}
+
+#ifdef NEVER
+static void obs_dump_pci_conf(struct pci_controller *hose, int bus, int devfn)
+{
+	u8 addr;
+	u32 buf;
+	printk("OpenBlockS: PCI configuration register dump (bus:%d,dev:%d,fn:%d)\n", bus, PCI_SLOT(devfn), PCI_FUNC(devfn));
+	for( addr=0; addr<0x80; addr+=4 ){
+		if( early_read_config_dword(hose, bus, devfn, addr, &buf) ){
+			printk("OpenBlockS: read error PCI:(bus:%d,dev:%d,fn:%d,addr:0x%02x)\n", bus, PCI_SLOT(devfn), PCI_FUNC(devfn), addr);
+		}
+		if( addr % 16 == 0 )
+			printk("%02x:", addr);
+		printk(" %08x", buf);
+		if( addr % 16 == 12 )
+			printk("\n");
+	}
+}
+#endif
+
+static void obs_reset_pci_bus(struct pci_controller *hose)
+{
+	u16 brdgopt2;
+
+	/* obs_dump_pci_conf(hose, 0, PCI_DEVFN(0,0)); */
+	if( early_read_config_word(hose, 0, PCI_DEVFN(0,0), 0x60, &brdgopt2) ){
+		printk("OpenBlockS: read error PCI:(bus:%d,dev:%d,fn:%d,addr:%02x)\n", 0,0,0, 0x60);
+		return;
+	}
+	if( early_write_config_word(hose, 0, PCI_DEVFN(0,0), 0x60, brdgopt2 | 0x1000) ){
+		printk("OpenBlockS: read error PCI:(bus:%d,dev:%d,fn:%d,addr:%02x)\n", 0,0,0, 0x60);
+		return;
+	}
+
+	udelay(1000); udelay(1000); udelay(1000); udelay(1000);
+
+	if( early_write_config_word(hose, 0, PCI_DEVFN(0,0), 0x60, (brdgopt2 & ~0x1000) & 0xffff) ){
+		printk("OpenBlockS: read error PCI:(bus:%d,dev:%d,fn:%d,addr:%02x)\n", 0,0,0, 0x60);
+
+	}
+}
+
+#ifdef NEVER
+static void obs_hpt371_dump_pci_conf(struct pci_controller *hose)
+{
+	obs_dump_pci_conf(hose, 0, PCI_DEVFN(3,0));
+}
+
+static void obs_hpt371_load_vender_id(struct pci_controller *hose)
+{
+	u32 ids;
+	u8 reg7bh;
+
+	if( early_read_config_dword(hose, 0, PCI_DEVFN(3,0), PCI_VENDOR_ID, &ids) ){
+		printk("OpenBlockS: HPT371: read error 1\n");
+		return;
+	}
+	if( ids == 0xffffffff || ids == 0x00000000 || ids == 0x0000ffff || ids == 0xffff0000 ){
+		printk("OpenBlockS: HPT371: not found device\n");
+		return;
+	}
+	if( ids == 0x00071103 ){
+#ifdef DEBUG
+		printk("OpenBlockS: HPT371: no need loading Vender ID\n");
+#endif
+		return;
+	}
+
+	if( early_read_config_byte(hose, 0, PCI_DEVFN(3,0), 0x7b, &reg7bh) ){
+		printk("OpenBlockS: HPT371: read error\n");
+		return;
+	}
+	printk("OpenBlockS: HPT371: try to change Vender ID %08x --> %08x\n", ids, 0x00071103);
+	if( early_write_config_byte(hose, 0, PCI_DEVFN(3,0), 0x7b, reg7bh | 0x40) ){
+		printk("OpenBlockS: HPT371: write error\n");
+		return;
+	}
+	if( early_write_config_dword(hose, 0, PCI_DEVFN(3,0), PCI_VENDOR_ID, 0x00071103) ){
+		printk("OpenBlockS: HPT371: write error\n");
+		return;
+	}
+	if( early_write_config_byte(hose, 0, PCI_DEVFN(3,0), 0x7b, reg7bh & ~0x40) ){
+		printk("OpenBlockS: HPT371: read error\n");
+		return;
+	}
+	if( early_read_config_dword(hose, 0, PCI_DEVFN(3,0), 0x00, &ids) ){
+		printk("OpenBlockS: HPT371: read error\n");
+		return;
+	}
+	if( ids != 0x00071103 ){
+		printk("OpenBlockS: HPT371: fail to set Vender ID (%08x)\n", ids);
+		return;
+	}
+}
+#endif /* NEVER */
+
+void __init
+bios_fixup(struct pci_controller *hose, struct pcil0_regs *pcip)
+{
+	/* Aviod a HPT371 vender ID broken problem in restart machine */
+	obs_reset_pci_bus(hose);
+
+	/* obs_hpt371_dump_pci_conf(hose); */
+	/* obs_hpt371_load_vender_id(hose);*/ /* Don't work... */
+
+#ifdef NEVER	/* OpenBlockS bios fixup is done at 405GPr ROM Monitor */
+	unsigned int bar_response, bar;
+	/*
+	 * Expected PCI mapping:
+	 *
+	 *  PLB addr             PCI memory addr
+	 *  ---------------------       ---------------------
+	 *  0000'0000 - 7fff'ffff <---  0000'0000 - 7fff'ffff
+	 *  8000'0000 - Bfff'ffff --->  8000'0000 - Bfff'ffff
+	 *
+	 *  PLB addr             PCI io addr
+	 *  ---------------------       ---------------------
+	 *  e800'0000 - e800'ffff --->  0000'0000 - 0001'0000
+	 *
+	 * The following code is simplified by assuming that the bootrom
+	 * has been well behaved in following this mapping.
+	 */
+
+#ifdef DEBUG
+	int i;
+
+	printk("ioremap PCLIO_BASE = 0x%x\n", pcip);
+	printk("PCI bridge regs before fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+
+	/* added for IBM boot rom version 1.15 bios bar changes  -AK */
+
+	/* Disable region first */
+	out_le32((void *) &(pcip->pmm[0].ma), 0x00000000);
+	/* PLB starting addr, PCI: 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].la), 0x80000000);
+	/* PCI start addr, 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].pcila), PPC405_PCI_MEM_BASE);
+	/* 512MB range of PLB to PCI */
+	out_le32((void *) &(pcip->pmm[0].pciha), 0x00000000);
+	/* Enable no pre-fetch, enable region */
+	out_le32((void *) &(pcip->pmm[0].ma), ((0xffffffff -
+						(PPC405_PCI_UPPER_MEM -
+						 PPC405_PCI_MEM_BASE)) | 0x01));
+
+	/* Disable region one */
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm1ms), 0x00000000);
+
+	/* Disable region two */
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm2ms), 0x00000000);
+
+	/* Zero config bars */
+	for (bar = PCI_BASE_ADDRESS_1; bar <= PCI_BASE_ADDRESS_2; bar += 4) {
+		early_write_config_dword(hose, hose->first_busno,
+					 PCI_FUNC(hose->first_busno), bar,
+					 0x00000000);
+		early_read_config_dword(hose, hose->first_busno,
+					PCI_FUNC(hose->first_busno), bar,
+					&bar_response);
+		DBG("BUS %d, device %d, Function %d bar 0x%8.8x is 0x%8.8x\n",
+		    hose->first_busno, PCI_SLOT(hose->first_busno),
+		    PCI_FUNC(hose->first_busno), bar, bar_response);
+	}
+	/* end work arround */
+
+#ifdef DEBUG
+	printk("PCI bridge regs after fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+#endif /* NEVER */
+}
+
+void __init
+board_io_mapping(void)
+{
+	io_block_mapping(OBS266_RTC_VADDR,
+			 OBS266_RTC_PADDR, OBS266_RTC_SIZE, _PAGE_IO);
+}
+
+void __init
+board_setup_irq(void)
+{
+}
+
+void __init
+board_init(void)
+{
+	ppc_md.time_init = NULL;
+	ppc_md.set_rtc_time = NULL;
+	ppc_md.get_rtc_time = NULL;
+	ppc_md.nvram_read_val = NULL;
+	ppc_md.nvram_write_val = NULL;
+}
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/openblocks266.h linux-2.4.20/arch/ppc/platforms/openblocks266.h
--- linux-2.4.20.orig/arch/ppc/platforms/openblocks266.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/openblocks266.h	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,92 @@
+/*
+ *
+ *    Copyright (c) 2003 AXE,Inc.
+ *    openblocks266.h: Based on walnut.h
+ *
+ *    Copyright (c) 1999 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000 MontaVista Software Inc.
+ *	PPC405 modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	frank_rowand@mvista.com or source@mvista.com
+ * 	   	debbie_chu@mvista.com
+ *
+ *    Module name: openblocks266.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      based boards.
+ *
+ *      This includes:
+ *
+ *         405GP "Walnut" evaluation board
+ *
+ * Please read the COPYING file for all license details.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_OBS266_H__
+#define __ASM_OBS266_H__
+
+/* We have a 405GPr core */
+#include <platforms/ibm405gpr.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * Data structure defining board information maintained by the boot
+ * ROM on IBM's "Walnut" evaluation board. An effort has been made to
+ * keep the field names consistent with the 8xx 'bd_t' board info
+ * structures.
+ */
+
+typedef struct board_info {
+	unsigned char	 bi_s_version[4];	/* Version of this structure */
+	unsigned char	 bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	 bi_memsize;		/* DRAM installed, in bytes */
+	unsigned char	 bi_enetaddr[6];	/* Local Ethernet MAC address */
+	unsigned char	 bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
+	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+} bd_t;
+
+/* Some 4xx parts use a different timebase frequency from the internal clock.
+*/
+#define bi_tbfreq bi_intfreq
+
+
+/* Memory map for the OpenBlockS266.
+ * Generic 4xx plus RTC.
+ */
+
+extern void *openblocks266_rtc_base;
+#define OBS266_RTC_PADDR	((uint)0xf0000000)
+#define OBS266_RTC_VADDR	OBS266_RTC_PADDR
+#define OBS266_RTC_SIZE	((uint)8*1024)
+
+/* ps2 keyboard and mouse */
+#define KEYBOARD_IRQ		25
+#define AUX_IRQ			26
+
+#ifdef CONFIG_PPC405GP_INTERNAL_CLOCK
+#define BASE_BAUD		201600
+#else
+#define BASE_BAUD               (7372800/16)
+#endif
+
+#define OBS266_PS2_BASE	0xF0100000
+#define OBS266_FPGA_BASE	0xF0300000
+
+
+extern void *kb_cs;
+extern void *kb_data;
+#define kbd_read_input()	readb(kb_data)
+#define kbd_read_status()	readb(kb_cs)
+#define kbd_write_output(val)	writeb(val, kb_data)
+#define kbd_write_command(val)	writeb(val, kb_cs)
+
+#define PPC4xx_MACHINE_NAME	"OpenBlockS266"
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_OBS266_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.20.orig/arch/ppc/platforms/openblocks50.h linux-2.4.20/arch/ppc/platforms/openblocks50.h
--- linux-2.4.20.orig/arch/ppc/platforms/openblocks50.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/arch/ppc/platforms/openblocks50.h	2004-12-21 12:27:03.000000000 +0900
@@ -0,0 +1,63 @@
+/*
+ * for OpenBlockS
+ * Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ */
+
+/*
+ * A collection of structures, addresses, and values associated with
+ * the Plat'Home OpenBlockS. Copied from the IVMS stuff.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_OBS_H__
+#define __ASM_OBS_H__
+
+#include <linux/config.h>
+
+#include <asm/ppcboot.h>
+
+/* Memory map
+ */
+#define	CFG_ATA_BASE_ADDR	((unsigned)0x80000000)
+#define	CFG_ATA_SIZE		((uint)4000)
+#define	CFG_ATA_SUB_BASE_ADDR	((unsigned)0x80200000)
+#define	CFG_ATA_SUB_SIZE	((uint)4000)
+#define	IMAP_ADDR		((uint)0xFF000000)
+#define IMAP_SIZE		((uint)(64 * 1024))
+
+/* Interrupt assignments.
+ */
+#define FEC_INTERRUPT	3		/* = SIU_LEVEL1 */
+#define CPM_INTERRUPT	5		/* = SIU_LEVEL2 */
+#define IDE0_INTERRUPT	8		/* = SIU_IRQ4 */
+#define PHY_INTERRUPT	10		/* = SIU_IRQ5 */
+
+/* override the default number of IDE hardware interfaces */
+#define	MAX_HWIFS	1
+
+/*
+ * Definitions for IDE0 Interface
+ */
+/* main area */
+#define IDE0_BASE_OFFSET		0	/* Base offset (dummy) */
+#define IDE0_DATA_REG_OFFSET		0x00000010
+#define IDE0_ERROR_REG_OFFSET		0x00000012
+#define IDE0_NSECTOR_REG_OFFSET		0x00000014
+#define IDE0_SECTOR_REG_OFFSET		0x00000016
+#define IDE0_LCYL_REG_OFFSET		0x00000018
+#define IDE0_HCYL_REG_OFFSET		0x0000001A
+#define IDE0_SELECT_REG_OFFSET		0x0000001C
+#define IDE0_STATUS_REG_OFFSET		0x0000001E
+/* sub area */
+#define IDE0_CONTROL_REG_OFFSET		0x0000000C
+#define IDE0_IRQ_REG_OFFSET		0x0000000E	/* not used */
+
+/* We don't use the 8259. */
+#define NR_8259_INTS	0
+
+/* ata register manipulation */
+#define OUT_WORD(w,p)	outw_p((w),(p))
+#define IN_WORD(p)	(short)inw_p(p)
+
+#endif /* __ASM_OBS_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.20.orig/drivers/char/Config.in linux-2.4.20/drivers/char/Config.in
--- linux-2.4.20.orig/drivers/char/Config.in	2002-12-11 11:39:52.000000000 +0900
+++ linux-2.4.20/drivers/char/Config.in	2004-12-21 12:27:03.000000000 +0900
@@ -272,6 +272,22 @@
 if [ "$CONFIG_PPC_ISERIES" != "y"  -a "$CONFIG_PPC_PSERIES" != "y" ]; then
    tristate 'Enhanced Real Time Clock Support' CONFIG_RTC
 fi   
+if [ "$CONFIG_I2C" = "y" ]; then
+   tristate 'X1226 RTC support' CONFIG_X1226_RTC
+   tristate 'I2C EEPROM support' CONFIG_I2C_EEPROM
+fi
+if [ "$CONFIG_OBS50" = "y" ]; then
+   tristate 'OpenBlockS Push button' CONFIG_OBS50_PUSHSW
+   tristate 'OpenBlockS Segment LED' CONFIG_OBS50_SLED
+fi
+if [ "$CONFIG_OBS200" = "y" ]; then
+   tristate 'OpenBlockS Push button' CONFIG_OBS200_PUSHSW
+   tristate 'OpenBlockS Segment LED' CONFIG_OBS200_SLED
+fi
+if [ "$CONFIG_OBS266" = "y" ]; then
+   tristate 'OpenBlockS Push button' CONFIG_OBS266_PUSHSW
+   tristate 'OpenBlockS LED' CONFIG_OBS266_LED
+fi
 if [ "$CONFIG_IA64" = "y" ]; then
    bool 'EFI Real Time Clock Services' CONFIG_EFI_RTC
 fi
diff -Naru linux-2.4.20.orig/drivers/char/Makefile linux-2.4.20/drivers/char/Makefile
--- linux-2.4.20.orig/drivers/char/Makefile	2002-12-11 11:39:46.000000000 +0900
+++ linux-2.4.20/drivers/char/Makefile	2004-12-21 12:27:04.000000000 +0900
@@ -228,6 +228,14 @@
 ifeq ($(CONFIG_ALL_PPC),)
   obj-$(CONFIG_NVRAM) += nvram.o
 endif
+obj-$(CONFIG_X1226_RTC) += x1226-rtc.o
+obj-$(CONFIG_I2C_EEPROM) += eepromi2c.o
+obj-$(CONFIG_OBS50_PUSHSW) += pushsw_obs50.o
+obj-$(CONFIG_OBS50_SLED) += segled_obs50.o
+obj-$(CONFIG_OBS200_PUSHSW) += pushsw_obs200.o
+obj-$(CONFIG_OBS200_SLED) += segled_obs200.o
+obj-$(CONFIG_OBS266_PUSHSW) += pushsw_obs266.o
+obj-$(CONFIG_OBS266_LED) += led_obs266.o
 obj-$(CONFIG_TOSHIBA) += toshiba.o
 obj-$(CONFIG_I8K) += i8k.o
 obj-$(CONFIG_DS1620) += ds1620.o
diff -Naru linux-2.4.20.orig/drivers/char/eepromi2c.c linux-2.4.20/drivers/char/eepromi2c.c
--- linux-2.4.20.orig/drivers/char/eepromi2c.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/drivers/char/eepromi2c.c	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,444 @@
+/*
+ *  linux/drivers/char/eepromi2c.c
+ *
+ *
+ *  Copyright 
+ *  Author: 2002 AXE Inc.  
+ *     	takawata@axe-inc.co.jp
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  TODO:
+ *    - implement alarm and periodic IRQ support.
+ *
+ */
+/*
+ *  Based On 
+ *  linux/drivers/char/x1226-rtc.c
+ *
+ *  I2C Real Time Clock Client Driver for Xicor X1226 RTC/Calendar
+ *
+ *  Copyright 2002 MontaVista Software Inc.
+ *  Author: MontaVista Software, Inc.
+ *     	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  TODO:
+ *    - implement alarm and periodic IRQ support.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/rtc.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/time.h>
+#include <linux/devfs_fs_kernel.h>
+
+#define EEPROM_MAJOR 240
+struct eepromi2c_private
+{
+	u8 ei2_addr;
+	int ei2_size;
+	int ei2_maxpage;
+	int use_count;
+	unsigned char *tmpbuf;
+	struct i2c_client *ei2_i2c;
+	devfs_handle_t ei2_dfsh;
+};
+static spinlock_t eeprom_state_lock = SPIN_LOCK_UNLOCKED;
+
+
+struct eepromi2c_private eepromi2c_conf[]=
+{
+	{0x57, 0x200, 64, 0, NULL, NULL, NULL},
+	{0x51, 0x2000, 32, 0, NULL, NULL, NULL}
+};
+
+#define MAXEEPROMDEVS (sizeof(eepromi2c_conf)/ sizeof(struct eepromi2c_private))
+#ifndef I2C_DRIVER_ID_LARGEEEPROM
+#define I2C_DRIVERID_LARGEEEPROM I2C_DRIVERID_EXP1
+#endif
+#ifndef I2C_M_WR
+#define I2C_M_WR 0x0
+#endif
+
+#ifdef DEBUG_I2CEEPROM
+#define	dbg(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define	dbg(fmt, args...)
+#endif
+
+#define I2CEEPROM_MODULE_NAME "LARGEEEPROM"
+#define PFX I2CEEPROM_MODULE_NAME
+
+#define err(format, arg...) printk(KERN_ERR PFX ": " format , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format , ## arg)
+#define emerg(format, arg...) printk(KERN_EMERG PFX ": " format , ## arg)
+
+static struct i2c_driver i2ceeprom_driver;
+
+static int i2ceeprom_read(struct i2c_client *client,
+			  u16 reg_offset, u8 *buf, int len)
+{
+	int ret;
+	u8 regbuf[2] = { reg_offset>>8, reg_offset };
+	struct i2c_msg random_addr_read[2] = {
+		{
+			/* "Set Current Address" */
+			client->addr,
+			client->flags | I2C_M_WR,
+			sizeof(regbuf),
+			regbuf
+		},
+		{
+			/* "Sequential Read" if len>1,
+			   "Current Address Read" if len=1 */
+			client->addr ,
+			client->flags| I2C_M_RD ,
+			len,
+			buf
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, random_addr_read, 2)) != 2) {
+		ret = -ENXIO;
+		dbg("i2c_transfer failed\n");
+	}
+
+	return ret;
+}
+
+static int i2ceeprom_write(struct i2c_client *client,
+			   u16 reg_offset, u8 *buf, int len)
+{
+	int ret;
+	u8* local_buf;
+	u8 regbuf[2] = { reg_offset>>8, reg_offset };
+	struct i2c_msg page_write = {
+		client->addr,
+		client->flags ,
+		len + sizeof(regbuf),
+		NULL
+	};
+
+	if ((local_buf = (u8*)kmalloc(len + sizeof(regbuf),
+				      GFP_KERNEL)) == NULL) {
+		err("buffer alloc failed\n");
+		return -ENOMEM;
+	}
+
+	memcpy(local_buf, regbuf, sizeof(regbuf));
+	memcpy(local_buf + sizeof(regbuf), buf, len);
+	page_write.buf = local_buf;
+	
+	if ((ret = i2c_transfer(client->adapter, &page_write, 1)) != 1) {
+		ret = -ENXIO;
+		dbg("i2c_transfer failed\n");
+	}
+
+	kfree(local_buf);
+	return ret;
+}
+
+static long long eepromi2c_llseek(struct file *file, loff_t offset, int origin)
+{
+	int minor;
+	struct inode *minode = file->f_dentry->d_inode;
+	struct eepromi2c_private *pri;
+
+	if ((minor = MINOR(minode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	pri = &eepromi2c_conf[minor];
+	switch (origin) {
+	case 0:
+		file->f_pos = offset;
+		return file->f_pos;
+	case 1:
+		file->f_pos += offset;
+		return file->f_pos;
+	case 2:
+		file->f_pos = pri->ei2_size - offset;
+		return file->f_pos;
+	default:
+		return -EINVAL;
+	}
+}
+
+static ssize_t eepromi2c_read(struct file *file, char *buf, size_t count,
+			      loff_t *ppos)
+{
+	int minor;
+	struct i2c_client *client;
+	struct eepromi2c_private *pri;
+	int offset, remaining, copysize;
+	struct inode *minode = file->f_dentry->d_inode;
+	if ((minor = MINOR(minode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	pri = &eepromi2c_conf[minor];
+	if (!(client = pri->ei2_i2c))
+		return -ENXIO;
+	offset = *ppos;
+	if ((offset + count) > pri->ei2_size)
+		count = pri->ei2_size - offset;
+	if (count <= 0) {
+		return 0;
+	}
+	remaining = count;
+	do {
+		copysize = (remaining > pri->ei2_maxpage)
+				? pri->ei2_maxpage : remaining;
+		dbg("; copysize=%d\n", copysize);	
+		i2ceeprom_read(client, offset, pri->tmpbuf, copysize);
+		if (copy_to_user(buf, pri->tmpbuf, copysize))
+			return -EFAULT;
+		*ppos += copysize;
+		offset += copysize;
+		buf += copysize;
+		remaining -= copysize;
+	} while (remaining > 0);
+	return count;
+}
+
+static ssize_t eepromi2c_write(struct file *file, const char *buf, size_t count,
+			       loff_t *ppos)
+{
+	int minor;
+	struct i2c_client *client;
+	struct eepromi2c_private *pri;
+	int offset, remaining, copysize;
+	struct inode *minode = file->f_dentry->d_inode;
+	if ((minor = MINOR(minode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	pri = &eepromi2c_conf[minor];
+	if (!(client = pri->ei2_i2c))
+		return -ENXIO;
+	offset = *ppos;
+	if ((offset + count) > pri->ei2_size)
+		count = pri->ei2_size - offset;
+	if (count <= 0) {
+		return 0;
+	}
+	/*Write regeon should be aligned */
+	copysize = (count > pri->ei2_maxpage) ? pri->ei2_maxpage : count;
+	if ((offset / pri->ei2_maxpage) !=
+	    ((offset + copysize) / pri->ei2_maxpage))
+		copysize = pri->ei2_maxpage - (offset % pri->ei2_maxpage);
+	dbg("; offset=%d\n", offset);
+	remaining = count;
+	do {
+		dbg("; copysize=%d\n", copysize);
+		if (copy_from_user(pri->tmpbuf, buf, copysize)) {
+			return -EFAULT;
+		}
+
+		i2ceeprom_write(client, offset, pri->tmpbuf, copysize);
+		*ppos += copysize;
+		offset += copysize;
+		buf += copysize;
+		remaining -= copysize;
+		copysize = (remaining > pri->ei2_maxpage)
+				? pri->ei2_maxpage : remaining;
+	} while (remaining > 0);
+	return count;
+}
+
+int eepromi2c_open(struct inode *minode, struct file *mfile)
+{
+	int minor;
+	spin_lock(&eeprom_state_lock);
+	if ((minor = MINOR(minode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	if (!eepromi2c_conf[minor].ei2_i2c)
+		return -ENXIO;
+
+	if (eepromi2c_conf[minor].use_count)
+		return -EBUSY;
+	eepromi2c_conf[minor].use_count++;
+	spin_unlock(&eeprom_state_lock);
+	return 0;
+}
+
+static int eepromi2c_ioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	return -ENOTTY;
+}
+
+static int eepromi2c_release(struct inode *inode, struct file *file)
+{
+	int minor;
+	spin_lock(&eeprom_state_lock);
+	if ((minor = MINOR(inode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	eepromi2c_conf[minor].use_count--;
+	spin_unlock(&eeprom_state_lock);
+	return 0;
+}
+
+static struct file_operations eepromi2c_fops = {
+	owner:		THIS_MODULE,
+	llseek:		eepromi2c_llseek,
+	read:		eepromi2c_read,
+	write:		eepromi2c_write,
+	ioctl:		eepromi2c_ioctl,
+	open:		eepromi2c_open,
+	release:	eepromi2c_release,
+};
+
+
+
+
+static int i2ceeprom_probe(struct i2c_adapter *adap)
+{
+	int ret, res, i;
+#if 0
+	char nbuffer[15];
+#endif
+	unsigned char stat;
+	struct i2c_client *this_client;
+
+	res = -ENXIO;
+	devfs_register_chrdev(EEPROM_MAJOR, "eepromi2c", &eepromi2c_fops);
+
+	this_client = kmalloc(sizeof(*this_client), GFP_KERNEL);
+
+	for (i = 0; i < MAXEEPROMDEVS; i++) {
+		if (this_client == NULL) {
+			break;
+		}
+		strcpy(this_client->name, I2CEEPROM_MODULE_NAME);
+		this_client->id = i2ceeprom_driver.id;
+		this_client->flags = 0;
+		this_client->addr = eepromi2c_conf[i].ei2_addr;
+		this_client->adapter = adap;
+		this_client->driver = &i2ceeprom_driver;
+
+		if ((res = i2ceeprom_read(this_client, 0, &stat, 1)) < 0) {
+			printk("Probe read %d\n", res);
+			continue;
+		}
+
+		if ((eepromi2c_conf[i].tmpbuf =
+		     kmalloc(eepromi2c_conf[i].ei2_size, GFP_KERNEL)) == NULL) {
+			continue;
+		}
+
+		printk("Serial EEPROM FOUND at %x\n", this_client->addr);
+		if (i2c_attach_client(this_client)) {
+			continue;
+		}
+#if 0
+		/*DEVFS NOT SUPPORTED YET */
+		sprintf(buffer, "eepromi2c%d", i);
+		eepromi2c_conf[i].ei2_dfsh =
+			devfs_register(NULL, nbuffer, DEVFS_FL_DEFAULT,
+				       EEPROM_MAJOR, 2, S_IFCHR,
+				       &eepromi2c_fops, NULL);
+#endif
+		this_client->data = &eepromi2c_conf[i];
+		eepromi2c_conf[i].ei2_i2c = this_client;
+		ret = 0;	/*At least 1 dev found */
+		this_client = kmalloc(sizeof(*this_client), GFP_KERNEL);
+	}
+	kfree(this_client);
+	return ret;
+}
+
+static int i2ceeprom_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+
+	kfree(client);
+
+	return 0;
+}
+
+static int i2ceeprom_command(struct i2c_client *client, unsigned int cmd,
+			     void *arg)
+{
+
+	return -EINVAL;
+}
+
+
+static struct i2c_driver i2ceeprom_driver = {
+	name:		I2CEEPROM_MODULE_NAME,
+	id:		I2C_DRIVERID_LARGEEEPROM,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	i2ceeprom_probe,
+	detach_client:	i2ceeprom_detach,
+	command:	i2ceeprom_command
+};
+
+
+static __init int i2ceeprom_init(void)
+{
+	int ret;
+	
+	info("I2C based EEPROM driver.\n");
+	ret = i2c_add_driver(&i2ceeprom_driver);
+	if (ret) {
+		err("Register I2C driver failed, errno is %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit i2ceeprom_exit(void)
+{
+	i2c_del_driver(&i2ceeprom_driver);
+}
+
+module_init(i2ceeprom_init);
+module_exit(i2ceeprom_exit);
diff -Naru linux-2.4.20.orig/drivers/char/led_obs266.c linux-2.4.20/drivers/char/led_obs266.c
--- linux-2.4.20.orig/drivers/char/led_obs266.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/drivers/char/led_obs266.c	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,264 @@
+/*
+ * Copyright (c) AXE,Inc.
+ *	Based on ibm_ocp_gpio.c
+ */
+/*
+ * FILE NAME ibm_ocp_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  API for IBM PowerPC 4xx GPIO device.
+ *  Driver for IBM PowerPC 4xx GPIO device.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *          Debbie Chu   <debbie_chu@mvista.com>
+ *
+ * Copyright 2000,2001,2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *	TODO: devfs
+ *
+ *	Version: 02/01/12 - Armin
+ *			 converted to ocp and using ioremap
+ *
+ *	1.2 02/21/01 - Armin
+ *		minor compiler warning fixes
+ *
+ *	1.3 02/22/01 - Armin
+ *		added apm
+ *
+ *	1.4 05/07/02 - Armin/David Mueller
+ *		coverted to core_ocp[];
+ *
+ *	1.5 05/25/02 - Armin
+ *	 name change from *_driver to *_dev
+ *
+ *	1.6 06/04/02 - Matt Porter
+ *	ioremap paddr. Comment as 4xx generic driver.
+ *	Fix header to be userland safe and locate in
+ *	an accessible area.  Add ioctl to configure
+ *	multiplexed GPIO pins.
+ *
+ *	1.7 07/25/02 - Armin
+ *	added CPM to enable/disable in init/exit
+ *
+ */
+
+#define OBSLED_VER	"0.01"
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/pm.h>
+#include <linux/ibm_ocp_gpio.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/ocp.h>
+
+#define OBSLED_MINOR	SEGLED_MINOR
+
+struct miscdevice obsled_miscdev;
+static struct gpio_regs *gpiop;
+static int is_open = 0;
+
+#define GPIO_BIT(n)	(1 << (31 - (n)))
+#define PAT_1	GPIO_BIT(12)
+#define PAT_2	GPIO_BIT(13)
+#define PAT_4	GPIO_BIT(14)
+
+#ifdef CONFIG_PM
+static struct pm_dev *pm_gpio;
+
+static int
+gpio_save_state(u32 state)
+{
+	return 0;
+}
+
+static int
+gpio_suspend(u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | state);
+	return 0;
+}
+
+static int
+gpio_resume(u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~state);
+	return 0;
+}
+#endif
+
+static int
+obsled_out_reg(int led, u32 *or, u32 *tcr)
+{
+	__u32 data;
+	__u32 mask = PAT_1 | PAT_2 | PAT_4;
+	data = 0;
+	if (led & 1) data |= PAT_1;
+	if (led & 2) data |= PAT_2;
+	if (led & 4) data |= PAT_4;
+
+	*or = (*or & ~mask) | ((~data) & mask);
+	eieio();
+	*tcr = *tcr | mask;
+	eieio();
+	return 0;
+}
+
+int
+obsled_out_pat(int led)
+{
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	return obsled_out_reg(led, &gpiop->or, &gpiop->tcr);
+}
+
+static int
+obsled_open(struct inode *inode, struct file *file)
+{
+	if (is_open) return -EALREADY;
+	is_open = 1;
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static int
+obsled_release(struct inode *inode, struct file *file)
+{
+	is_open = 0;
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static ssize_t obsled_write(struct file *file, const char *buf, size_t count,
+			    loff_t *ppos)
+{
+	int err, i, led;
+
+	if (count <= 0) {
+		return 0;
+	}
+
+	for (i = 0; i < count; i++) {
+		err = get_user(led, buf + i);
+		if (err) {
+			return err;
+		}
+		if (led < '0' || '7' < led) {
+			/* skip */
+			continue;
+		}
+		err = obsled_out_pat(led);
+		if (err) {
+			return err;
+		}
+	}
+
+	return count;
+}
+
+static struct file_operations obsled_fops = {
+	owner:		THIS_MODULE,
+	write:		obsled_write,
+	open:		obsled_open,
+	release:	obsled_release,
+};
+
+static int __init
+obsled_init(void)
+{
+	int curr_gpio = 0;
+	struct ocp_dev *gpio_dev;
+
+	printk("OBS_LED driver version %s\n", OBSLED_VER);
+	while (curr_gpio != -ENXIO) {
+		if (!(gpio_dev = ocp_alloc_dev(0)))
+			return -ENOMEM;
+
+		gpio_dev->type = GPIO;
+		if ((curr_gpio = ocp_register(gpio_dev)) == -ENXIO) {
+			ocp_free_dev(gpio_dev);
+			break;
+		} else {
+			obsled_miscdev.minor = OBSLED_MINOR;
+			obsled_miscdev.name = gpio_dev->name;
+			obsled_miscdev.fops = &obsled_fops;
+			misc_register(&obsled_miscdev);
+
+			gpiop = (struct gpio_regs *) ioremap(gpio_dev->paddr,
+					sizeof (struct gpio_regs));
+			mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR)
+					& ~ocp_get_pm(GPIO, curr_gpio));
+			printk("OBS_LED: GPIO #%d at 0x%lx\n", curr_gpio,
+			       (unsigned long) gpiop);
+
+		}
+	}
+
+	return (curr_gpio == -ENXIO) ? 0 : curr_gpio;
+}
+
+static void __exit
+obsled_exit(void)
+{
+	int i;
+	struct ocp_dev *gpio_dev;
+
+	for (i = 0; i < ocp_get_max(GPIO); i++) {
+		gpio_dev = ocp_get_dev(GPIO, i);
+		misc_deregister(&obsled_miscdev);
+		mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | ocp_get_pm(GPIO, i));
+		ocp_unregister(gpio_dev);
+	}
+}
+
+module_init(obsled_init);
+module_exit(obsled_exit);
+
+/* EXPORT_SYMBOL(obsled_out_pat); */
+
+MODULE_LICENSE("GPL");
+
+#define GPIO_OR		((u32 *)0xef600700)
+#define GPIO_TCR	((u32 *)0xef600704)
+int
+obsled_out(int led)
+{
+	return obsled_out_reg(led, GPIO_OR, GPIO_TCR);
+}
+
diff -Naru linux-2.4.20.orig/drivers/char/pushsw_obs200.c linux-2.4.20/drivers/char/pushsw_obs200.c
--- linux-2.4.20.orig/drivers/char/pushsw_obs200.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/drivers/char/pushsw_obs200.c	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,202 @@
+/*
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Century's push button driver
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <asm/irq.h>
+/* #include <asm/ppc4xx.h> */
+#include <asm/pushsw_obs2xx.h>
+
+#define DBGON(x)        x
+#define DBGOFF(x)
+
+
+#define PSW_VER		"0.01"
+#define PSW_IRQ		25      /* AIC_INT25 */
+#define PD_IRQ		30      /* AIC_INT30 */
+
+/*----------------------------------------------------------------------------
+ *	Prototypes.
+ *----------------------------------------------------------------------------*/
+/* int psw_init(void); */
+static
+void psw_isr(int irq, void *dev_id, struct pt_regs *regs);
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int psw_open(struct inode *inode, struct file *file);
+static int psw_release(struct inode *inode, struct file *file);
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static struct file_operations	psw_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		psw_ioctl,
+	open:		psw_open,
+	release:	psw_release,
+};
+static struct miscdevice	psw_miscdev =
+	{ PUSHSW_MINOR, "pushsw", &psw_fops };
+static DECLARE_WAIT_QUEUE_HEAD(psw_wait);
+
+/* used to allow only one process at a time to "own" the push switch */
+static pid_t			psw_wait_pid = 0;
+static unsigned long 		PowerFail = 0;
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int __init psw_init(void)
+{
+	printk("Push switch driver v%s\n", PSW_VER);
+
+	/* Install the push switch interrupt handler */
+	if (request_irq(PSW_IRQ, psw_isr, SA_INTERRUPT, "push switch", NULL)) {
+		printk("[psw_open] interrupt %u not free\n", PSW_IRQ);
+		return (-EIO);
+	}
+	/* Install the power down interrupt handler */
+	if (request_irq(PD_IRQ, psw_isr, SA_INTERRUPT, "power down", NULL)) {
+		printk("[psw_open] interrupt %u not free\n", PD_IRQ);
+		return (-EIO);
+	}
+	DBGOFF(printk("[psw_init] Push switch installed on interrupt %u\n", PSW_IRQ);)
+	DBGOFF(printk("[psw_init] Power down installed on interrupt %u\n", PD_IRQ);)
+	misc_register(&psw_miscdev);
+	return (0);
+}	/* psw_init() */
+
+static void __exit psw_exit (void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq (PSW_IRQ, NULL);
+	free_irq (PD_IRQ, NULL);
+}
+
+module_init(psw_init);
+module_exit(psw_exit);
+EXPORT_NO_SYMBOLS;
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static
+void psw_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	DBGOFF(printk(KERN_CRIT "p");)
+	wake_up_interruptible(&psw_wait);
+	if (irq == PD_IRQ)
+	{
+		PowerFail = 1;
+		/* free_irq(PD_IRQ, NULL); */
+		mtdcr(DCRN_UIC_TR(UIC0), (mfdcr(DCRN_UIC_TR(UIC0)) | 0x00000002));
+	}
+}	/* psw_isr() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned long	flags;
+
+	if (MINOR(inode->i_rdev) != PUSHSW_MINOR) {
+		return (-ENODEV);
+	}
+
+	switch (cmd) {
+		case PSWIOC_GETWAITPID:
+			return (put_user(psw_wait_pid, (int *) arg));
+		case PSWIOC_WAITPUSH:
+			/* protect psw_wait_pid */
+			save_flags(flags);
+			cli();
+			if (psw_wait_pid == 0) {
+				psw_wait_pid = current->pid;
+				restore_flags(flags);
+				DBGOFF(printk("[psw_ioctl] PSWIOC_WAITPUSH pid %u\n", psw_wait_pid);)
+				/* block until switch pushed */
+				if (!PowerFail)
+					interruptible_sleep_on(&psw_wait);
+				save_flags(flags);
+				cli();
+				psw_wait_pid = 0;
+				restore_flags(flags);
+
+				DBGOFF(printk("[psw_ioctl] unblocked\n");)
+				if (signal_pending(current)) {
+					DBGOFF(printk("[psw_ioctl] sig\n");)
+					return (-ERESTARTSYS);
+				}
+				return (0);
+			}
+			else {
+				restore_flags(flags);
+				return (-EBUSY);
+			}
+		default:
+			break;
+	}
+	return (-ENOIOCTLCMD);
+}	/* psw_ioctl() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_open(struct inode *inode, struct file *file)
+{
+	switch (MINOR(inode->i_rdev)) {
+		case PUSHSW_MINOR:
+			MOD_INC_USE_COUNT;
+			return (0);
+		default:
+			return (-ENODEV);
+	}
+}	/* psw_open() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_release(struct inode *inode, struct file *file)
+{
+	unsigned long	flags;
+
+	DBGOFF(printk("[psw_release] ");)
+	if (MINOR(inode->i_rdev) == PUSHSW_MINOR) {
+		DBGOFF(printk("by pid %u\n", current->pid);)
+		save_flags(flags);
+		cli();
+		if (psw_wait_pid && (psw_wait_pid == current->pid)) {
+			psw_wait_pid = 0;
+			restore_flags(flags);
+			DBGOFF(printk("cleared\n");)
+		}
+		else {
+			restore_flags(flags);
+			DBGOFF(if (psw_wait_pid) printk("psw_wait_pid %u, current->pid %u\n", psw_wait_pid, current->pid);)
+		}
+		MOD_DEC_USE_COUNT;
+	}
+	return (0);
+}	/* psw_release() */
+
+
+#ifdef MODULE
+
+#define psw_init init_module
+
+void cleanup_module(void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq(PSW_IRQ, NULL);
+	free_irq(PD_IRQ, NULL);
+}	/* cleanup_module() */
+
+#endif
diff -Naru linux-2.4.20.orig/drivers/char/pushsw_obs266.c linux-2.4.20/drivers/char/pushsw_obs266.c
--- linux-2.4.20.orig/drivers/char/pushsw_obs266.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/drivers/char/pushsw_obs266.c	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,172 @@
+/*
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Century's push button driver
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <asm/irq.h>
+#include <asm/pushsw_obs2xx.h>
+
+#define DBGON(x)	
+#define DBGOFF(x)	x
+
+
+#define PSW_VER		"0.01"
+#define PSW_IRQ		26 /* AIC_INT1 */
+
+/*----------------------------------------------------------------------------
+ *	Prototypes.
+ *----------------------------------------------------------------------------*/
+int psw_init(void);
+void psw_isr(int irq, void *dev_id, struct pt_regs *regs);
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int psw_open(struct inode *inode, struct file *file);
+static int psw_release(struct inode *inode, struct file *file);
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static struct file_operations	psw_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		psw_ioctl,
+	open:		psw_open,
+	release:	psw_release,
+};
+static struct miscdevice	psw_miscdev =
+	{ PUSHSW_MINOR, "pushsw", &psw_fops };
+static DECLARE_WAIT_QUEUE_HEAD(psw_wait);
+
+/* used to allow only one process at a time to "own" the push switch */
+static pid_t			psw_wait_pid = 0;
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+int
+psw_init(void)
+{
+	printk("Push switch driver v%s\n", PSW_VER);
+
+	/* Install the push switch interrupt handler */
+	if (request_irq(PSW_IRQ, psw_isr, SA_INTERRUPT, "push switch", NULL)) {
+		printk("[psw_open] interrupt %u not free\n", PSW_IRQ);
+		return (-EIO);
+	}
+	DBGOFF(printk("[psw_init] Push switch installed on interrupt %u\n", PSW_IRQ);)
+	misc_register(&psw_miscdev);
+	return (0);
+}	/* psw_init() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+void
+psw_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* DBGOFF(printk(KERN_CRIT "p");) */
+	wake_up_interruptible(&psw_wait);
+}	/* psw_isr() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int
+psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	unsigned long arg)
+{
+	unsigned long	flags;
+
+	if (MINOR(inode->i_rdev) != PUSHSW_MINOR) {
+		return (-ENODEV);
+	}
+
+	switch (cmd) {
+	case PSWIOC_GETWAITPID:
+		return (put_user(psw_wait_pid, (int *) arg));
+	case PSWIOC_WAITPUSH:
+		/* protect psw_wait_pid */
+		save_flags(flags);
+		cli();
+		if (psw_wait_pid == 0) {
+			psw_wait_pid = current->pid;
+			restore_flags(flags);
+			DBGOFF(printk("[psw_ioctl] PSWIOC_WAITPUSH pid %u\n", psw_wait_pid);)
+			/* block until switch pushed */
+			interruptible_sleep_on(&psw_wait);
+			save_flags(flags);
+			cli();
+			psw_wait_pid = 0;
+			restore_flags(flags);
+
+			DBGOFF(printk("[psw_ioctl] unblocked\n");)
+			if (signal_pending(current)) {
+				DBGOFF(printk("[psw_ioctl] sig\n");)
+				return (-ERESTARTSYS);
+			}
+			return (0);
+		} else {
+			restore_flags(flags);
+			return (-EBUSY);
+		}
+	default:
+		break;
+	}
+	return (-ENOIOCTLCMD);
+}	/* psw_ioctl() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int
+psw_open(struct inode *inode, struct file *file)
+{
+	switch (MINOR(inode->i_rdev)) {
+	case PUSHSW_MINOR:
+		MOD_INC_USE_COUNT;
+		return (0);
+	default:
+		return (-ENODEV);
+	}
+}	/* psw_open() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int
+psw_release(struct inode *inode, struct file *file)
+{
+	unsigned long	flags;
+
+	DBGOFF(printk("[psw_release] ");)
+	if (MINOR(inode->i_rdev) == PUSHSW_MINOR) {
+		DBGOFF(printk("by pid %u\n", current->pid);)
+		save_flags(flags);
+		cli();
+		if (psw_wait_pid && (psw_wait_pid == current->pid)) {
+			psw_wait_pid = 0;
+			restore_flags(flags);
+			DBGOFF(printk("cleared\n");)
+		} else {
+			restore_flags(flags);
+			DBGOFF(if (psw_wait_pid) printk("psw_wait_pid %u, current->pid %u\n", psw_wait_pid, current->pid);)
+		}
+		MOD_DEC_USE_COUNT;
+	}
+	return (0);
+}	/* psw_release() */
+
+static void
+psw_exit(void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq(PSW_IRQ, NULL);
+}	/* cleanup_module() */
+module_init(psw_init);
+module_exit(psw_exit);
diff -Naru linux-2.4.20.orig/drivers/char/pushsw_obs50.c linux-2.4.20/drivers/char/pushsw_obs50.c
--- linux-2.4.20.orig/drivers/char/pushsw_obs50.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/drivers/char/pushsw_obs50.c	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,277 @@
+/*
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Century's push button driver
+ *
+ * Support for OpenBlockS 50.
+ * Copyright (C) 2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- replaced from arch/ppc/kernel and rename to pushsw_obs50.c
+ *		- removed PUSHSW_MINOR, it defined linux/miscdevice.h 
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <asm/irq.h>
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+#include <asm/pushsw_obs2xx.h>
+
+#define DBGON(x)	x
+#define DBGOFF(x)
+
+#define PSW_VER		"0.01"
+#define PSW_IRQ		(SIU_IRQ2)
+
+/* bit mask for PSW_IRQ in SIMASK, etc. */
+#define SIU_IRQ		(0x08000000)
+#define SIU_WM		(SIU_IRQ >> 1)
+
+/*----------------------------------------------------------------------------
+ *	Prototypes.
+ *----------------------------------------------------------------------------*/
+static void psw_isr(int irq, void *dev_id, struct pt_regs *regs);
+static int psw_status(void);
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static void psw_hw_init(void);
+static int psw_open(struct inode *inode, struct file *file);
+static int psw_release(struct inode *inode, struct file *file);
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static struct file_operations	psw_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		psw_ioctl,
+	open:		psw_open,
+	release:	psw_release,
+};
+static struct miscdevice	psw_miscdev =
+	{ PUSHSW_MINOR, "pushswitch", &psw_fops };
+static DECLARE_WAIT_QUEUE_HEAD(psw_wait);
+
+/* used to allow only one process at a time to "own" the push switch */
+static pid_t			psw_wait_pid = 0;
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int __init psw_init(void)
+{
+	printk("Push switch driver v%s\n", PSW_VER);
+
+	psw_hw_init();
+
+	/* install the interrupt handler */
+	if (request_8xxirq(PSW_IRQ, psw_isr, SA_INTERRUPT, "pushswitch", NULL)) {
+		printk("[psw_open] interrupt %u not free\n", PSW_IRQ);
+		return (-EIO);
+	}
+	DBGOFF(printk("[psw_init] installed on interrupt %u\n", PSW_IRQ);)
+
+	misc_register(&psw_miscdev);
+	return (0);
+}	/* psw_init() */
+
+
+static void __exit psw_exit(void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq(PSW_IRQ, NULL);
+}
+
+module_init(psw_init);
+module_exit(psw_exit);
+EXPORT_NO_SYMBOLS;
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static void psw_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	DBGOFF(printk(KERN_CRIT "p");)
+	wake_up_interruptible(&psw_wait);
+}	/* psw_isr() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_status(void)
+{
+	if (((immap_t *) IMAP_ADDR)->im_ioport.iop_padat & 0x0020) {
+		DBGOFF(printk("[psw_status] notpushed\n");)
+		return (PSWIOF_NOTPUSHED);
+	}
+	else {
+		DBGOFF(printk("[psw_status] pushed\n");)
+		return (PSWIOF_PUSHED);
+	}
+}	/* psw_status() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned long	flags;
+
+	if (MINOR(inode->i_rdev) != PUSHSW_MINOR) {
+		return (-ENODEV);
+	}
+
+	switch (cmd) {
+		case PSWIOC_GETWAITPID:
+			return (put_user(psw_wait_pid, (int *) arg));
+		case PSWIOC_GETSTATUS:
+			return (put_user(psw_status(), (int *) arg));
+		case PSWIOC_WAITPUSH:
+			/* protect psw_wait_pid */
+			save_flags(flags);
+			cli();
+			if (psw_wait_pid == 0) {
+				psw_wait_pid = current->pid;
+				restore_flags(flags);
+				DBGOFF(printk("[psw_ioctl] PSWIOC_WAITPUSH pid %u\n", psw_wait_pid);)
+				/* block until switch pushed */
+				interruptible_sleep_on(&psw_wait);
+
+				save_flags(flags);
+				cli();
+				psw_wait_pid = 0;
+				restore_flags(flags);
+
+				DBGOFF(printk("[psw_ioctl] unblocked\n");)
+				if (signal_pending(current)) {
+					DBGOFF(printk("[psw_ioctl] sig\n");)
+					return (-ERESTARTSYS);
+				}
+				DBGOFF(if (psw_status() == PSWIOF_NOTPUSHED)
+						printk("not pushed?\n");)
+				return (0);
+			}
+			else {
+				restore_flags(flags);
+				return (-EBUSY);
+			}
+		default:
+			break;
+	}
+	return (-ENOIOCTLCMD);
+}	/* psw_ioctl() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static void psw_hw_init(void)
+{
+	unsigned long	i;
+	unsigned long	flags;
+
+	save_flags(flags);
+	cli();
+
+	DBGOFF({
+		printk("IMAP_ADDR: 0x%08x\n", IMAP_ADDR);
+		printk("&sc_siel: 0x%08x\n",
+			(&((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel));
+		printk("sc_sipend: 0x%08x\n",
+				((immap_t *) IMAP_ADDR)->im_siu_conf.sc_sipend);
+		printk("sc_simask: 0x%08x\n",
+				((immap_t *) IMAP_ADDR)->im_siu_conf.sc_simask);
+		printk("sc_siel: 0x%08x\n\n",
+				((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel);
+	})
+
+	/* PA10 push switch general purpose input */
+	((immap_t *) IMAP_ADDR)->im_ioport.iop_papar &= ~0x0020;
+	((immap_t *) IMAP_ADDR)->im_ioport.iop_padir &= ~0x0020;
+	((immap_t *) IMAP_ADDR)->im_ioport.iop_paodr &= ~0x0020;
+
+	/* initial hardware setup for push switch interrupt */
+
+	/* disable IRQ */
+	((immap_t *) IMAP_ADDR)->im_siu_conf.sc_simask &= ~SIU_IRQ;
+
+	/* we want an interrupt at notpushed==>pushed edge */
+	((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel |= (SIU_IRQ | SIU_WM);
+
+	/* clear IRQ pending */
+	((immap_t *) IMAP_ADDR)->im_siu_conf.sc_sipend |= SIU_IRQ;
+
+	for (i = 0L; i < 10000UL; i++) {}
+
+	/* enable IRQ */
+	((immap_t *) IMAP_ADDR)->im_siu_conf.sc_simask |= SIU_IRQ;
+
+	restore_flags(flags);
+
+	DBGOFF({
+		printk("pa:par:dir:odr 0x%08x 0x%08x 0x%08x \n",
+		       ((immap_t *) IMAP_ADDR)->im_ioport.iop_papar,
+		       ((immap_t *) IMAP_ADDR)->im_ioport.iop_padir,
+		       ((immap_t *) IMAP_ADDR)->im_ioport.iop_paodr);
+		printk("sc_sipend: 0x%08x\n",
+		       ((immap_t *) IMAP_ADDR)->im_siu_conf.sc_sipend);
+		printk("sc_simask: 0x%08x\n",
+		       ((immap_t *) IMAP_ADDR)->im_siu_conf.sc_simask);
+		printk("sc_siel: 0x%08x\n",
+		       ((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel);
+	})
+}	/* psw_hw_init() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_open(struct inode *inode, struct file *file)
+{
+	switch (MINOR(inode->i_rdev)) {
+		case PUSHSW_MINOR:
+			MOD_INC_USE_COUNT;
+			return (0);
+		default:
+			return (-ENODEV);
+	}
+}	/* psw_open() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_release(struct inode *inode, struct file *file)
+{
+	unsigned long	flags;
+
+	DBGOFF(printk("[psw_release] ");)
+	if (MINOR(inode->i_rdev) == PUSHSW_MINOR) {
+		DBGOFF(printk("by pid %u\n", current->pid);)
+		save_flags(flags);
+		cli();
+		if (psw_wait_pid && (psw_wait_pid == current->pid)) {
+			psw_wait_pid = 0;
+			restore_flags(flags);
+			DBGOFF(printk("cleared\n");)
+		}
+		else {
+			restore_flags(flags);
+			DBGOFF(if (psw_wait_pid) printk("psw_wait_pid %u, current->pid %u\n", psw_wait_pid, current->pid);)
+		}
+		MOD_DEC_USE_COUNT;
+	}
+	return (0);
+}	/* psw_release() */
+
+
+#ifdef MODULE
+
+#define psw_init init_module
+
+void cleanup_module(void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq(PSW_IRQ, NULL);
+}	/* cleanup_module() */
+
+#endif
diff -Naru linux-2.4.20.orig/drivers/char/segled_obs200.c linux-2.4.20/drivers/char/segled_obs200.c
--- linux-2.4.20.orig/drivers/char/segled_obs200.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/drivers/char/segled_obs200.c	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,453 @@
+/*
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Century's 7 segment LED driver
+ *      2002-01-06 ozawa CONFIG_OBSS
+ *              - remove '+' shutdown procedure...
+ * 	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#ifdef CONFIG_4xx
+/* #include <asm/ppc4xx.h> */
+#include <asm/ibm4xx.h>
+#endif
+#ifdef CONFIG_8xx
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+#endif
+
+#include <asm/io.h>     /* for ioremap() */
+#include <asm/segled_obs200.h>
+
+#define DBGON(x)	x
+#define DBGOFF(x)
+
+
+#define SL_VER		"0.01"
+
+#define SL_MAX_TEST	(3)
+#define SL_TEST_DELAY	(0x00C00000UL)
+#define SL_DELAY(n)	for (delay = 0L; delay < (n); delay++) {}
+#define SL_OPEN_MAX	(0xffffffff)
+
+/*
+#define OPNT ((volatile unsigned char *)(0x40000000))
+*/
+static volatile unsigned char * OPNT;
+
+#if !defined(CONFIG_OBS200)
+#define GPIO0_OR ((volatile unsigned long *)(0xef600700))
+#define GPIO0_TCR ((volatile unsigned long *)(0xef600704))
+#define GPIO0_ODR ((volatile unsigned long *)(0xef600718))
+#define GPIO0_IR ((volatile unsigned long *)(0xef60071c))
+#endif  /* !CONFIG_OBS200 */
+/*----------------------------------------------------------------------------
+ *	Prototypes.
+ *----------------------------------------------------------------------------*/
+/* int sl_init(void); */
+static ssize_t sl_write(struct file *file, const char *buf, size_t count, loff_t *ppos);
+static int sl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int sl_open(struct inode *inode, struct file *file);
+static int sl_release(struct inode *inode, struct file *file);
+static unsigned long sl_v2p(unsigned int v);
+static void sl_hw_test(void);
+static void sl_set(unsigned long val);
+static void sl_set_dp(int dp);
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static struct file_operations	sl_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		sl_ioctl,
+	open:		sl_open,
+	release:	sl_release,
+	write:		sl_write,
+};
+
+static struct miscdevice	sl_miscdev =
+	{ SEGLED_MINOR, "segled", &sl_fops };
+
+static unsigned long	sl_open_count = 0L;
+static pid_t		sl_owner_pid = 0;
+
+#if !defined(CONFIG_OBS200)
+static unsigned long	firsttime = 1;
+#endif
+
+static unsigned long		sl_v2p_table[16] = {
+	SL_V0, SL_V1, SL_V2, SL_V3, SL_V4, SL_V5, SL_V6, SL_V7,
+	SL_V8, SL_V9, SL_VA, SL_VB, SL_VC, SL_VD, SL_VE, SL_VF
+};
+
+/*----------------------------------------------------------------------------
+ *	Driver registration.
+ *----------------------------------------------------------------------------*/
+static int __init sl_init(void)
+{
+	printk("7-segment LED driver v%s\n", SL_VER);
+	OPNT = ioremap(0x40000000, 4096);
+	misc_register(&sl_miscdev);
+
+	return (0);
+}	/* sl_init() */
+
+static void __exit sl_exit (void)
+{
+	misc_deregister(&sl_miscdev);
+}
+
+module_init(sl_init);
+module_exit(sl_exit);
+EXPORT_NO_SYMBOLS;
+
+/*----------------------------------------------------------------------------
+ *	Return the segment pattern value corresponding to the given value.
+ *
+ *	Parameters:
+ *		v:	Value between 0 and 15.
+ *
+ *	Returns:
+ *		0:	Range error.
+ *		else:	The segment pattern to use to represent the value.
+ *			Can be used as the argument to sl_set().
+ *----------------------------------------------------------------------------*/
+static unsigned long sl_v2p(unsigned int v)
+{
+	if (v > 15L) {
+		return (0L);
+	}
+	else {
+		return (sl_v2p_table[v]);
+	}
+}	/* sl_v2p() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static ssize_t sl_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	size_t		i;
+	unsigned int	digit;
+
+	if (sl_owner_pid && (sl_owner_pid != current->pid)) {
+		return (-EPERM);
+	}
+
+	DBGOFF(printk("[sl_write] count %d\n", count);)
+	DBGOFF({
+		for (i = 0L; i < count; i++) {
+			printk(" 0x%02x", buf[i]);
+		}
+	})
+
+	/* no seeks allowed on this device */
+	if (ppos != &file->f_pos) {
+		DBGOFF(printk("[sl_write] seek\n");)
+		return (-ESPIPE);
+	}
+
+	for (i = 0; i < count; i++) {
+		digit = 16;
+		if ((buf[i] >= 0x30) && (buf[i] <= 0x39)) {
+			digit = (unsigned int) (buf[i] - 0x30);
+		}
+		else {
+			switch (buf[i]) {
+			case 0x41:
+			case 0x61:
+				digit = 10;
+				break;
+			case 0x42:
+			case 0x62:
+				digit = 11;
+				break;
+			case 0x43:
+			case 0x63:
+				digit = 12;
+				break;
+			case 0x44:
+			case 0x64:
+				digit = 13;
+				break;
+			case 0x45:
+			case 0x65:
+				digit = 14;
+				break;
+			case 0x46:
+			case 0x66:
+				digit = 15;
+				break;
+			case ' ':	/* space => all off */
+				sl_set(SL_NONE);
+				break;
+			case '+':	/* '+' => DP on  */
+				sl_set_dp(1);
+#ifndef CONFIG_OBS200
+				if (firsttime)
+				{
+					printk("EXECUTING POWER SHUTDOWN\n");
+					*GPIO0_ODR &= ~(0x00200000);
+					*GPIO0_OR |= 0x00200000;
+					*GPIO0_TCR |= 0x00200000;
+					mtdcr(DCRN_CHCR0, (mfdcr(DCRN_CHCR0) | 0x04000000));
+					*GPIO0_OR &= ~(0x00200000);
+					firsttime = 0;
+				}
+#endif  /* !CONFIG_OBS200 */
+				break;
+			case '-':	/* '-' => DP off  */
+				sl_set_dp(0);
+				break;
+#if 0
+// TODO - for watchdog debug only - REMOVE!!
+case 'w':
+	printk("disabling interrupts for watchdog test - REMOVE!!!\n");
+	cli();
+	while (1) {}
+#endif
+			default:
+				break;
+			}
+		}	/* A..F, a..f, etc. */
+
+		if (digit < 16) {
+			sl_set(sl_v2p(digit));
+			DBGOFF(printk("[sl_write] ok\n");)
+		}
+	}
+
+	return (count);
+}	/* sl_write() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int sl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	extern void sys_405dc(unsigned long);
+#if 0
+	unsigned long pn, *tmp, size;
+	int i;
+#endif  /* 0 */
+
+	unsigned long	ptn;
+
+	DBGOFF(printk("!");)
+
+	if (MINOR(inode->i_rdev) != SEGLED_MINOR) {
+		return (-ENODEV);
+	}
+
+	//printk(" (cmd %x,%x) ", cmd, SLIOC_TEST405);
+	DBGOFF(printk(" cmd %u ", cmd);)
+
+	switch (cmd) {
+	case SLIOC_GET_OWNER_PID:
+		DBGOFF(printk(" SLIOC_GET_OWNER_PID ");)
+		return (put_user(sl_owner_pid, (int *) arg));
+	case SLIOC_RESERVE:
+		DBGOFF(printk(" SLIOC_RESERVE ");)
+		if (!sl_owner_pid || (sl_owner_pid == current->pid)) {
+			sl_owner_pid = current->pid;
+			DBGOFF(printk("led reserved by pid %d\n", sl_owner_pid);)
+			return (0);
+		}
+		return (-EPERM);
+	default:
+		/*
+		 *	Other commands require LED access.
+		 *	Disallow if LED has been reserved
+		 *	by another process.
+		 */
+		if (sl_owner_pid && (sl_owner_pid != current->pid)) {
+			DBGOFF(printk("disallowed (sl_owner_pid %d, current->pid %d)\n", sl_owner_pid, current->pid);)
+			return (-EPERM);
+		}
+		break;
+	}	/* switch on cmd */
+
+	DBGOFF(printk(" cmd check 2 ");)
+
+	switch (cmd) {
+		case SLIOC_SETVAL:
+			DBGOFF(printk(" SLIOC_SETVAL ");)
+			ptn = sl_v2p((unsigned int) arg);
+			if (ptn) {
+				DBGOFF(printk(" led%u ", (unsigned)arg);)
+				sl_set(ptn);
+				return (0);
+			}
+			DBGOFF(else printk(" SLIOC_SETVAL arg 0x%x ignored ",
+							(unsigned)arg);)
+			break;
+		case SLIOC_SETSEG:
+			DBGOFF(printk(" SLIOC_SETSEG ");)
+			DBGOFF(printk("!");)
+			sl_set(arg);
+			return (0);
+		case SLIOC_TEST:
+			DBGOFF(printk(" SLIOC_TEST ");)
+			sl_hw_test();
+			return (0);
+		default:
+			DBGOFF(printk(" unknown cmd %d ", cmd);)
+			break;
+	}
+	return (-ENOIOCTLCMD);
+}	/* sl_ioctl() */
+
+/*----------------------------------------------------------------------------
+ *	Set the given value to the 7-segment LED.
+ *
+ *	Parameters:
+ *		val:	Value indicating which segments should be on.
+ *			Can be built with the macros in segled.h.
+ *----------------------------------------------------------------------------*/
+static
+void sl_set(unsigned long val)
+{
+	*OPNT = 0xFF; 				/* turn off all segments */
+	*OPNT = ~(val);				/* turn on specified segments */
+}	/* sl_set() */
+
+/*----------------------------------------------------------------------------
+ *	Set the DP (dot) segment of the 7-segment LED as specified.
+ *
+ *	Parameters:
+ *		dp:	State of segment DP (dot).
+ *				0:	off
+ *				else:	on
+ *----------------------------------------------------------------------------*/
+static
+void sl_set_dp(int dp)
+{
+	if (dp) {
+		*OPNT = ~SL_DP;	/* turn DP segment on */
+	}
+	else {
+		*OPNT = SL_DP;	/* turn DP segment off */
+	}
+}	/* sl_set_dp() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int sl_open(struct inode *inode, struct file *file)
+{
+#if 1
+	switch (MINOR(inode->i_rdev)) {
+		case SEGLED_MINOR:
+			if (sl_open_count >= SL_OPEN_MAX) {
+				return (-EBUSY);
+			}
+			sl_open_count++;
+			return (0);
+		default:
+			return (-ENODEV);
+	}
+#else
+	//printk("o");
+	switch (MINOR(inode->i_rdev)) {
+		case SEGLED_MINOR:
+			sl_open_count++;
+			//printk("k");
+			return (0);
+		default:
+			printk("No");
+			return (-ENODEV);
+	}
+//	extern void PPC4xx_tlb_flush_all(void);
+//	PPC4xx_tlb_flush_all();
+//	//return (0);
+//	return (-ENODEV);
+#endif
+}	/* sl_open() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int sl_release(struct inode *inode, struct file *file)
+{
+	if (MINOR(inode->i_rdev) == SEGLED_MINOR) {
+		if (sl_owner_pid == current->pid) {
+			DBGOFF(printk("pid %d led reserve released\n",
+								sl_owner_pid);)
+			sl_owner_pid = 0;
+		}
+		if (sl_open_count >= 1L) {
+			DBGOFF(printk("[sl_release]\n");)
+			sl_open_count--;
+		}
+		else printk("[sl_release] not open!\n");
+	}
+	return (0);
+}	/* sl_release() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static void sl_hw_test(void)
+{
+	unsigned long	delay;
+	unsigned int	test, ptn;
+
+	for (test = 0; test < SL_MAX_TEST; test++) {
+		/* all off */
+		DBGOFF(printk("all off ");)
+		sl_set(SL_NONE);
+		sl_set_dp(0);
+		SL_DELAY(SL_TEST_DELAY)
+
+		/* display 0..F in sequence */
+		for (ptn = 0; ptn <= 15; ptn++) {
+			DBGOFF(printk(" %x ", ptn);)
+			sl_set(sl_v2p_table[ptn]);
+			SL_DELAY(SL_TEST_DELAY)
+		}
+
+		/* all on */
+		DBGOFF(printk("all on ");)
+		sl_set(SL_ALL);
+		SL_DELAY(SL_TEST_DELAY)
+
+		sl_set_dp(0);	/* turn off DP */
+
+		/* turn on each segment individually */
+		DBGOFF(printk(" sA ");)
+		sl_set(SL_A);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sB ");)
+		sl_set(SL_B);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sC ");)
+		sl_set(SL_C);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sD ");)
+		sl_set(SL_D);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sE ");)
+		sl_set(SL_E);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sF ");)
+		sl_set(SL_F);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sG ");)
+		sl_set(SL_G);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sDP ");)
+		sl_set(SL_DP);
+		SL_DELAY(SL_TEST_DELAY)
+
+		DBGOFF(printk("\n");)
+	}	/* for number of times to repeat test */
+}	/* sl_hw_test() */
diff -Naru linux-2.4.20.orig/drivers/char/segled_obs50.c linux-2.4.20/drivers/char/segled_obs50.c
--- linux-2.4.20.orig/drivers/char/segled_obs50.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/drivers/char/segled_obs50.c	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,219 @@
+/*
+ * LED driver for OpenBlockS 50.
+ *
+ * --- Copyright (C) 2001  Masaki WAKABAYASHI <masaki@quox.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- replaced from arch/ppc/kernel and rename to segled_obs50.c
+ *		- defined OBSLED_MINOR SEGLED_MINOR 
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+
+/* version information */
+#define OBSLED_VERSION_INFO "LED driver version 1.0.0"
+
+/* character special file id */
+#define OBSLED_MAJOR MISC_MAJOR
+#define OBSLED_MINOR SEGLED_MINOR
+
+/* pointer to device */
+#define DEV ((volatile cpm8xx_t*)(&(((volatile immap_t*)IMAP_ADDR)->im_cpm)))
+
+/* ioctl command id */
+#define	OBSLED_IOCTL_BASE          'S'
+#define	OBSLED_IOCTL_SETSEG        _IOR(OBSLED_IOCTL_BASE, 2, int)
+#define OBSLED_IOCTL_GET_OWNER_PID _IOR(OBSLED_IOCTL_BASE, 3, int)
+#define OBSLED_IOCTL_RESERVE       _IOR(OBSLED_IOCTL_BASE, 4, int)
+
+/* LED digit pattern table */
+#define LEDPATTERN_0      (0x0003c003UL)
+#define LEDPATTERN_1      (0x00028000UL)
+#define LEDPATTERN_2      (0x0000c00bUL)
+#define LEDPATTERN_3      (0x0002c009UL)
+#define LEDPATTERN_4      (0x00038008UL)
+#define LEDPATTERN_5      (0x00034009UL)
+#define LEDPATTERN_6      (0x0003400bUL)
+#define LEDPATTERN_7      (0x0003c000UL)
+#define LEDPATTERN_8      (0x0003c00bUL)
+#define LEDPATTERN_9      (0x0003c009UL)
+#define LEDPATTERN_A      (0x0003c00aUL)
+#define LEDPATTERN_B      (0x0003000bUL)
+#define LEDPATTERN_C      (0x00014003UL)
+#define LEDPATTERN_D      (0x0002800bUL)
+#define LEDPATTERN_E      (0x0001400bUL)
+#define LEDPATTERN_F      (0x0001400aUL)
+#define LEDPATTERN_DOT    (0x00000004UL)
+#define LEDPATTERN_ALLBAR (LEDPATTERN_8)
+#define LEDPATTERN_NONE   (0x00000000UL)
+#define LEDPATTERN_ALL    (LEDPATTERN_ALLBAR | LEDPATTERN_DOT)
+
+/* function prototypes */
+static void obsled_set_pattern(unsigned long, unsigned long);
+static int obsled_init(void);
+static void obsled_exit(void);
+static int obsled_open(struct inode*, struct file*);
+static int obsled_release(struct inode*, struct file*);
+static ssize_t obsled_write(struct file*, const char*, size_t, loff_t*);
+static int obsled_ioctl(struct inode*, struct file*, unsigned int, unsigned long);
+
+/* stuructures for kernel module */
+static struct file_operations obsled_fops = {
+	owner:   "segled",
+	write:   obsled_write,
+	ioctl:   obsled_ioctl,
+	open:    obsled_open,
+	release: obsled_release
+};
+static struct miscdevice obsled_miscdev = {
+	OBSLED_MINOR,
+	"obsled",
+	&obsled_fops
+};
+
+/* misc variables */
+static unsigned int obsled_open_count = 0;
+static pid_t obsled_owner_pid = 0;
+
+/* set pattern to LED */
+void obsled_set_pattern(unsigned long pattern, unsigned long mask)
+{
+	unsigned long flags;
+	save_flags(flags); cli();
+	DEV->cp_pbdat = (((DEV->cp_pbdat) | ~mask) & ~pattern);
+	restore_flags(flags);
+}
+
+/* import module */
+int __init obsled_init(void)
+{
+	printk(KERN_INFO OBSLED_VERSION_INFO "\n");
+	obsled_set_pattern(LEDPATTERN_DOT, ~LEDPATTERN_ALL);
+	misc_register(&obsled_miscdev);
+	return 0;
+}
+
+/* release module */
+void obsled_exit(void)
+{
+	obsled_set_pattern(LEDPATTERN_DOT, ~LEDPATTERN_ALL);
+	misc_deregister(&obsled_miscdev);
+}
+
+/* open device */
+int obsled_open(struct inode* inode, struct file* file)
+{
+	if (MINOR(inode->i_rdev) != OBSLED_MINOR) return -ENODEV;
+	if (obsled_open_count == UINT_MAX) return -EBUSY;
+	obsled_open_count++;
+	return 0;
+}
+
+/* release device */
+int obsled_release(struct inode* inode, struct file* file)
+{
+	if (MINOR(inode->i_rdev) != OBSLED_MINOR) return 0;
+	if (obsled_owner_pid == current->pid) obsled_owner_pid = 0;
+	if (obsled_open_count > 0) obsled_open_count--;
+	return 0;
+}
+
+/* write to device */
+ssize_t obsled_write(struct file* file, const char* buf, size_t size,
+					 loff_t* ppos)
+{
+	size_t i;
+	/* owner check */
+	if (obsled_owner_pid != 0 && obsled_owner_pid != current->pid) {
+		return -EPERM;
+	}
+	/* no seeks allowed on this device */
+	if (ppos != &file->f_pos) return -ESPIPE;
+	/* show patterns */
+	for (i = 0; i < size; i++) {
+		switch (buf[i]) {
+		case '0':
+			obsled_set_pattern(LEDPATTERN_0, ~LEDPATTERN_ALLBAR); break;
+		case '1':
+			obsled_set_pattern(LEDPATTERN_1, ~LEDPATTERN_ALLBAR); break;
+		case '2':
+			obsled_set_pattern(LEDPATTERN_2, ~LEDPATTERN_ALLBAR); break;
+		case '3':
+			obsled_set_pattern(LEDPATTERN_3, ~LEDPATTERN_ALLBAR); break;
+		case '4':
+			obsled_set_pattern(LEDPATTERN_4, ~LEDPATTERN_ALLBAR); break;
+		case '5':
+			obsled_set_pattern(LEDPATTERN_5, ~LEDPATTERN_ALLBAR); break;
+		case '6':
+			obsled_set_pattern(LEDPATTERN_6, ~LEDPATTERN_ALLBAR); break;
+		case '7':
+			obsled_set_pattern(LEDPATTERN_7, ~LEDPATTERN_ALLBAR); break;
+		case '8':
+			obsled_set_pattern(LEDPATTERN_8, ~LEDPATTERN_ALLBAR); break;
+		case '9':
+			obsled_set_pattern(LEDPATTERN_9, ~LEDPATTERN_ALLBAR); break;
+		case 'A': case 'a':
+			obsled_set_pattern(LEDPATTERN_A, ~LEDPATTERN_ALLBAR); break;
+		case 'B': case 'b':
+			obsled_set_pattern(LEDPATTERN_B, ~LEDPATTERN_ALLBAR); break;
+		case 'C': case 'c':
+			obsled_set_pattern(LEDPATTERN_C, ~LEDPATTERN_ALLBAR); break;
+		case 'D': case 'd':
+			obsled_set_pattern(LEDPATTERN_D, ~LEDPATTERN_ALLBAR); break;
+		case 'E': case 'e':
+			obsled_set_pattern(LEDPATTERN_E, ~LEDPATTERN_ALLBAR); break;
+		case 'F': case 'f':
+			obsled_set_pattern(LEDPATTERN_F, ~LEDPATTERN_ALLBAR); break;
+		case ' ':
+			obsled_set_pattern(LEDPATTERN_NONE, ~LEDPATTERN_ALL); break;
+		case '+':
+			obsled_set_pattern(LEDPATTERN_DOT, ~LEDPATTERN_NONE); break;
+		case '-':
+			obsled_set_pattern(LEDPATTERN_NONE, ~LEDPATTERN_DOT); break;
+		default:
+			break;
+		}
+	}
+	return size;
+}
+
+/* ioctl device */
+int obsled_ioctl(struct inode* inode, struct file* file, unsigned int cmd,
+						unsigned long arg)
+{
+	if (MINOR(inode->i_rdev) != OBSLED_MINOR) return -ENODEV;
+	switch (cmd) {
+	case OBSLED_IOCTL_SETSEG:
+		if (obsled_owner_pid != 0 && obsled_owner_pid != current->pid) {
+			return -EPERM;
+		}
+		obsled_set_pattern(arg, ~LEDPATTERN_ALL);
+		break;
+	case OBSLED_IOCTL_GET_OWNER_PID:
+		return put_user(obsled_owner_pid, (pid_t*)arg);
+	case OBSLED_IOCTL_RESERVE:
+		if (obsled_owner_pid != 0 && obsled_owner_pid != current->pid) {
+			return -EPERM;
+		}
+		obsled_owner_pid = current->pid;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+module_init(obsled_init);
+module_exit(obsled_exit);
diff -Naru linux-2.4.20.orig/drivers/char/serial.c linux-2.4.20/drivers/char/serial.c
--- linux-2.4.20.orig/drivers/char/serial.c	2002-12-11 11:37:38.000000000 +0900
+++ linux-2.4.20/drivers/char/serial.c	2004-12-21 12:27:04.000000000 +0900
@@ -62,6 +62,9 @@
  *        Robert Schwebel <robert@schwebel.de>,
  *        Juergen Beisert <jbeisert@eurodsn.de>,
  *        Theodore Ts'o <tytso@mit.edu>
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- added UPS control for OpenBlockS 266
  */
 
 static char *serial_version = "5.05c";
@@ -287,6 +290,16 @@
 static void change_speed(struct async_struct *info, struct termios *old);
 static void rs_wait_until_sent(struct tty_struct *tty, int timeout);
 
+#if CONFIG_OBS266
+static void UPS_proc(void);
+static int ups_init(struct async_struct *info);
+static int ups_start(struct async_struct *info);
+static int ups_stop(struct async_struct *info);
+static int ups_set_timeout(int);
+extern void ups_shutdown(void);
+void UPS_poff(void);
+#endif
+
 /*
  * Here we define the default xmit fifo size used for each type of
  * UART
@@ -1534,10 +1547,16 @@
 	
 	/* disable break condition */
 	serial_out(info, UART_LCR, serial_inp(info, UART_LCR) & ~UART_LCR_SBC);
-	
+
+#if CONFIG_OBS266
+	if (info->iomem_base != 0xef600400) {
+#endif
 	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
 		info->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);
 	serial_outp(info, UART_MCR, info->MCR);
+#if CONFIG_OBS266
+	}
+#endif
 
 	/* disable FIFO's */	
 	serial_outp(info, UART_FCR, (UART_FCR_ENABLE_FIFO |
@@ -2546,7 +2565,11 @@
 
 	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
 	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&
-	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
+	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)
+#if CONFIG_OBS266
+	    && (cmd != UPSIOINIT) && (cmd != UPSIOSTART) && (cmd != UPSIOSTOP)
+#endif
+	) {
 		if (tty->flags & (1 << TTY_IO_ERROR))
 		    return -EIO;
 	}
@@ -2689,7 +2712,24 @@
 			/* "setserial -W" is called in Debian boot */
 			printk ("TIOCSER?WILD ioctl obsolete, ignored.\n");
 			return 0;
-
+#if CONFIG_OBS266
+		case UPSIOINIT:
+			if (ups_init(info))
+				return -EIO;
+			return 0;
+		case UPSIOSTART:
+			if (ups_start(info))
+				return -EIO;
+			return 0;
+		case UPSIOSTOP:
+			if (ups_stop(info))
+				return -EIO;
+			return 0;
+		case UPSIOTIME:
+			if (ups_set_timeout((int)arg))
+				return -EIO;
+			return 0;
+#endif
 		default:
 			return -ENOIOCTLCMD;
 		}
@@ -6007,6 +6047,135 @@
 }
 #endif
 
+#if CONFIG_OBS266
+
+#define	UPS_IDLE	0
+#define	UPS_RUN		1
+#define	UPS_POLL	2
+#define	UPS_HALT	3
+
+#ifdef CONFIG_OBS266_UPS_DEBUG
+#define	UPS_UNITTIME	1
+#define	UPS_TIMEOUT	5
+#define	UPS_TIMEBASE	1
+#else
+#define	UPS_UNITTIME	5
+#define	UPS_TIMEOUT	300
+#define	UPS_TIMEBASE	60
+#endif
+
+static struct async_struct *ups_info = 0;
+static struct timer_list ups_timer;
+static int UPS_state = UPS_IDLE;
+static int UPS_count = 0;
+static int UPS_timeout = UPS_TIMEOUT;
+
+static void UPS_proc()
+{
+	int ctrl;
+
+	switch (UPS_state) {
+	default:
+	case UPS_IDLE:
+	case UPS_HALT:
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+		/* XXX XXX XXX */
+		printk("UPS_IDEL\n");
+#endif
+		/* just return. better than break. */
+		return;
+
+	case UPS_RUN:
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+		/* XXX XXX XXX */
+		printk("UPS_RUN\n");
+#endif
+		ctrl = serial_in(ups_info, UART_MSR);
+		if (ctrl & UART_MSR_DSR) {		/* DSR ON */
+			UPS_state = UPS_POLL;
+		}
+		break;
+
+	case UPS_POLL:
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+		/* XXX XXX XXX */
+		printk("UPS_POLL\n");
+#endif
+		ctrl = serial_in(ups_info, UART_MSR);
+		if ((ctrl & UART_MSR_DSR) == 0) {	/* DSR OFF */
+			UPS_count = 0;
+			UPS_state = UPS_RUN;
+		} else {
+			UPS_count++;
+			if (UPS_count > (UPS_timeout / UPS_UNITTIME)) {
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+				printk("psw_isr()\n");
+#endif
+				psw_isr(SA_INTERRUPT, "push switch", NULL);
+				UPS_count = 0;
+				UPS_state = UPS_HALT;
+				return;
+			}
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+			printk("count = %d\n", UPS_count);
+#endif
+		}
+		break;
+	}
+	mod_timer(&ups_timer, jiffies + UPS_UNITTIME * HZ);
+}
+
+static int ups_init(struct async_struct *info)
+{
+	if (info->iomem_base != 0xef600400)
+		return -1;
+	ups_info = info;
+	init_timer(&ups_timer);
+	ups_timer.function = UPS_proc;
+	/*UPS_state = UPS_RUN;*/
+	/*mod_timer(&ups_timer, jiffies + UPS_UNITTIME * HZ);*/
+	return 0;
+}
+
+static int ups_start(struct async_struct *info)
+{
+	if (UPS_state != UPS_IDLE)
+		return -1;
+	if (info->iomem_base != 0xef600400)
+		return -1;
+	if (ups_info == 0)
+		ups_init(info);
+	info->MCR |= UART_MCR_DTR;
+	UPS_state = UPS_RUN;
+	UPS_count = 0;
+	mod_timer(&ups_timer, jiffies + UPS_UNITTIME * HZ);
+	return 0;
+}
+
+static int ups_stop(struct async_struct *info)
+{
+	if (info->iomem_base != 0xef600400)
+		return -1;
+	UPS_state = UPS_IDLE;
+	UPS_count = 0;
+	return 0;
+}
+
+static int ups_set_timeout(int time)
+{
+	if (time < 1 || time > 10)
+		return -1;
+	UPS_timeout = time * UPS_TIMEBASE;
+	return 0;
+}
+
+void UPS_poff()
+{
+	serial_out(ups_info, UART_MCR, 0);
+}
+
+#endif
+
 /*
   Local variables:
   compile-command: "gcc -D__KERNEL__ -I../../include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing -pipe -fno-strength-reduce -march=i586 -DMODULE -DMODVERSIONS -include ../../include/linux/modversions.h   -DEXPORT_SYMTAB -c serial.c"
diff -Naru linux-2.4.20.orig/drivers/char/tty_io.c linux-2.4.20/drivers/char/tty_io.c
--- linux-2.4.20.orig/drivers/char/tty_io.c	2002-12-11 11:39:49.000000000 +0900
+++ linux-2.4.20/drivers/char/tty_io.c	2004-12-21 12:27:04.000000000 +0900
@@ -63,6 +63,9 @@
  *
  * Move do_SAK() into process context.  Less stack use in devfs functions.
  * alloc_tty_struct() always uses kmalloc() -- Andrew Morton <andrewm@uow.edu.eu> 17Mar01
+ *
+ * PlatHome <openlab.plathome.co.jp>
+ *	- Added for OpenBlockS 266
  */
 
 #include <linux/config.h>
@@ -2198,7 +2201,11 @@
 	memcpy(tty_std_termios.c_cc, INIT_C_CC, NCCS);
 	tty_std_termios.c_iflag = ICRNL | IXON;
 	tty_std_termios.c_oflag = OPOST | ONLCR;
+#ifdef CONFIG_OBS266
+	tty_std_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL;
+#else
 	tty_std_termios.c_cflag = B38400 | CS8 | CREAD | HUPCL;
+#endif
 	tty_std_termios.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK |
 		ECHOCTL | ECHOKE | IEXTEN;
 
diff -Naru linux-2.4.20.orig/drivers/char/x1226-rtc.c linux-2.4.20/drivers/char/x1226-rtc.c
--- linux-2.4.20.orig/drivers/char/x1226-rtc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/drivers/char/x1226-rtc.c	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,547 @@
+
+/*
+ *  linux/drivers/char/x1226-rtc.c
+ *
+ *  I2C Real Time Clock Client Driver for Xicor X1226 RTC/Calendar
+ *
+ *  Copyright 2002 MontaVista Software Inc.
+ *  Author: MontaVista Software, Inc.
+ *     	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  TODO:
+ *    - implement alarm and periodic IRQ support.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/rtc.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+#ifdef DEBUG_X1226
+#define	dbg(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define	dbg(fmt, args...)
+#endif
+
+#define X1226_MODULE_NAME "X1226"
+#define PFX X1226_MODULE_NAME
+#ifndef I2C_DRIVERID_X1226
+#define I2C_DRIVERID_X1226  I2C_DRIVERID_EXP0
+#endif
+
+#define err(format, arg...) printk(KERN_ERR PFX ": " format , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format , ## arg)
+#define emerg(format, arg...) printk(KERN_EMERG PFX ": " format , ## arg)
+
+#define EPOCH 2000
+#define SYS_EPOCH 1900
+
+#undef BCD_TO_BIN
+#define BCD_TO_BIN(val) (((val)&15) + ((val)>>4)*10)
+
+#undef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((((val)/10)<<4) + (val)%10)
+
+#define X1226_RTC_SR      0x3f
+#define   RTC_SR_RTCF  (1)
+#define   RTC_SR_WEL  (1<<1)
+#define   RTC_SR_RWEL (1<<2)
+
+#define X1226_RTC_BASE    0x30
+
+/* This is an image of the RTC registers starting at offset 0x30 */
+struct rtc_registers {
+	unsigned char secs;  // 30
+        unsigned char mins;  // 31
+        unsigned char hours; // 32
+        unsigned char day;   // 33
+        unsigned char mon;   // 34
+        unsigned char year;  // 35
+        unsigned char dayofweek; // 36
+        unsigned char epoch; // 37
+};
+
+#define X1226_CONTROL_DTR  0x13
+#define X1226_CONTROL_ATR  0x12
+#define X1226_CONTROL_INT  0x11
+#define X1226_CONTROL_BL   0x10
+
+#define DEVID_RTC          0x6F
+#define DEVID_NVRAM        0x57
+#define   SLAVE_READ 0x01
+#ifndef I2C_M_WR
+#define I2C_M_WR 0x0
+#endif
+#define ABITS           9
+#define EESIZE          (1 << ABITS)    /* size in bytes */
+
+#define NVSIZE          512             /* we use 512 bytes */
+#define NVOFFSET        (EESIZE-NVSIZE) /* at end of EEROM */
+
+static struct i2c_driver x1226_driver;
+
+static int x1226_use_count = 0;
+
+static struct i2c_client *this_client = NULL;
+
+static int rtc_read_proc(char *page, char **start, off_t off,
+                         int count, int *eof, void *data);
+
+
+
+
+static int x1226_read (struct i2c_client *client,
+		       u8 reg_offset, u8* buf, int len)
+{
+	int ret;
+	u8 regbuf[2] = { 0, reg_offset };
+	struct i2c_msg random_addr_read[2] = {
+		{
+			/* "Set Current Address" */
+			client->addr,
+			client->flags | I2C_M_WR,
+			sizeof(regbuf),
+			regbuf
+		},
+		{
+			/* "Sequential Read" if len>1,
+			   "Current Address Read" if len=1 */
+			client->addr ,
+			client->flags| I2C_M_RD ,
+			len,
+			buf
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, random_addr_read, 2)) != 2) {
+		ret = -ENXIO;
+		dbg("i2c_transfer failed\n");
+	}
+
+	return ret;
+}
+
+static int x1226_write (struct i2c_client *client,
+			u8 reg_offset, u8* buf, int len)
+{
+	int ret;
+	u8* local_buf;
+	u8 regbuf[2] = { 0, reg_offset };
+	struct i2c_msg page_write = {
+		client->addr,
+		client->flags ,
+		len + sizeof(regbuf),
+		NULL
+	};
+
+	if ((local_buf = (u8*)kmalloc(len + sizeof(regbuf),
+				      GFP_KERNEL)) == NULL) {
+		err("buffer alloc failed\n");
+		return -ENOMEM;
+	}
+
+	memcpy(local_buf, regbuf, sizeof(regbuf));
+	memcpy(local_buf + sizeof(regbuf), buf, len);
+	page_write.buf = local_buf;
+	
+	if ((ret = i2c_transfer(client->adapter, &page_write, 1)) != 1) {
+		ret = -ENXIO;
+		dbg("i2c_transfer failed\n");
+	}
+
+	kfree(local_buf);
+	return ret;
+}
+
+
+static int ccr_write_enable(struct i2c_client *client)
+{
+	u8 sr = RTC_SR_WEL;
+	int ret;
+	if ((ret = x1226_write(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+	sr |= RTC_SR_RWEL;
+	if ((ret = x1226_write(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+	sr = 0;
+	if ((ret = x1226_read(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+
+	sr &= (RTC_SR_RWEL | RTC_SR_RWEL);
+	if (sr != (RTC_SR_RWEL | RTC_SR_RWEL)) {
+		dbg("verify SR failed\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int ccr_write_disable(struct i2c_client *client)
+{
+	int ret;
+	u8 sr = 0;
+	
+	if ((ret = x1226_write(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+	if ((ret = x1226_read(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+	if (sr != 0) {
+		dbg("verify SR failed\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+
+static int
+x1226_get_time(struct i2c_client *client, struct rtc_time *tm)
+{	
+	struct rtc_registers rtc;
+	u32 epoch;
+	int ret;
+	
+	/* read RTC registers */
+	if ((ret = x1226_read(client, X1226_RTC_BASE, (u8*)&rtc,
+			      sizeof(struct rtc_registers))) < 0) {
+		dbg("couldn't read RTC\n");
+		return ret;
+	}
+	dbg("IN: epoch=%02x, year=%02x, mon=%02x, day=%02x, hour=%02x, "
+	    "min=%02x, sec=%02x\n",
+	    rtc.epoch, rtc.year, rtc.mon, rtc.day, rtc.hours,
+	    rtc.mins, rtc.secs);
+	
+	epoch  = 100 * BCD_TO_BIN(rtc.epoch);   // 19 / 20
+	tm->tm_year = BCD_TO_BIN(rtc.year); // 0 - 99
+	tm->tm_year += (epoch - SYS_EPOCH);
+	tm->tm_mon = BCD_TO_BIN(rtc.mon);   // 1 - 12
+	tm->tm_mon--;                       /* tm_mon is 0 to 11 */
+	tm->tm_mday = BCD_TO_BIN(rtc.day);  // 1 - 31
+	tm->tm_hour = BCD_TO_BIN(rtc.hours & ~0x80);
+	if (!(rtc.hours & 0x80)) {
+		// AM/PM 1-12 format, convert to MIL
+		tm->tm_hour--; // 0 - 11
+		if (rtc.hours & (1<<5))
+			tm->tm_hour += 12; // PM
+	}
+	
+	tm->tm_min = BCD_TO_BIN(rtc.mins);
+	tm->tm_sec = BCD_TO_BIN(rtc.secs);
+
+	dbg("OUT: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+	    tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
+	    tm->tm_min, tm->tm_sec);
+	
+	return 0;
+}
+
+static int 
+x1226_set_time(struct i2c_client *client, const struct rtc_time *tm)
+{
+	struct rtc_registers rtc;
+	int ret;
+
+	dbg("IN: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+	    tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
+	    tm->tm_min, tm->tm_sec);
+
+	rtc.epoch = BIN_TO_BCD(EPOCH/100);
+	rtc.year  = BIN_TO_BCD(tm->tm_year + SYS_EPOCH - EPOCH);
+	rtc.mon   = BIN_TO_BCD(tm->tm_mon + 1); /* tm_mon is 0 to 11 */
+	rtc.day   = BIN_TO_BCD(tm->tm_mday);
+	rtc.dayofweek = 0; // ignore day of week
+	rtc.hours = BIN_TO_BCD(tm->tm_hour) | 0x80; /* 24 hour format */
+	rtc.mins  = BIN_TO_BCD(tm->tm_min);
+	rtc.secs  = BIN_TO_BCD(tm->tm_sec);
+	
+	dbg("OUT: epoch=%02x, year=%02x, mon=%02x, day=%02x, hour=%02x, "
+	    "min=%02x, sec=%02x\n",
+	    rtc.epoch, rtc.year, rtc.mon, rtc.day, rtc.hours,
+	    rtc.mins, rtc.secs);
+	
+	/* write RTC registers */
+	if ((ret = ccr_write_enable(client)) < 0)
+		return ret;
+	if ((ret = x1226_write(client, X1226_RTC_BASE, (u8*)&rtc,
+			       sizeof(struct rtc_registers))) < 0) {
+		dbg("couldn't write RTC\n");
+		return ret;
+	}
+	ccr_write_disable(client);
+
+	return 0;
+}
+
+static int
+x1226_probe(struct i2c_adapter *adap)
+{
+	int ret;
+	char stat;
+	unsigned char crs[4];
+	struct rtc_time dummy_tm={0,0,0, 1, 0, 100, 0, 0};
+	if (this_client != NULL)
+		return -EBUSY;
+	
+	this_client = kmalloc(sizeof(*this_client), GFP_KERNEL);
+	if (this_client == NULL) {
+		return -ENOMEM;
+	}
+
+	strcpy(this_client->name, X1226_MODULE_NAME);
+	this_client->id		= x1226_driver.id;
+
+	this_client->flags	= 0;
+	this_client->addr	= DEVID_RTC;
+	this_client->adapter	= adap;
+	this_client->driver	= &x1226_driver;
+	this_client->data	= NULL;
+
+	/*
+	 * use x1226_get_time() to probe for an X1226 on this bus.
+	 */
+	if((ret = x1226_read(this_client,X1226_RTC_SR, &stat, 1))< 0){
+		kfree(this_client);
+		this_client = NULL;
+		return ret;
+	}
+	info("found X1226 on %s\n", adap->name);
+	if(stat & RTC_SR_RTCF){
+	  printk("X1226:Timer Not Initialized after power fail. Setting 2002/1/1/0:00\n" );
+	  ret= x1226_set_time(this_client, &dummy_tm);
+	}
+	dbg("stat %x \n", stat);
+	x1226_read(this_client,0x10, &crs[0], 1);
+	x1226_read(this_client,0x11, &crs[1], 1);
+	x1226_read(this_client,0x12, &crs[2], 1);
+	x1226_read(this_client,0x13, &crs[3], 1);
+	dbg("CTLREG:%d %x %x %x %x\n", ret, crs[0],crs[1],crs[2],crs[3]);
+
+	if ((ret = x1226_get_time(this_client, &dummy_tm)) < 0) {
+	  printk("Fetch Timer Failed\n");
+	}else{
+#ifdef DEBUG_X1226
+	  struct rtc_time *tm = &dummy_tm;
+	  dbg("OUT: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+	    tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
+	    tm->tm_min, tm->tm_sec);
+#endif
+	}
+
+	/* attach it. */
+	return i2c_attach_client(this_client);
+}
+
+static int
+x1226_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+
+	if (this_client != NULL) {
+		kfree(this_client);
+		this_client = NULL;
+	}
+
+	return 0;
+}
+
+int rtc_open(struct inode *minode, struct file *mfile)
+{
+	/*if(MOD_IN_USE)*/
+	if(x1226_use_count > 0) {
+		return -EBUSY;
+	}
+	MOD_INC_USE_COUNT;
+	++x1226_use_count;
+	return 0;
+}
+
+int rtc_release(struct inode *minode, struct file *mfile)
+{
+	MOD_DEC_USE_COUNT;
+	--x1226_use_count;
+	return 0;
+}
+
+static loff_t rtc_llseek(struct file *mfile, loff_t offset, int origint)
+{
+	return -ESPIPE;
+}
+
+static int
+x1226_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return -EINVAL;
+}
+
+static int rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		     unsigned long arg)
+{
+	struct rtc_time rtc_tm;
+	int ret;
+	
+	switch (cmd) {
+	case RTC_RD_TIME:	/* Read the time/date from RTC  */
+		if ((ret = x1226_get_time(this_client, &rtc_tm)) < 0)
+			return ret;
+		return copy_to_user((void *)arg, &rtc_tm, sizeof(rtc_tm)) ? 
+			-EFAULT : 0;
+	case RTC_SET_TIME:	/* Set the RTC */
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		if (copy_from_user(&rtc_tm, 
+				   (struct rtc_time *) arg,
+		                   sizeof(struct rtc_time))) 
+			return -EFAULT;
+
+		return x1226_set_time(this_client, &rtc_tm);
+	default:
+		return -EINVAL;
+	}
+}
+
+
+static struct i2c_driver x1226_driver = {
+	name:		X1226_MODULE_NAME,
+	id:		I2C_DRIVERID_X1226,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	x1226_probe,
+	detach_client:	x1226_detach,
+	command:	x1226_command
+};
+
+static struct file_operations rtc_fops = {
+	owner:		THIS_MODULE,
+	llseek:		rtc_llseek,
+	ioctl:		rtc_ioctl,
+	open:		rtc_open,
+	release:	rtc_release,
+};
+
+static struct miscdevice x1226rtc_miscdev = {
+	RTC_MINOR,
+	"rtc",
+	&rtc_fops
+};
+
+static __init int x1226_init(void)
+{
+	int ret;
+
+	info("I2C based RTC driver.\n");
+	ret = i2c_add_driver(&x1226_driver);
+	if (ret) {
+		err("Register I2C driver failed, errno is %d\n", ret);
+		return ret;
+	}
+	ret = misc_register(&x1226rtc_miscdev);
+	if (ret) {
+		err("Register misc driver failed, errno is %d\n", ret);
+		ret = i2c_del_driver(&x1226_driver);
+		if (ret) {
+			err("Unregister I2C driver failed, errno is %d\n",
+			    ret);
+		}
+		return ret;
+	}
+
+	create_proc_read_entry("driver/rtc", 0, 0, rtc_read_proc, NULL);
+
+	return 0;
+}
+
+static void __exit x1226_exit(void)
+{
+        remove_proc_entry("driver/rtc", NULL);
+        misc_deregister(&x1226rtc_miscdev);
+	i2c_del_driver(&x1226_driver);
+}
+
+
+module_init(x1226_init);
+module_exit(x1226_exit);
+
+/*
+ *	Info exported via "/proc/driver/rtc".
+ */
+
+static int rtc_proc_output(char *buf)
+{
+	char *p;
+	struct rtc_time tm;
+	int ret;
+	
+	if ((ret = x1226_get_time(this_client, &tm)) < 0)
+		return ret;
+
+	p = buf;
+
+	/*
+	 * There is no way to tell if the luser has the RTC set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	p += sprintf(p,
+		     "rtc_time\t: %02d:%02d:%02d\n"
+		     "rtc_date\t: %04d-%02d-%02d\n"
+		     "rtc_epoch\t: %04d\n",
+		     tm.tm_hour, tm.tm_min, tm.tm_sec,
+		     tm.tm_year + SYS_EPOCH, tm.tm_mon + 1,
+		     tm.tm_mday, EPOCH);
+
+	return p - buf;
+}
+
+static int rtc_read_proc(char *page, char **start, off_t off,
+			 int count, int *eof, void *data)
+{
+	int len = rtc_proc_output(page);
+	if (len <= off + count)
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+MODULE_AUTHOR("Steve Longerbeam");
+MODULE_LICENSE("GPL");
+
diff -Naru linux-2.4.20.orig/drivers/i2c/i2c-adap-ibm_ocp.c linux-2.4.20/drivers/i2c/i2c-adap-ibm_ocp.c
--- linux-2.4.20.orig/drivers/i2c/i2c-adap-ibm_ocp.c	2002-12-11 11:39:43.000000000 +0900
+++ linux-2.4.20/drivers/i2c/i2c-adap-ibm_ocp.c	2004-12-21 12:27:04.000000000 +0900
@@ -281,8 +281,7 @@
 				    (iic_drv->irq,
 				     iic_ibmocp_handler, 0, "IBM OCP IIC",
 				     iic_drv)) {
-					printk(KERN_ERR "iic_hw_resrc_init: Request irq%d 
-				failed\n", iic_drv->irq);
+					printk(KERN_ERR "iic_hw_resrc_init: Request irq%d failed\n", iic_drv->irq);
 					iic_drv->irq = 0;
 				} else {
 					DEB3(printk
diff -Naru linux-2.4.20.orig/drivers/i2c/i2c-algo-ibm_ocp.c linux-2.4.20/drivers/i2c/i2c-algo-ibm_ocp.c
--- linux-2.4.20.orig/drivers/i2c/i2c-algo-ibm_ocp.c	2002-12-11 11:37:04.000000000 +0900
+++ linux-2.4.20/drivers/i2c/i2c-algo-ibm_ocp.c	2004-12-21 12:27:04.000000000 +0900
@@ -56,6 +56,9 @@
 
    Version 05/25/02 - Armin
       name change for *_driver to *_dev
+
+   PlatHome <openlab.plathome.co.jp>
+	- Modified OpenBlockS 2xx
 */
 
 #include <linux/kernel.h>
@@ -755,6 +758,9 @@
 		DEB2(printk(KERN_DEBUG "iic_xfer: Call adapter's read\n"));
 		ret =
 		    iic_readbytes(adap, pmsg->buf, pmsg->len, IIC_SINGLE_XFER);
+#ifdef CONFIG_OBS2xx
+		ret = (ret == pmsg->len)? num: ret;
+#endif
 	}
 	/*
 	 * Write only
@@ -767,6 +773,9 @@
 		DEB2(printk(KERN_DEBUG "iic_xfer: Call adapter's write\n"));
 		ret =
 		    iic_sendbytes(adap, pmsg->buf, pmsg->len, IIC_SINGLE_XFER);
+#ifdef CONFIG_OBS2xx
+		ret = (ret == pmsg->len)? num: ret;
+#endif
 	}
 
 	return ret;
diff -Naru linux-2.4.20.orig/drivers/ide/hpt366.c linux-2.4.20/drivers/ide/hpt366.c
--- linux-2.4.20.orig/drivers/ide/hpt366.c	2002-12-11 11:38:06.000000000 +0900
+++ linux-2.4.20/drivers/ide/hpt366.c	2004-12-21 12:27:04.000000000 +0900
@@ -40,6 +40,9 @@
  * Reset the hpt366 on error, reset on dma
  * Fix disabling Fast Interrupt hpt366.
  * 	Mike Waychison <crlf@sun.com>
+ *
+ *  PlatHome <openlab.plathome.co.jp>
+ *      - Adjusted for OpenBlockS 266 from linux-2.5.63/drivers/ide/pci/hpt366.h
  */
 
 #include <linux/config.h>
@@ -75,6 +78,9 @@
 #include <linux/proc_fs.h>
 #endif  /* defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS) */
 
+static unsigned int hpt_revision(struct pci_dev *dev);
+static unsigned int hpt_minimum_revision(struct pci_dev *dev, int revision);
+
 extern char *ide_dmafunc_verbose(ide_dma_action_t dmafunc);
 
 const char *quirk_drives[] = {
@@ -144,6 +150,7 @@
 	unsigned int	chipset_settings;
 };
 
+/* from linux-2.5.63/drivers/ide/pci/hpt366.h */
 /* key for bus clock timings
  * bit
  * 0:3    data_high_time. inactive time of DIOW_/DIOR_ for PIO and MW
@@ -166,9 +173,8 @@
  *        PIO.
  * 31     FIFO enable.
  */
-struct chipset_bus_clock_list_entry forty_base [] = {
-
-	{	XFER_UDMA_4,    0x900fd943	},
+struct chipset_bus_clock_list_entry forty_base_hpt366[] = {
+	{	XFER_UDMA_4,	0x900fd943	},
 	{	XFER_UDMA_3,	0x900ad943	},
 	{	XFER_UDMA_2,	0x900bd943	},
 	{	XFER_UDMA_1,	0x9008d943	},
@@ -186,8 +192,7 @@
 	{	0,		0x0120d9d9	}
 };
 
-struct chipset_bus_clock_list_entry thirty_three_base [] = {
-
+struct chipset_bus_clock_list_entry thirty_three_base_hpt366[] = {
 	{	XFER_UDMA_4,	0x90c9a731	},
 	{	XFER_UDMA_3,	0x90cfa731	},
 	{	XFER_UDMA_2,	0x90caa731	},
@@ -206,7 +211,7 @@
 	{	0,		0x0120a7a7	}
 };
 
-struct chipset_bus_clock_list_entry twenty_five_base [] = {
+struct chipset_bus_clock_list_entry twenty_five_base_hpt366[] = {
 
 	{	XFER_UDMA_4,	0x90c98521	},
 	{	XFER_UDMA_3,	0x90cf8521	},
@@ -226,51 +231,9 @@
 	{	0,		0x01208585	}
 };
 
-#if 1
-/* these are the current (4 sep 2001) timings from highpoint */
-struct chipset_bus_clock_list_entry thirty_three_base_hpt370[] = {
-        {       XFER_UDMA_5,    0x12446231      },
-        {       XFER_UDMA_4,    0x12446231      },
-        {       XFER_UDMA_3,    0x126c6231      },
-        {       XFER_UDMA_2,    0x12486231      },
-        {       XFER_UDMA_1,    0x124c6233      },
-        {       XFER_UDMA_0,    0x12506297      },
-
-        {       XFER_MW_DMA_2,  0x22406c31      },
-        {       XFER_MW_DMA_1,  0x22406c33      },
-        {       XFER_MW_DMA_0,  0x22406c97      },
-
-        {       XFER_PIO_4,     0x06414e31      },
-        {       XFER_PIO_3,     0x06414e42      },
-        {       XFER_PIO_2,     0x06414e53      },
-        {       XFER_PIO_1,     0x06814e93      },
-        {       XFER_PIO_0,     0x06814ea7      },
-        {       0,              0x06814ea7      }
-};
-
-/* 2x 33MHz timings */
-struct chipset_bus_clock_list_entry sixty_six_base_hpt370[] = {
-	{       XFER_UDMA_5,    0x1488e673       },
-	{       XFER_UDMA_4,    0x1488e673       },
-	{       XFER_UDMA_3,    0x1498e673       },
-	{       XFER_UDMA_2,    0x1490e673       },
-	{       XFER_UDMA_1,    0x1498e677       },
-	{       XFER_UDMA_0,    0x14a0e73f       },
-
-	{       XFER_MW_DMA_2,  0x2480fa73       },
-	{       XFER_MW_DMA_1,  0x2480fa77       }, 
-	{       XFER_MW_DMA_0,  0x2480fb3f       },
-
-	{       XFER_PIO_4,     0x0c82be73       },
-	{       XFER_PIO_3,     0x0c82be95       },
-	{       XFER_PIO_2,     0x0c82beb7       },
-	{       XFER_PIO_1,     0x0d02bf37       },
-	{       XFER_PIO_0,     0x0d02bf5f       },
-	{       0,              0x0d02bf5f       }
-};
-#else
 /* from highpoint documentation. these are old values */
 struct chipset_bus_clock_list_entry thirty_three_base_hpt370[] = {
+/*	{	XFER_UDMA_5,	0x1A85F442,	0x16454e31	}, */
 	{	XFER_UDMA_5,	0x16454e31	},
 	{	XFER_UDMA_4,	0x16454e31	},
 	{	XFER_UDMA_3,	0x166d4e31	},
@@ -309,9 +272,50 @@
 	{       XFER_PIO_0,     0x06914e57      },
 	{       0,              0x06514e57      }
 };
-#endif
 
-struct chipset_bus_clock_list_entry fifty_base_hpt370[] = {
+/* these are the current (4 sep 2001) timings from highpoint */
+struct chipset_bus_clock_list_entry thirty_three_base_hpt370a[] = {
+        {       XFER_UDMA_5,    0x12446231      },
+        {       XFER_UDMA_4,    0x12446231      },
+        {       XFER_UDMA_3,    0x126c6231      },
+        {       XFER_UDMA_2,    0x12486231      },
+        {       XFER_UDMA_1,    0x124c6233      },
+        {       XFER_UDMA_0,    0x12506297      },
+
+        {       XFER_MW_DMA_2,  0x22406c31      },
+        {       XFER_MW_DMA_1,  0x22406c33      },
+        {       XFER_MW_DMA_0,  0x22406c97      },
+
+        {       XFER_PIO_4,     0x06414e31      },
+        {       XFER_PIO_3,     0x06414e42      },
+        {       XFER_PIO_2,     0x06414e53      },
+        {       XFER_PIO_1,     0x06814e93      },
+        {       XFER_PIO_0,     0x06814ea7      },
+        {       0,              0x06814ea7      }
+};
+
+/* 2x 33MHz timings */
+struct chipset_bus_clock_list_entry sixty_six_base_hpt370a[] = {
+	{       XFER_UDMA_5,    0x1488e673       },
+	{       XFER_UDMA_4,    0x1488e673       },
+	{       XFER_UDMA_3,    0x1498e673       },
+	{       XFER_UDMA_2,    0x1490e673       },
+	{       XFER_UDMA_1,    0x1498e677       },
+	{       XFER_UDMA_0,    0x14a0e73f       },
+
+	{       XFER_MW_DMA_2,  0x2480fa73       },
+	{       XFER_MW_DMA_1,  0x2480fa77       }, 
+	{       XFER_MW_DMA_0,  0x2480fb3f       },
+
+	{       XFER_PIO_4,     0x0c82be73       },
+	{       XFER_PIO_3,     0x0c82be95       },
+	{       XFER_PIO_2,     0x0c82beb7       },
+	{       XFER_PIO_1,     0x0d02bf37       },
+	{       XFER_PIO_0,     0x0d02bf5f       },
+	{       0,              0x0d02bf5f       }
+};
+
+struct chipset_bus_clock_list_entry fifty_base_hpt370a[] = {
 	{       XFER_UDMA_5,    0x12848242      },
 	{       XFER_UDMA_4,    0x12ac8242      },
 	{       XFER_UDMA_3,    0x128c8242      },
@@ -331,7 +335,149 @@
 	{       0,              0x0ac1f48a      }
 };
 
+struct chipset_bus_clock_list_entry thirty_three_base_hpt372[] = {
+	{	XFER_UDMA_6,	0x1c81dc62	},
+	{	XFER_UDMA_5,	0x1c6ddc62	},
+	{	XFER_UDMA_4,	0x1c8ddc62	},
+	{	XFER_UDMA_3,	0x1c8edc62	},	/* checkme */
+	{	XFER_UDMA_2,	0x1c91dc62	},
+	{	XFER_UDMA_1,	0x1c9adc62	},	/* checkme */
+	{	XFER_UDMA_0,	0x1c82dc62	},	/* checkme */
+
+	{	XFER_MW_DMA_2,	0x2c829262	},
+	{	XFER_MW_DMA_1,	0x2c829266	},	/* checkme */
+	{	XFER_MW_DMA_0,	0x2c82922e	},	/* checkme */
+
+	{	XFER_PIO_4,	0x0c829c62	},
+	{	XFER_PIO_3,	0x0c829c84	},
+	{	XFER_PIO_2,	0x0c829ca6	},
+	{	XFER_PIO_1,	0x0d029d26	},
+	{	XFER_PIO_0,	0x0d029d5e	},
+	{	0,		0x0d029d5e	}
+};
+
+struct chipset_bus_clock_list_entry fifty_base_hpt372[] = {
+	{	XFER_UDMA_5,	0x12848242	},
+	{	XFER_UDMA_4,	0x12ac8242	},
+	{	XFER_UDMA_3,	0x128c8242	},
+	{	XFER_UDMA_2,	0x120c8242	},
+	{	XFER_UDMA_1,	0x12148254	},
+	{	XFER_UDMA_0,	0x121882ea	},
+
+	{	XFER_MW_DMA_2,	0x22808242	},
+	{	XFER_MW_DMA_1,	0x22808254	},
+	{	XFER_MW_DMA_0,	0x228082ea	},
+
+	{	XFER_PIO_4,	0x0a81f442	},
+	{	XFER_PIO_3,	0x0a81f443	},
+	{	XFER_PIO_2,	0x0a81f454	},
+	{	XFER_PIO_1,	0x0ac1f465	},
+	{	XFER_PIO_0,	0x0ac1f48a	},
+	{	0,		0x0a81f443	}
+};
+
+struct chipset_bus_clock_list_entry sixty_six_base_hpt372[] = {
+	{	XFER_UDMA_6,	0x1c869c62	},
+	{	XFER_UDMA_5,	0x1cae9c62	},
+	{	XFER_UDMA_4,	0x1c8a9c62	},
+	{	XFER_UDMA_3,	0x1c8e9c62	},
+	{	XFER_UDMA_2,	0x1c929c62	},
+	{	XFER_UDMA_1,	0x1c9a9c62	},
+	{	XFER_UDMA_0,	0x1c829c62	},
+
+	{	XFER_MW_DMA_2,	0x2c829c62	},
+	{	XFER_MW_DMA_1,	0x2c829c66	},
+	{	XFER_MW_DMA_0,	0x2c829d2e	},
+
+	{	XFER_PIO_4,	0x0c829c62	},
+	{	XFER_PIO_3,	0x0c829c84	},
+	{	XFER_PIO_2,	0x0c829ca6	},
+	{	XFER_PIO_1,	0x0d029d26	},
+	{	XFER_PIO_0,	0x0d029d5e	},
+	{	0,		0x0d029d26	}
+};
+
+struct chipset_bus_clock_list_entry thirty_three_base_hpt374[] = {
+	{	XFER_UDMA_6,	0x12808242	},
+	{	XFER_UDMA_5,	0x12848242	},
+	{	XFER_UDMA_4,	0x12ac8242	},
+	{	XFER_UDMA_3,	0x128c8242	},
+	{	XFER_UDMA_2,	0x120c8242	},
+	{	XFER_UDMA_1,	0x12148254	},
+	{	XFER_UDMA_0,	0x121882ea	},
+
+	{	XFER_MW_DMA_2,	0x22808242	},
+	{	XFER_MW_DMA_1,	0x22808254	},
+	{	XFER_MW_DMA_0,	0x228082ea	},
+
+	{	XFER_PIO_4,	0x0a81f442	},
+	{	XFER_PIO_3,	0x0a81f443	},
+	{	XFER_PIO_2,	0x0a81f454	},
+	{	XFER_PIO_1,	0x0ac1f465	},
+	{	XFER_PIO_0,	0x0ac1f48a	},
+	{	0,		0x06814e93	}
+};
+
+#if 0
+struct chipset_bus_clock_list_entry fifty_base_hpt374[] = {
+	{	XFER_UDMA_6,	},
+	{	XFER_UDMA_5,	},
+	{	XFER_UDMA_4,	},
+	{	XFER_UDMA_3,	},
+	{	XFER_UDMA_2,	},
+	{	XFER_UDMA_1,	},
+	{	XFER_UDMA_0,	},
+	{	XFER_MW_DMA_2,	},
+	{	XFER_MW_DMA_1,	},
+	{	XFER_MW_DMA_0,	},
+	{	XFER_PIO_4,	},
+	{	XFER_PIO_3,	},
+	{	XFER_PIO_2,	},
+	{	XFER_PIO_1,	},
+	{	XFER_PIO_0,	},
+	{	0,	}
+};
+#endif
+#if 0
+struct chipset_bus_clock_list_entry sixty_six_base_hpt374[] = {
+	{	XFER_UDMA_6,	0x12406231	},	/* checkme */
+	{	XFER_UDMA_5,	0x12446231	},
+				0x14846231
+	{	XFER_UDMA_4,		0x16814ea7	},
+				0x14886231
+	{	XFER_UDMA_3,		0x16814ea7	},
+				0x148c6231
+	{	XFER_UDMA_2,		0x16814ea7	},
+				0x148c6231
+	{	XFER_UDMA_1,		0x16814ea7	},
+				0x14906231
+	{	XFER_UDMA_0,		0x16814ea7	},
+				0x14986231
+	{	XFER_MW_DMA_2,		0x16814ea7	},
+				0x26514e21
+	{	XFER_MW_DMA_1,		0x16814ea7	},
+				0x26514e97
+	{	XFER_MW_DMA_0,		0x16814ea7	},
+				0x26514e97
+	{	XFER_PIO_4,		0x06814ea7	},
+				0x06514e21
+	{	XFER_PIO_3,		0x06814ea7	},
+				0x06514e22
+	{	XFER_PIO_2,		0x06814ea7	},
+				0x06514e33
+	{	XFER_PIO_1,		0x06814ea7	},
+				0x06914e43
+	{	XFER_PIO_0,		0x06814ea7	},
+				0x06914e57
+	{	0,		0x06814ea7	}
+};
+#endif
+
 #define HPT366_DEBUG_DRIVE_INFO		0
+#define HPT374_ALLOW_ATA133_6		0
+#define HPT371_ALLOW_ATA133_6		0
+#define HPT302_ALLOW_ATA133_6		0
+#define HPT372_ALLOW_ATA133_6		1
 #define HPT370_ALLOW_ATA100_5		1
 #define HPT366_ALLOW_ATA66_4		1
 #define HPT366_ALLOW_ATA66_3		1
@@ -345,13 +491,13 @@
 static struct pci_dev *hpt_devs[HPT366_MAX_DEVS];
 static int n_hpt_devs;
 
-static unsigned int pci_rev_check_hpt3xx(struct pci_dev *dev);
-static unsigned int pci_rev2_check_hpt3xx(struct pci_dev *dev);
 byte hpt366_proc = 0;
 byte hpt363_shared_irq;
 byte hpt363_shared_pin;
 extern char *ide_xfer_verbose (byte xfer_rate);
 
+static int hpt37x_ide_dma_check_done=0;
+
 #if defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS)
 static int hpt366_get_info(char *, char **, off_t, int);
 extern int (*hpt366_display_info)(char *, char **, off_t, int); /* ide-proc.c */
@@ -360,21 +506,20 @@
 static int hpt366_get_info (char *buffer, char **addr, off_t offset, int count)
 {
 	char *p	= buffer;
-	char *chipset_nums[] = {"366", "366", "368", "370", "370A"};
+	char *chipset_nums[] = {"366", "366", "368", "370", "370A",
+				"372", "302", "371",  "374" };
 	int i;
 
 	p += sprintf(p, "\n                             "
-		"HighPoint HPT366/368/370\n");
+		     "HighPoint HPT366/368/370/371\n");
 	for (i = 0; i < n_hpt_devs; i++) {
 		struct pci_dev *dev = hpt_devs[i];
 		unsigned long iobase = dev->resource[4].start;
-		u32 class_rev;
+		u32 class_rev = hpt_revision(dev);
 		u8 c0, c1;
 
-		pci_read_config_dword(dev, PCI_CLASS_REVISION, &class_rev);
-		class_rev &= 0xff;
-
 		p += sprintf(p, "\nController: %d\n", i);
+
 		p += sprintf(p, "Chipset: HPT%s\n", chipset_nums[class_rev]);
 		p += sprintf(p, "--------------- Primary Channel "
 				"--------------- Secondary Channel "
@@ -388,7 +533,8 @@
 			(c0 & 0x80) ? "no" : "yes",
 			(c1 & 0x80) ? "no" : "yes");
 
-		if (pci_rev_check_hpt3xx(dev)) {
+#ifdef NEVER
+		if (hpt_minimum_revision(dev, 3)) {
 			u8 cbl;
 			cbl = inb_p(iobase + 0x7b);
 			outb_p(cbl | 1, iobase + 0x7b);
@@ -400,6 +546,7 @@
 				(cbl & 0x01) ? 33 : 66);
 			p += sprintf(p, "\n");
 		}
+#endif
 
 		p += sprintf(p, "--------------- drive0 --------- drive1 "
 				"------- drive0 ---------- drive1 -------\n");
@@ -437,20 +584,111 @@
 }
 #endif  /* defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS) */
 
-static unsigned int pci_rev_check_hpt3xx (struct pci_dev *dev)
+static u32 hpt_revision (struct pci_dev *dev)
 {
-	unsigned int class_rev;
+	u32 class_rev;
 	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class_rev);
 	class_rev &= 0xff;
-	return ((int) (class_rev > 0x02) ? 1 : 0);
+
+	switch(dev->device) {
+		case PCI_DEVICE_ID_TTI_HPT374:
+			class_rev = PCI_DEVICE_ID_TTI_HPT374; break;
+		case PCI_DEVICE_ID_TTI_HPT371:
+			class_rev = PCI_DEVICE_ID_TTI_HPT371; break;
+		case PCI_DEVICE_ID_TTI_HPT302:
+			class_rev = PCI_DEVICE_ID_TTI_HPT302; break;
+		case PCI_DEVICE_ID_TTI_HPT372:
+			class_rev = PCI_DEVICE_ID_TTI_HPT372; break;
+		default:
+			break;
+	}
+	return class_rev;
 }
 
-static unsigned int pci_rev2_check_hpt3xx (struct pci_dev *dev)
+static u32 hpt_minimum_revision (struct pci_dev *dev, int revision)
 {
-	unsigned int class_rev;
-	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class_rev);
-	class_rev &= 0xff;
-	return ((int) (class_rev > 0x01) ? 1 : 0);
+	unsigned int class_rev = hpt_revision(dev);
+	revision--;
+	return ((int) (class_rev > revision) ? 1 : 0);
+}
+
+static int check_in_drive_lists(ide_drive_t *drive, const char **list);
+
+static u8 hpt3xx_ratemask (ide_drive_t *drive)
+{
+	struct pci_dev *dev	= HWIF(drive)->pci_dev;
+	u8 mode			= 0;
+
+	if (hpt_minimum_revision(dev, 8)) {		/* HPT374 */
+		mode = (HPT374_ALLOW_ATA133_6) ? 4 : 3;
+	} else if (hpt_minimum_revision(dev, 7)) {	/* HPT371 */
+		mode = (HPT371_ALLOW_ATA133_6) ? 4 : 3;
+	} else if (hpt_minimum_revision(dev, 6)) {	/* HPT302 */
+		mode = (HPT302_ALLOW_ATA133_6) ? 4 : 3;
+	} else if (hpt_minimum_revision(dev, 5)) {	/* HPT372 */
+		mode = (HPT372_ALLOW_ATA133_6) ? 4 : 3;
+	} else if (hpt_minimum_revision(dev, 4)) {	/* HPT370A */
+		mode = (HPT370_ALLOW_ATA100_5) ? 3 : 2;
+	} else if (hpt_minimum_revision(dev, 3)) {	/* HPT370 */
+		mode = (HPT370_ALLOW_ATA100_5) ? 3 : 2;
+		mode = (check_in_drive_lists(drive, bad_ata33)) ? 0 : mode;
+	} else {				/* HPT366 and HPT368 */
+		mode = (check_in_drive_lists(drive, bad_ata33)) ? 0 : 2;
+	}
+	if (!eighty_ninty_three(drive) && (mode))
+		mode = min(mode, (u8)1);
+	return mode;
+}
+
+static u8 hpt3xx_ratefilter (ide_drive_t *drive, u8 speed)
+{
+	struct pci_dev *dev	= HWIF(drive)->pci_dev;
+	u8 mode			= hpt3xx_ratemask(drive);
+
+	if (drive->media != ide_disk)
+		return min(speed, (u8)XFER_PIO_4);
+
+	switch(mode) {
+		case 0x04:
+			speed = min(speed, (u8)XFER_UDMA_6);
+			break;
+		case 0x03:
+			speed = min(speed, (u8)XFER_UDMA_5);
+			if (hpt_minimum_revision(dev, 5))
+				break;
+			if (check_in_drive_lists(drive, bad_ata100_5))
+				speed = min(speed, (u8)XFER_UDMA_4);
+			break;
+		case 0x02:
+			speed = min(speed, (u8)XFER_UDMA_4);
+	/*
+	 * CHECK ME, Does this need to be set to 5 ??
+	 */
+			if (hpt_minimum_revision(dev, 3))
+				break;
+			if ((check_in_drive_lists(drive, bad_ata66_4)) ||
+			    (!(HPT366_ALLOW_ATA66_4)))
+				speed = min(speed, (u8)XFER_UDMA_3);
+			if ((check_in_drive_lists(drive, bad_ata66_3)) ||
+			    (!(HPT366_ALLOW_ATA66_3)))
+				speed = min(speed, (u8)XFER_UDMA_2);
+			break;
+		case 0x01:
+			speed = min(speed, (u8)XFER_UDMA_2);
+	/*
+	 * CHECK ME, Does this need to be set to 5 ??
+	 */
+			if (hpt_minimum_revision(dev, 3))
+				break;
+			if (check_in_drive_lists(drive, bad_ata33))
+				speed = min(speed, (u8)XFER_MW_DMA_2);
+			break;
+		case 0x00:
+		default:
+			speed = min(speed, (u8)XFER_MW_DMA_2);
+			break;
+	}
+	return speed;
 }
 
 static int check_in_drive_lists (ide_drive_t *drive, const char **list)
@@ -498,28 +736,28 @@
 	 * Disable the "fast interrupt" prediction. 
 	 */
 	pci_read_config_byte(HWIF(drive)->pci_dev, regfast, &drive_fast);
-	if (drive_fast & 0x02)
-		pci_write_config_byte(HWIF(drive)->pci_dev, regfast, drive_fast & ~0x20);
+	if (drive_fast & 0x80)
+		pci_write_config_byte(HWIF(drive)->pci_dev, regfast, drive_fast & ~0x80);
 
 	pci_read_config_dword(HWIF(drive)->pci_dev, regtime, &reg1);
 	/* detect bus speed by looking at control reg timing: */
 	switch((reg1 >> 8) & 7) {
 		case 5:
-			reg2 = pci_bus_clock_list(speed, forty_base);
+			reg2 = pci_bus_clock_list(speed, forty_base_hpt366);
 			break;
 		case 9:
-			reg2 = pci_bus_clock_list(speed, twenty_five_base);
+			reg2 = pci_bus_clock_list(speed, twenty_five_base_hpt366);
 			break;
 		default:
 		case 7:
-			reg2 = pci_bus_clock_list(speed, thirty_three_base);
+			reg2 = pci_bus_clock_list(speed, thirty_three_base_hpt366);
 			break;
 	}
 #if 0
 	/* this is a nice idea ... */
 	list_conf = pci_bus_clock_list(speed,
 				       (struct chipset_bus_clock_list_entry *)
-				       dev->sysdata);
+				       pci_get_drvdata(dev));
 #endif
 	/*
 	 * Disable on-chip PIO FIFO/buffer (to avoid problems handling I/O errors later)
@@ -534,6 +772,11 @@
 	pci_write_config_dword(HWIF(drive)->pci_dev, regtime, reg2);
 }
 
+static void hpt368_tune_chipset (ide_drive_t *drive, u8 speed)
+{
+	hpt366_tune_chipset(drive, speed);
+}
+
 static void hpt370_tune_chipset (ide_drive_t *drive, byte speed)
 {
 	byte regfast		= (HWIF(drive)->channel) ? 0x55 : 0x51;
@@ -544,6 +787,7 @@
 	byte new_fast, drive_fast		= 0;
 	struct pci_dev *dev 	= HWIF(drive)->pci_dev;
 
+	printk("HPT366: use old code -- fix me\n");
 	/*
 	 * Disable the "fast interrupt" prediction.
 	 * don't holdoff on interrupts. (== 0x01 despite what the docs say) 
@@ -565,7 +809,7 @@
 
 	list_conf = pci_bus_clock_list(speed, 
 				       (struct chipset_bus_clock_list_entry *)
-				       dev->sysdata);
+				       pci_get_drvdata(dev));
 
 	pci_read_config_dword(dev, drive_pci, &drive_conf);
 	list_conf = (list_conf & ~conf_mask) | (drive_conf & conf_mask);
@@ -577,19 +821,65 @@
 	pci_write_config_dword(dev, drive_pci, list_conf);
 }
 
+static void hpt372_tune_chipset (ide_drive_t *drive, u8 xferspeed)
+{
+	struct pci_dev *dev	= HWIF(drive)->pci_dev;
+	u8 speed	= hpt3xx_ratefilter(drive, xferspeed);
+//	u8 speed	= ide_rate_filter(hpt3xx_ratemask(drive), xferspeed);
+	u8 regfast	= (HWIF(drive)->channel) ? 0x55 : 0x51;
+	u8 drive_fast	= 0, drive_pci = 0x40 + (drive->dn * 4);
+	u32 list_conf	= 0, drive_conf = 0;
+	u32 conf_mask	= (speed >= XFER_MW_DMA_0) ? 0xc0000000 : 0x30070000;
+
+	/*
+	 * Disable the "fast interrupt" prediction.
+	 * don't holdoff on interrupts. (== 0x01 despite what the docs say)
+	 */
+	pci_read_config_byte(dev, regfast, &drive_fast);
+	drive_fast &= ~0x07;
+	pci_write_config_byte(dev, regfast, drive_fast);
+					
+	list_conf = pci_bus_clock_list(speed,
+			(struct chipset_bus_clock_list_entry *)
+					pci_get_drvdata(dev));
+	pci_read_config_dword(dev, drive_pci, &drive_conf);
+	list_conf = (list_conf & ~conf_mask) | (drive_conf & conf_mask);
+	if (speed < XFER_MW_DMA_0)
+		list_conf &= ~0x80000000; /* Disable on-chip PIO FIFO/buffer */
+	pci_write_config_dword(dev, drive_pci, list_conf);
+}
+
+static void hpt374_tune_chipset (ide_drive_t *drive, u8 speed)
+{
+	hpt372_tune_chipset(drive, speed);
+}
+
 static int hpt3xx_tune_chipset (ide_drive_t *drive, byte speed)
 {
+	struct pci_dev *dev	= HWIF(drive)->pci_dev;
+
 	if ((drive->media != ide_disk) && (speed < XFER_SW_DMA_0))
 		return -1;
 
 	if (!drive->init_speed)
 		drive->init_speed = speed;
 
-	if (pci_rev_check_hpt3xx(HWIF(drive)->pci_dev)) {
+	if (hpt_minimum_revision(dev, 8))
+		hpt374_tune_chipset(drive, speed);
+#if 0
+	else if (hpt_minimum_revision(dev, 7))
+		hpt371_tune_chipset(drive, speed);
+	else if (hpt_minimum_revision(dev, 6))
+		hpt302_tune_chipset(drive, speed);
+#endif
+	else if (hpt_minimum_revision(dev, 5))
+		hpt372_tune_chipset(drive, speed);
+	else if (hpt_minimum_revision(dev, 3))
 		hpt370_tune_chipset(drive, speed);
-        } else {
+	else if (hpt_minimum_revision(dev, 2))
+		hpt368_tune_chipset(drive, speed);
+	else
                 hpt366_tune_chipset(drive, speed);
-        }
 	drive->current_speed = speed;
 	return ((int) ide_config_drive_speed(drive, speed));
 }
@@ -642,6 +932,9 @@
 		case 1:		speed = XFER_PIO_1;break;
 		default:	speed = XFER_PIO_0;break;
 	}
+
+	/* no check a range of pio -- fix me */
+
 	(void) hpt3xx_tune_chipset(drive, speed);
 }
 
@@ -662,28 +955,36 @@
 	struct hd_driveid *id	= drive->id;
 	byte speed		= 0x00;
 	byte ultra66		= eighty_ninty_three(drive);
+	byte mode		= hpt3xx_ratemask(drive);
 	int  rval;
 
 	if ((drive->media != ide_disk) && (speed < XFER_SW_DMA_0))
 		return ((int) ide_dma_off_quietly);
 
-	if ((id->dma_ultra & 0x0020) &&
+	if ((id->dma_ultra & 0x0040) &&
+	    (HPT370_ALLOW_ATA100_5)  &&
+	    (mode >= 0x04) &&
+	    (ultra66)) {
+		speed = XFER_UDMA_6;
+	} else if ((id->dma_ultra & 0x0020) &&
 	    (!check_in_drive_lists(drive, bad_ata100_5)) &&
 	    (HPT370_ALLOW_ATA100_5) &&
-	    (pci_rev_check_hpt3xx(HWIF(drive)->pci_dev)) &&
+	    (mode >= 0x03) &&
 	    (ultra66)) {
 		speed = XFER_UDMA_5;
 	} else if ((id->dma_ultra & 0x0010) &&
 		   (!check_in_drive_lists(drive, bad_ata66_4)) &&
-		   (HPT366_ALLOW_ATA66_4) &&
+		   (mode >= 0x02) &&
 		   (ultra66)) {
 		speed = XFER_UDMA_4;
 	} else if ((id->dma_ultra & 0x0008) &&
 		   (!check_in_drive_lists(drive, bad_ata66_3)) &&
-		   (HPT366_ALLOW_ATA66_3) &&
+		   (mode >= 0x02) &&
 		   (ultra66)) {
 		speed = XFER_UDMA_3;
-	} else if (id->dma_ultra && (!check_in_drive_lists(drive, bad_ata33))) {
+	} else if (id->dma_ultra &&
+		   (mode >= 0x01) &&
+		   (!check_in_drive_lists(drive, bad_ata33))) {
 		if (id->dma_ultra & 0x0004) {
 			speed = XFER_UDMA_2;
 		} else if (id->dma_ultra & 0x0002) {
@@ -727,7 +1028,7 @@
 void hpt3xx_maskproc (ide_drive_t *drive, int mask)
 {
 	if (drive->quirk_list) {
-		if (pci_rev_check_hpt3xx(HWIF(drive)->pci_dev)) {
+		if (hpt_minimum_revision(HWIF(drive)->pci_dev,3)) {
 			byte reg5a = 0;
 			pci_read_config_byte(HWIF(drive)->pci_dev, 0x5a, &reg5a);
 			if (((reg5a & 0x10) >> 4) != mask)
@@ -751,6 +1052,7 @@
 	ide_dma_action_t dma_func = ide_dma_on;
 
 	if (id && (id->capability & 1) && HWIF(drive)->autodma) {
+		hpt37x_ide_dma_check_done = 1;
 		/* Consult the list of known "bad" drives */
 		if (ide_dmaproc(ide_dma_bad_drive, drive)) {
 			dma_func = ide_dma_off;
@@ -767,7 +1069,7 @@
 			}
 		} else if (id->field_valid & 2) {
 try_dma_modes:
-			if (id->dma_mword & 0x0007) {
+			if (id->dma_mword & 0x0007) {  /* xxx */
 				/* Force if Capable regular DMA modes */
 				dma_func = config_chipset_for_dma(drive);
 				if (dma_func != ide_dma_on)
@@ -784,12 +1086,16 @@
 		} else {
 			goto fast_ata_pio;
 		}
-	} else if ((id->capability & 8) || (id->field_valid & 2)) {
+	} else if ( (id && (id->capability & 8)) || (id->field_valid & 2)) {
 fast_ata_pio:
 		dma_func = ide_dma_off_quietly;
 no_dma_set:
-
 		config_chipset_for_pio(drive);
+	} else {
+		if( !(id && (id->capability & 1)) ){
+			printk("HPT37X: %s: unsupported DMA drive\n", drive->name);
+			return 1;
+		}
 	}
 	return HWIF(drive)->dmaproc(dma_func, drive);
 }
@@ -889,6 +1195,41 @@
 	}
 	return ide_dmaproc(func, drive);	/* use standard DMA stuff */
 }
+
+int hpt37x_dmaproc (ide_dma_action_t func, ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct pci_dev *dev = hwif->pci_dev;
+	byte msc_stat = 0, mscreg = hwif->channel ? 0x54 : 0x50;
+	byte bwsr_stat = 0, bwsr_mask = hwif->channel ? 0x02 : 0x01;
+
+	switch (func) {
+		case ide_dma_check:
+			return config_drive_xfer_rate(drive);
+		case ide_dma_end:
+			pci_read_config_byte(dev, 0x6a, &bwsr_stat);
+			pci_read_config_byte(dev, mscreg, &msc_stat);
+			if ((bwsr_stat & bwsr_mask) == bwsr_mask)
+				pci_write_config_byte(dev, mscreg, msc_stat|0x30);
+			break;
+		case ide_dma_on:
+			if( !hpt37x_ide_dma_check_done ){
+				/* kernel parameter: ide0=noautotune or ide=nodma */
+				if( !hwif->autodma ){
+					/* kernel parameter: ide=nodma */
+
+					printk("HPT37X: Allow DMA\n");
+					hwif->autodma = 1;
+				}
+				(void) (HWIF(drive)->dmaproc(ide_dma_off_quietly, drive));
+				(void) (HWIF(drive)->dmaproc(ide_dma_check, drive));
+			}
+			break;
+		default:
+			break;
+	}
+	return ide_dmaproc(func, drive);	/* use standard DMA stuff */
+}
 #endif /* CONFIG_BLK_DEV_IDEDMA */
 
 /*
@@ -1006,13 +1347,20 @@
 	return 0;
 }
 
-static void __init init_hpt370(struct pci_dev *dev)
+static int __init init_hpt37x(struct pci_dev *dev)
 {
 	int adjust, i;
 	u16 freq;
 	u32 pll;
 	byte reg5bh;
 
+#if 1
+	u8 reg5ah = 0;
+	pci_read_config_byte(dev, 0x5a, &reg5ah);
+	/* interrupt force enable */
+	pci_write_config_byte(dev, 0x5a, (reg5ah & ~0x10));
+#endif
+
 	/*
 	 * default to pci clock. make sure MA15/16 are set to output
 	 * to prevent drives having problems with 40-pin cables.
@@ -1027,18 +1375,41 @@
 	freq &= 0x1FF;
 	if (freq < 0x9c) {
 		pll = F_LOW_PCI_33;
-		dev->sysdata = (void *) thirty_three_base_hpt370;
-		printk("HPT370: using 33MHz PCI clock\n");
+		if (hpt_minimum_revision(dev,8))
+			pci_set_drvdata(dev, (void *) thirty_three_base_hpt374);
+		else if (hpt_minimum_revision(dev,5))
+			pci_set_drvdata(dev, (void *) thirty_three_base_hpt372);
+		else if (hpt_minimum_revision(dev,4))
+			pci_set_drvdata(dev, (void *) thirty_three_base_hpt370a);
+		else
+			pci_set_drvdata(dev, (void *) thirty_three_base_hpt370);
+		printk("HPT37X: using 33MHz PCI clock\n");
 	} else if (freq < 0xb0) {
 		pll = F_LOW_PCI_40;
 	} else if (freq < 0xc8) {
 		pll = F_LOW_PCI_50;
-		dev->sysdata = (void *) fifty_base_hpt370;
-		printk("HPT370: using 50MHz PCI clock\n");
+		if (hpt_minimum_revision(dev,8))
+			pci_set_drvdata(dev, (void *) NULL);
+		else if (hpt_minimum_revision(dev,5))
+			pci_set_drvdata(dev, (void *) fifty_base_hpt372);
+		else if (hpt_minimum_revision(dev,4))
+			pci_set_drvdata(dev, (void *) fifty_base_hpt370a);
+		else
+			pci_set_drvdata(dev, (void *) fifty_base_hpt370a);
+		
+		printk("HPT37X: using 50MHz PCI clock\n");
 	} else {
 		pll = F_LOW_PCI_66;
-		dev->sysdata = (void *) sixty_six_base_hpt370;
-		printk("HPT370: using 66MHz PCI clock\n");
+		if (hpt_minimum_revision(dev,8)){
+			printk(KERN_ERR "HPT37x: 66MHz timings are not supported.\n");
+			pci_set_drvdata(dev, (void *) NULL);
+		}else if (hpt_minimum_revision(dev,5))
+			pci_set_drvdata(dev, (void *) sixty_six_base_hpt372);
+		else if (hpt_minimum_revision(dev,4))
+			pci_set_drvdata(dev, (void *) sixty_six_base_hpt370a);
+		else
+			pci_set_drvdata(dev, (void *) sixty_six_base_hpt370);
+		printk("HPT37X: using 66MHz PCI clock\n");
 	}
 	
 	/*
@@ -1048,8 +1419,8 @@
 	 * don't like to use the PLL because it will cause glitches
 	 * on PRST/SRST when the HPT state engine gets reset.
 	 */
-	if (dev->sysdata) 
-		goto init_hpt370_done;
+	if (pci_get_drvdata(dev)) 
+		goto init_hpt37X_done;
 	
 	/*
 	 * adjust PLL based upon PCI clock, enable it, and wait for
@@ -1076,9 +1447,16 @@
 				pci_write_config_dword(dev, 0x5c, 
 						       pll & ~0x100);
 				pci_write_config_byte(dev, 0x5b, 0x21);
-				dev->sysdata = (void *) fifty_base_hpt370;
-				printk("HPT370: using 50MHz internal PLL\n");
-				goto init_hpt370_done;
+				if (hpt_minimum_revision(dev,8))
+					return -EOPNOTSUPP;
+				else if (hpt_minimum_revision(dev,5))
+					pci_set_drvdata(dev, (void *) fifty_base_hpt372);
+				else if (hpt_minimum_revision(dev,4))
+					pci_set_drvdata(dev, (void *) fifty_base_hpt370a);
+				else
+					pci_set_drvdata(dev, (void *) fifty_base_hpt370a);
+				printk("HPT37X: using 50MHz internal PLL\n");
+				goto init_hpt37X_done;
 			}
 		}
 pll_recal:
@@ -1088,15 +1466,52 @@
 			pll += (adjust >> 1);
 	} 
 
-init_hpt370_done:
+init_hpt37X_done:
 	/* reset state engine */
-	pci_write_config_byte(dev, 0x50, 0x37); 
+	pci_write_config_byte(dev, 0x50, 0x37);
 	pci_write_config_byte(dev, 0x54, 0x37); 
 	udelay(100);
+	return 0;
+}
+
+static int __init init_hpt366 (struct pci_dev *dev)
+{
+	u32 reg1	= 0;
+	u8 drive_fast	= 0;
+
+	/*
+	 * Disable the "fast interrupt" prediction.
+	 */
+	pci_read_config_byte(dev, 0x51, &drive_fast);
+	if (drive_fast & 0x80)
+		pci_write_config_byte(dev, 0x51, drive_fast & ~0x80);
+	pci_read_config_dword(dev, 0x40, &reg1);
+									
+	/* detect bus speed by looking at control reg timing: */
+	switch((reg1 >> 8) & 7) {
+		case 5:
+			pci_set_drvdata(dev, (void *) forty_base_hpt366);
+			break;
+		case 9:
+			pci_set_drvdata(dev, (void *) twenty_five_base_hpt366);
+			break;
+		case 7:
+		default:
+			pci_set_drvdata(dev, (void *) thirty_three_base_hpt366);
+			break;
+	}
+
+	if (pci_get_drvdata(dev))
+	{
+		printk(KERN_ERR "hpt366: unknown bus timing.\n");
+		pci_set_drvdata(dev, (void *) NULL);
+	}
+	return 0;
 }
 
 unsigned int __init pci_init_hpt366 (struct pci_dev *dev, const char *name)
 {
+	int ret = 0;
 	byte test = 0;
 
 	if (dev->resource[PCI_ROM_RESOURCE].start)
@@ -1118,12 +1533,15 @@
 	if (test != 0x08)
 		pci_write_config_byte(dev, PCI_MAX_LAT, 0x08);
 
-	if (pci_rev_check_hpt3xx(dev)) {
-		init_hpt370(dev);
-		hpt_devs[n_hpt_devs++] = dev;
+	if (hpt_minimum_revision(dev, 3)) {
+		ret = init_hpt37x(dev);
 	} else {
-		hpt_devs[n_hpt_devs++] = dev;
+		ret = init_hpt366(dev);
 	}
+
+	if (ret)
+		return ret;
+	hpt_devs[n_hpt_devs++] = dev;
 	
 #if defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS)
 	if (!hpt366_proc) {
@@ -1151,8 +1569,6 @@
 
 void __init ide_init_hpt366 (ide_hwif_t *hwif)
 {
-	int hpt_rev;
-
 	hwif->tuneproc	= &hpt3xx_tune_drive;
 	hwif->speedproc	= &hpt3xx_tune_chipset;
 	hwif->quirkproc	= &hpt3xx_quirkproc;
@@ -1165,25 +1581,29 @@
 		hwif->serialized = hwif->mate->serialized = 1;
 #endif
 
-	hpt_rev = pci_rev_check_hpt3xx(hwif->pci_dev);
-	if (hpt_rev) {
-		/* set up ioctl for power status. note: power affects both
-		 * drives on each channel */
-		hwif->busproc   = &hpt370_busproc;
-	}
-
-	if (pci_rev2_check_hpt3xx(hwif->pci_dev)) {
-		/* do nothing now but will split device types */
+	if (hpt_minimum_revision(hwif->pci_dev,3)) {
+		u8 reg5ah = 0;
+			pci_write_config_byte(hwif->pci_dev, 0x5a, reg5ah & ~0x10);
+		/*
+		 * set up ioctl for power status.
+		 * note: power affects both
+		 * drives on each channel
+		 */
+		hwif->resetproc	= &hpt3xx_reset;
+		hwif->busproc	= &hpt370_busproc;
+	} else if (hpt_minimum_revision(hwif->pci_dev,2)) {
+		hwif->resetproc	= &hpt3xx_reset;
+		hwif->busproc	= &hpt3xx_tristate;
+	} else {
 		hwif->resetproc = &hpt3xx_reset;
-/*
- * don't do until we can parse out the cobalt box argh ...
- *		hwif->busproc   = &hpt3xx_tristate;
- */
+		hwif->busproc   = &hpt3xx_tristate;
 	}
 
 #ifdef CONFIG_BLK_DEV_IDEDMA
 	if (hwif->dma_base) {
-		if (hpt_rev) {
+		if (hpt_minimum_revision(hwif->pci_dev,5)) {
+			hwif->dmaproc = &hpt37x_dmaproc;
+		}else if (hpt_minimum_revision(hwif->pci_dev,3)) {	/* xxx */
 			byte reg5ah = 0;
 			pci_read_config_byte(hwif->pci_dev, 0x5a, &reg5ah);
 			if (reg5ah & 0x10)	/* interrupt force enable */
@@ -1194,8 +1614,6 @@
 		}
 		if (!noautodma)
 			hwif->autodma = 1;
-		else
-			hwif->autodma = 0;
 	} else {
 		hwif->autodma = 0;
 		hwif->drives[0].autotune = 1;
@@ -1211,23 +1629,25 @@
 void __init ide_dmacapable_hpt366 (ide_hwif_t *hwif, unsigned long dmabase)
 {
 	byte masterdma = 0, slavedma = 0;
-	byte dma_new = 0, dma_old = inb(dmabase+2);
+	byte dma_m_new, dma_m_old = inb(dmabase+0x2);
+	byte dma_s_new, dma_s_old = inb(dmabase+0xa);
 	byte primary	= hwif->channel ? 0x4b : 0x43;
 	byte secondary	= hwif->channel ? 0x4f : 0x47;
 	unsigned long flags;
 
-	__save_flags(flags);	/* local CPU only */
-	__cli();		/* local CPU only */
+	local_irq_save(flags);
 
-	dma_new = dma_old;
+	dma_m_new = dma_m_old;
+	dma_s_new = dma_s_old;
 	pci_read_config_byte(hwif->pci_dev, primary, &masterdma);
 	pci_read_config_byte(hwif->pci_dev, secondary, &slavedma);
 
-	if (masterdma & 0x30)	dma_new |= 0x20;
-	if (slavedma & 0x30)	dma_new |= 0x40;
-	if (dma_new != dma_old) outb(dma_new, dmabase+2);
+	if (masterdma & 0x30)	dma_m_new |= 0x60;
+	if (slavedma & 0x30)	dma_s_new |= 0x40;
+	if (dma_m_new != dma_m_old) outb(dma_m_new, dmabase+0x2);
+	if (dma_s_new != dma_s_old) outb(dma_s_new, dmabase+0xa);
 
-	__restore_flags(flags);	/* local CPU only */
+	local_irq_restore(flags);
 
 	ide_setup_dma(hwif, dmabase, 8);
 }
diff -Naru linux-2.4.20.orig/drivers/ide/ide-disk.c linux-2.4.20/drivers/ide/ide-disk.c
--- linux-2.4.20.orig/drivers/ide/ide-disk.c	2002-12-11 11:37:57.000000000 +0900
+++ linux-2.4.20/drivers/ide/ide-disk.c	2004-12-21 12:27:04.000000000 +0900
@@ -30,6 +30,9 @@
  * Version 1.11		added 48-bit lba
  * Version 1.12		adding taskfile io access method
  *			Highmem I/O support, Jens Axboe <axboe@suse.de>
+ *
+ * PlatHome <openlab.plathome.co.jp>
+ *	- Added LED Display for OpenBlockS 266
  */
 
 #define IDEDISK_VERSION	"1.12"
@@ -1424,6 +1427,10 @@
 	drive->no_io_32bit = id->dword_io ? 1 : 0;
 	if (drive->id->cfs_enable_2 & 0x3000)
 		write_cache(drive, (id->cfs_enable_2 & 0x3000));
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	extern int obsled_out(int);
+	obsled_out(4);
+#endif
 	(void) probe_lba_addressing(drive, 1);
 }
 
diff -Naru linux-2.4.20.orig/drivers/ide/ide-m8xx.c linux-2.4.20/drivers/ide/ide-m8xx.c
--- linux-2.4.20.orig/drivers/ide/ide-m8xx.c	2002-12-11 11:40:01.000000000 +0900
+++ linux-2.4.20/drivers/ide/ide-m8xx.c	2004-12-21 14:13:37.000000000 +0900
@@ -9,6 +9,9 @@
  *	by Steven.Scholz@imc-berlin.de
  *  Moved out of arch/ppc/kernel/m8xx_setup.c, other minor cleanups
  *	by Mathew Locke <mattl@mvista.com>
+ *
+ *	PlatHome <openlab@plathome.co.jp>
+ *		- Added for OpenBlockS 50
  */
 
 #include <linux/config.h>
@@ -31,6 +34,9 @@
 #include <linux/ioport.h>
 #include <linux/ide.h>
 #include <linux/bootmem.h>
+#ifdef CONFIG_OBS50
+#include <linux/delay.h>
+#endif
 
 #include <asm/mpc8xx.h>
 #include <asm/mmu.h>
@@ -44,13 +50,20 @@
 #include <asm/irq.h>
 
 #include "ide_modes.h"
+#ifndef CONFIG_OBS50
 static int identify  (volatile unsigned char *p);
 static void print_fixed (volatile unsigned char *p);
 static void print_funcid (int func);
 static int check_ide_device (unsigned long base);
+#endif
 
+#ifdef CONFIG_OBS50
+void ide_interrupt_ack (void *dev);
+void m8xx_ide_tuneproc(ide_drive_t *drive, u8 pio);
+#else
 static void ide_interrupt_ack (void *dev);
 static void m8xx_ide_tuneproc(ide_drive_t *drive, byte pio);
+#endif
 
 typedef	struct ide_ioport_desc {
 	unsigned long	base_off;		/* Offset to PCMCIA memory	*/
@@ -102,7 +115,9 @@
  * Warning: only 1 (ONE) PCMCIA slot supported here,
  * which must be correctly initialized by the firmware (PPCBoot).
  */
+#ifndef CONFIG_OBS50
 static int _slot_ = -1;			/* will be read from PCMCIA registers   */
+#endif
 
 /* Make clock cycles and always round up */
 #define PCMCIA_MK_CLKS( t, T ) (( (t) * ((T)/1000000) + 999U ) / 1000U )
@@ -351,8 +366,12 @@
 	ide_ioreg_t *p = hw->io_ports;
 	int i;
 
+#ifndef CONFIG_OBS50
 	u32 ide_phy_base;
 	u32 ide_phy_end;
+#else
+	static unsigned long ide_sub_base = 0;
+#endif
 	static unsigned long ide_base = 0;
 	unsigned long base;
 
@@ -360,8 +379,72 @@
 	if (irq)
 		*irq = 0;
 
+#ifdef CONFIG_OBS50
+/* version information */
+#define OBSIDE_VERSION_INFO "IDE driver for OBS Version 1.2.0"
+#define OBS_IDE_RESET	(0x0008)	/* in Port C bit3 */
+
+	printk(KERN_INFO OBSIDE_VERSION_INFO "\n");
+
 	if (!ide_base) {
 
+		/* reset-pin setup */
+		((immap_t *)IMAP_ADDR)->im_ioport.iop_pcpar &= ~OBS_IDE_RESET;
+		((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdir |=  OBS_IDE_RESET;
+		((immap_t *)IMAP_ADDR)->im_ioport.iop_pcso  &= ~OBS_IDE_RESET;
+
+		/* IDE RESET off, on, wait, off */
+		((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat |=  OBS_IDE_RESET;
+		((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat &= ~OBS_IDE_RESET;
+		udelay(100);
+		((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat |=  OBS_IDE_RESET;
+		udelay(10);
+
+		/* IDE wake up */
+		for (i = 0; i < 1000; i++) {
+			/* FIXME: WDT clear in here */
+			udelay(100);
+		}
+
+		/* io area mapping */
+		ide_base = (unsigned long)
+			ioremap(CFG_ATA_BASE_ADDR, CFG_ATA_SIZE);
+		ide_sub_base = (unsigned long)
+			ioremap(CFG_ATA_SUB_BASE_ADDR, CFG_ATA_SUB_SIZE);
+	}
+
+	if (data_port >= MAX_HWIFS)
+		return;
+	
+	base = ide_base;
+	
+	for (i = 0; i < IDE_NR_PORTS - 1; ++i) {
+		if (i == IDE_CONTROL_OFFSET) {
+			base = ide_sub_base;
+		}
+#ifdef DEBUG
+		printk ("IDE port[%d]: %08lx + %08x = %08lx\n",
+			i,
+			base,
+			ioport_dsc[data_port].reg_off[i],
+			base + ioport_dsc[data_port].reg_off[i]);
+#endif
+		*p++ = base + ioport_dsc[data_port].reg_off[i];
+	}
+
+	/* 0x1e:status[BSY] check */
+	for (i = 0; i < 10000; i++) {
+		udelay(400);
+		if ((*((volatile ushort *)hw->io_ports[IDE_STATUS_OFFSET])
+			& 0x0080) == 0) {
+				break;
+		}
+	}
+
+	printk ("IDE init %s\n", (i >= 10000) ? "timeout" : "done");
+#else /* ! CONFIG_OBS50 */
+
+	if (!ide_base) {
 		/* TODO:
 		 * - add code to read ORx, BRx
 		 */
@@ -399,6 +482,7 @@
 #endif
 	 	*p++ = base + ioport_dsc[data_port].reg_off[i];
 	}
+#endif /* CONFIG_OBS50 */
 
 	if (irq) {
 		/* direct connected IDE drive, i.e. external IRQ */
@@ -432,7 +516,11 @@
 
 
 /* Calculate PIO timings */
+#ifdef CONFIG_OBS50
+void
+#else
 static void
+#endif
 m8xx_ide_tuneproc(ide_drive_t *drive, byte pio)
 {
 	ide_pio_data_t d;
@@ -492,7 +580,11 @@
 #endif /* defined(CONFIG_IDE_8xx_PCCARD) || defined(CONFIG_IDE_8xx_PCMCIA */
 }
 
+#ifdef CONFIG_OBS50
+void
+#else
 static void
+#endif
 ide_interrupt_ack (void *dev)
 {
 #ifdef CONFIG_IDE_8xx_PCCARD
@@ -535,7 +627,7 @@
 #endif /* CONFIG_IDE_8xx_PCCARD */
 }
 
-
+#ifndef CONFIG_OBS50
 
 /*
  * CIS Tupel codes
@@ -849,9 +941,32 @@
 	return (0);	/* don't know */
 }
 
+#endif /* CONFIG_OBS50 */
+
 void m8xx_ide_init(void)
 {
 	ppc_ide_md.default_irq          = m8xx_ide_default_irq;
 	ppc_ide_md.default_io_base      = m8xx_ide_default_io_base;
 	ppc_ide_md.ide_init_hwif        = m8xx_ide_init_hwif_ports;
 }
+
+#ifdef CONFIG_OBS50
+
+/* special function for IDE interface */
+void OUT_BYTE(unsigned char dat, ide_ioreg_t port)
+{
+	unsigned short sdat;
+
+	sdat = dat;
+	_outsw_ns((u16 *)port, &sdat, 1);
+}
+
+unsigned char IN_BYTE(ide_ioreg_t port)
+{
+	unsigned short s;
+
+	_insw_ns((u16 *)port, &s, 1);
+	return s;
+}
+
+#endif /* CONFIG_OBS50 */
diff -Naru linux-2.4.20.orig/drivers/ide/ide-pci.c linux-2.4.20/drivers/ide/ide-pci.c
--- linux-2.4.20.orig/drivers/ide/ide-pci.c	2002-12-11 11:38:03.000000000 +0900
+++ linux-2.4.20/drivers/ide/ide-pci.c	2004-12-21 12:27:04.000000000 +0900
@@ -5,6 +5,9 @@
  *
  *  Copyright (c) 1995-1998  Mark Lord
  *  May be copied or modified under the terms of the GNU General Public License
+ *
+ *  PlatHome <openlab.plathome.co.jp>
+ *	- Added DEVID_HPT371 for OpenBlockS 266
  */
 
 /*
@@ -81,6 +84,7 @@
 #define DEVID_UM8886BF	((ide_pci_devid_t){PCI_VENDOR_ID_UMC,     PCI_DEVICE_ID_UMC_UM8886BF})
 #define DEVID_HPT34X	((ide_pci_devid_t){PCI_VENDOR_ID_TTI,     PCI_DEVICE_ID_TTI_HPT343})
 #define DEVID_HPT366	((ide_pci_devid_t){PCI_VENDOR_ID_TTI,     PCI_DEVICE_ID_TTI_HPT366})
+#define DEVID_HPT371	((ide_pci_devid_t){PCI_VENDOR_ID_TTI,     0x0007})
 #define DEVID_ALI15X3	((ide_pci_devid_t){PCI_VENDOR_ID_AL,      PCI_DEVICE_ID_AL_M5229})
 #define DEVID_CY82C693	((ide_pci_devid_t){PCI_VENDOR_ID_CONTAQ,  PCI_DEVICE_ID_CONTAQ_82C693})
 #define DEVID_HINT	((ide_pci_devid_t){0x3388,                0x8013})
@@ -454,6 +458,7 @@
 	{DEVID_UM8886BF,"UM8886BF",	NULL,		NULL,		NULL,		NULL,		{{0x00,0x00,0x00}, {0x00,0x00,0x00}}, 	ON_BOARD,	0 },
 	{DEVID_HPT34X,	"HPT34X",	PCI_HPT34X,	NULL,		INIT_HPT34X,	NULL,		{{0x00,0x00,0x00}, {0x00,0x00,0x00}},	NEVER_BOARD,	16 },
 	{DEVID_HPT366,	"HPT366",	PCI_HPT366,	ATA66_HPT366,	INIT_HPT366,	DMA_HPT366,	{{0x00,0x00,0x00}, {0x00,0x00,0x00}},	OFF_BOARD,	240 },
+	{DEVID_HPT371,	"HPT371",	PCI_HPT366,	ATA66_HPT366,	INIT_HPT366,	DMA_HPT366,	{{0x00,0x00,0x00}, {0x00,0x00,0x00}},	ON_BOARD,	0 },
 	{DEVID_ALI15X3,	"ALI15X3",	PCI_ALI15X3,	ATA66_ALI15X3,	INIT_ALI15X3,	DMA_ALI15X3,	{{0x00,0x00,0x00}, {0x00,0x00,0x00}},	ON_BOARD,	0 },
 	{DEVID_CY82C693,"CY82C693",	PCI_CY82C693,	NULL,		INIT_CY82C693,	NULL,		{{0x00,0x00,0x00}, {0x00,0x00,0x00}},	ON_BOARD,	0 },
 	{DEVID_HINT,	"HINT_IDE",	NULL,		NULL,		NULL,		NULL,		{{0x00,0x00,0x00}, {0x00,0x00,0x00}},	ON_BOARD,	0 },
@@ -748,6 +753,8 @@
 controller_ok:			
 		if (IDE_PCI_DEVID_EQ(d->devid, DEVID_HPT366) && (port) && (class_rev < 0x03))
 			return;
+		if (IDE_PCI_DEVID_EQ(d->devid, DEVID_HPT371) && (port == 0))
+			continue;
 		if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE || (dev->class & (port ? 4 : 1)) != 0) {
 			ctl  = dev->resource[(2*port)+1].start;
 			base = dev->resource[2*port].start;
@@ -832,6 +839,7 @@
 		    IDE_PCI_DEVID_EQ(d->devid, DEVID_AEC6280R) ||
 		    IDE_PCI_DEVID_EQ(d->devid, DEVID_HPT34X) ||
 		    IDE_PCI_DEVID_EQ(d->devid, DEVID_HPT366) ||
+		    IDE_PCI_DEVID_EQ(d->devid, DEVID_HPT371) ||
 		    IDE_PCI_DEVID_EQ(d->devid, DEVID_CS5530) ||
 		    IDE_PCI_DEVID_EQ(d->devid, DEVID_CY82C693) ||
 		    IDE_PCI_DEVID_EQ(d->devid, DEVID_CMD646) ||
diff -Naru linux-2.4.20.orig/drivers/ide/ide-probe.c linux-2.4.20/drivers/ide/ide-probe.c
--- linux-2.4.20.orig/drivers/ide/ide-probe.c	2002-12-11 11:37:04.000000000 +0900
+++ linux-2.4.20/drivers/ide/ide-probe.c	2004-12-21 12:27:04.000000000 +0900
@@ -27,6 +27,13 @@
  * Version 1.06		stream line request queue and prep for cascade project.
  * Version 1.07		max_sect <= 255; slower disks would get behind and
  * 			then fall over when they get to 256.	Paul G.
+ * 
+ *	Century <www.centurysys.co.jp>
+ *		- Added LED display
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added CONFIG_OBS200
+ *		- just fixed around CONFIG_IDEPCI_SHARE_IRQ
+ * 
  */
 
 #undef REALLY_SLOW_IO		/* most systems can safely undef this */
@@ -51,6 +58,10 @@
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
+#ifdef CONFIG_OBS200
+#include <asm/segled_obs200.h>
+#define OPNT ((volatile unsigned char *)(0x40000000))
+#endif
 
 static inline void do_identify (ide_drive_t *drive, byte cmd)
 {
@@ -232,7 +243,11 @@
 	} else
 #endif /* CONFIG_BLK_DEV_PDC4030 */
 		OUT_BYTE(cmd,IDE_COMMAND_REG);		/* ask drive for ID */
+#ifdef CONFIG_OBS200
+	timeout = ((cmd == WIN_IDENTIFY) ? (WAIT_WORSTCASE/10) : (WAIT_PIDENTIFY/10)) / 2;
+#else
 	timeout = ((cmd == WIN_IDENTIFY) ? WAIT_WORSTCASE : WAIT_PIDENTIFY) / 2;
+#endif
 	timeout += jiffies;
 	do {
 		if (0 < (signed long)(jiffies - timeout)) {
@@ -261,7 +276,9 @@
 	int autoprobe = 0;
 	unsigned long cookie = 0;
 	ide_hwif_t *hwif = HWIF(drive);
+#ifdef CONFIG_IDEPCI_SHARE_IRQ
 	int irqdefense = 0;
+#endif
 
 	if (IDE_CONTROL_REG && !hwif->irq) {
 		autoprobe = 1;
@@ -275,7 +292,7 @@
 		disable_irq(hwif->irq);
 		irqdefense = 1;
 	}
-#endif CONFIG_IDEPCI_SHARE_IRQ
+#endif /* CONFIG_IDEPCI_SHARE_IRQ */
 
 	retval = actual_try_to_identify(drive, cmd);
 
@@ -305,7 +322,7 @@
 #ifdef CONFIG_IDEPCI_SHARE_IRQ
 	if (irqdefense)
 		enable_irq(hwif->irq);
-#endif CONFIG_IDEPCI_SHARE_IRQ
+#endif /* CONFIG_IDEPCI_SHARE_IRQ */
 
 	return retval;
 }
@@ -379,6 +396,9 @@
 		ide_delay_50ms();
 		(void) GET_STAT();		/* ensure drive irq is clear */
 	}
+#ifdef CONFIG_OBS200
+	*OPNT = (unsigned char)~(SL_V3);
+#endif
 	return rc;
 }
 
diff -Naru linux-2.4.20.orig/drivers/mtd/maps/Config.in linux-2.4.20/drivers/mtd/maps/Config.in
--- linux-2.4.20.orig/drivers/mtd/maps/Config.in	2002-12-11 11:39:44.000000000 +0900
+++ linux-2.4.20/drivers/mtd/maps/Config.in	2004-12-21 12:27:04.000000000 +0900
@@ -51,8 +51,16 @@
    if [ "$CONFIG_MBX" = "y" ]; then
       dep_tristate '  System flash on MBX860 board' CONFIG_MTD_MBX860 $CONFIG_MTD_CFI
    fi
-   if [ "$CONFIG_REDWOOD_4" = "y" -o "$CONFIG_REDWOOD_5" = "y" -o "$CONFIG_REDWOOD_6" = "y" ]; then
+   if [ "$CONFIG_REDWOOD_4" = "y" -o "$CONFIG_REDWOOD_5" = "y" -o "$CONFIG_REDWOOD_6" = "y" -o "$CONFIG_OBS266" ]; then
       dep_tristate '  CFI Flash device mapped on IBM Redwood' CONFIG_MTD_REDWOOD $CONFIG_MTD_CFI
+#      if [ "$CONFIG_MTD_REDWOOD" = "y" ]; then
+#        if [ "$CONFIG_OBS266" = "y" ]; then
+#         bool 'Reserve flash for user' CONFIG_MTD_OBSUSER $CONFIG_MTD_OBSUSER
+#           if [ "$CONFIG_MTD_OBSUSER" = "y" ]; then
+#              int 'Max compressed kernel size' CONFIG_OBS_MAXKERNSIZE $CONFIG_OBS_MAXKERNSIZE
+#           fi
+#        fi
+#       fi
    fi
    if [ "$CONFIG_BEECH" = "y" ]; then
       dep_tristate '  CFI Flash device mapped on IBM Beech' CONFIG_MTD_BEECH $CONFIG_MTD_CFI
diff -Naru linux-2.4.20.orig/drivers/mtd/maps/redwood.c linux-2.4.20/drivers/mtd/maps/redwood.c
--- linux-2.4.20.orig/drivers/mtd/maps/redwood.c	2002-12-11 11:39:51.000000000 +0900
+++ linux-2.4.20/drivers/mtd/maps/redwood.c	2004-12-21 12:27:04.000000000 +0900
@@ -31,6 +31,9 @@
  *  		: 07/11/02 - Armin
  *  		added redwood 6 support
  *
+ *		PlatHome <openlab.plathome.co.jp>
+ *			- Added for OpenBlockS 266
+ *
  */
 
 #include <linux/config.h>
@@ -47,7 +50,7 @@
 #define STBXX_OB_SZ	0x20000
 #define STBXX_4MB	0x4000000
 
-#if !defined (CONFIG_REDWOOD_6)
+#if !defined (CONFIG_REDWOOD_6) && !defined(CONFIG_OBS266)
 #define WINDOW_ADDR 0xffc00000
 #define WINDOW_SIZE 0x00400000
 
@@ -97,6 +100,7 @@
 #define WINDOW_ADDR 0xff800000
 #define WINDOW_SIZE 0x00800000
 
+#ifdef CONFIG_REDWOOD_6
 #define RW_PART0_OF	0
 #define RW_PART0_SZ	0x400000	/* 4 MB data */
 #define RW_PART1_OF	RW_PART0_OF + RW_PART0_SZ 	
@@ -129,48 +133,102 @@
 		mask_flags: MTD_WRITEABLE	/* force read-only */
 	}
 };
-
+#else
+#define RW_CONF_OF     0
+#define RW_CONF_SZ     0x10000          /*64Kb Variable data*/
+#define RW_BIOS_OF	0x7c0000         /* BIOS area */
+#define RW_BIOS_SZ	0x40000
+#define RW_KERN_OF	(RW_CONF_OF)+(RW_CONF_SZ)
+#if defined(CONFIG_OBS_MAXKERNSIZE) && (CONFIG_OBS_MAXKERNSIZE != 0)
+#define RW_KERN_SZ     CONFIG_OBS_MAXKERNSIZE
+#else
+#define RW_KERN_SZ     (RW_BIOS_OF) - (RW_KERN_OF)
+#endif
+#define RW_USER_OF     (RW_KERN_OF) + (RW_KERN_SZ)
+#define RW_USER_SZ     (RW_BIOS_OF) - (RW_USER_OF)
+static struct mtd_partition redwood_flash_partitions[] = {
+	{
+		name: "OpenBlockS Configuration Data",
+		offset: RW_CONF_OF,
+		size: RW_CONF_SZ
+	},
+	{
+		name: "OpenBlockS Boot Image",
+		offset: RW_KERN_OF,
+		size: RW_KERN_SZ
+	},
+	{
+		name: "OpenBlockS OpenBIOS",
+		offset: RW_BIOS_OF,
+		size: RW_BIOS_SZ,
+		mask_flags: MTD_WRITEABLE	/* force read-only */
+	},
+	{
+		name: "OpenBlockS All Flash",
+		offset: RW_CONF_OF,
+		size: RW_BIOS_OF + RW_BIOS_SZ,
+		mask_flags: MTD_WRITEABLE       /* force read-only */
+	},
+#if  (RW_USER_SZ > 0)
+	{
+		name: "OpenBlockS User Flash",
+		offset: RW_USER_OF,
+		size: RW_USER_SZ,
+	}
+#elif (RW_USER_SZ < 0)
+#error  "Kernel Size Invalid"
+#endif	
+};
+#endif
 #endif
 
 __u8 redwood_flash_read8(struct map_info *map, unsigned long ofs)
 {
+  iobarrier_rw();
 	return *(__u8 *)(map->map_priv_1 + ofs);
 }
 
 __u16 redwood_flash_read16(struct map_info *map, unsigned long ofs)
 {
+  iobarrier_rw();
 	return *(__u16 *)(map->map_priv_1 + ofs);
 }
 
 __u32 redwood_flash_read32(struct map_info *map, unsigned long ofs)
 {
+  iobarrier_rw();
 	return *(volatile unsigned int *)(map->map_priv_1 + ofs);
 }
 
 void redwood_flash_copy_from(struct map_info *map, void *to,
 		unsigned long from, ssize_t len)
 {
+  iobarrier_rw();
 	memcpy(to, (void *)(map->map_priv_1 + from), len);
 }
 
 void redwood_flash_write8(struct map_info *map, __u8 d, unsigned long adr)
 {
+  iobarrier_rw();
 	*(__u8 *)(map->map_priv_1 + adr) = d;
 }
 
 void redwood_flash_write16(struct map_info *map, __u16 d, unsigned long adr)
 {
+  iobarrier_rw();
 	*(__u16 *)(map->map_priv_1 + adr) = d;
 }
 
 void redwood_flash_write32(struct map_info *map, __u32 d, unsigned long adr)
 {
+  iobarrier_rw();
 	*(__u32 *)(map->map_priv_1 + adr) = d;
 }
 
 void redwood_flash_copy_to(struct map_info *map, unsigned long to,
 		const void *from, ssize_t len)
 {
+  iobarrier_rw();
 	memcpy((void *)(map->map_priv_1 + to), from, len);
 }
 
diff -Naru linux-2.4.20.orig/drivers/net/8139too.c linux-2.4.20/drivers/net/8139too.c
--- linux-2.4.20.orig/drivers/net/8139too.c	2002-12-11 11:40:25.000000000 +0900
+++ linux-2.4.20/drivers/net/8139too.c	2004-12-21 12:27:04.000000000 +0900
@@ -89,6 +89,10 @@
 
 		See 8139too.txt for more details.
 
+	PlatHome <openlab.plathome.co.jp>
+		- Added __BIG_ENDIAN
+
+
 */
 
 #define DRV_NAME	"8139too"
@@ -2513,7 +2517,11 @@
 		     i++, mclist = mclist->next) {
 			int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
 
+#ifdef __BIG_ENDIAN
 			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+#else
+			mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
+#endif
 			rx_mode |= AcceptMulticast;
 		}
 	}
diff -Naru linux-2.4.20.orig/drivers/net/Makefile linux-2.4.20/drivers/net/Makefile
--- linux-2.4.20.orig/drivers/net/Makefile	2002-12-11 11:38:36.000000000 +0900
+++ linux-2.4.20/drivers/net/Makefile	2004-12-21 12:27:04.000000000 +0900
@@ -21,14 +21,14 @@
 list-multi	:=	rcpci.o
 rcpci-objs	:=	rcpci45.o rclanmtl.o
 
-ifeq ($(CONFIG_TULIP),y)
-  obj-y += tulip/tulip.o
-endif
-
 ifeq ($(CONFIG_OCP_NET),y)
   obj-y += ibm_ocp/ocp.o
 endif
 
+ifeq ($(CONFIG_TULIP),y)
+  obj-y += tulip/tulip.o
+endif
+
 ifeq ($(CONFIG_E1000),y)
   obj-y += e1000/e1000.o
 endif
diff -Naru linux-2.4.20.orig/drivers/net/e100/e100_main.c linux-2.4.20/drivers/net/e100/e100_main.c
--- linux-2.4.20.orig/drivers/net/e100/e100_main.c	2002-12-11 11:39:48.000000000 +0900
+++ linux-2.4.20/drivers/net/e100/e100_main.c	2004-12-21 12:27:04.000000000 +0900
@@ -1218,6 +1218,9 @@
 	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
 	case SIOCGMIIREG:	/* Read MII PHY register. */
 	case SIOCSMIIREG:	/* Write to MII PHY register. */
+	case SIOCDEVPRIVATE:
+	case SIOCDEVPRIVATE + 1:
+	case SIOCDEVPRIVATE + 2:
 		return e100_mii_ioctl(dev, ifr, cmd);
 		break;
 
@@ -3888,10 +3891,12 @@
 
 	switch (cmd) {
 	case SIOCGMIIPHY:
+	case SIOCDEVPRIVATE:
 		data_ptr->phy_id = bdp->phy_addr & 0x1f;
-		break;
+/*		break;	*/
 
 	case SIOCGMIIREG:
+	case SIOCDEVPRIVATE + 1:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 		e100_mdi_read(bdp, data_ptr->reg_num & 0x1f, bdp->phy_addr,
@@ -3899,6 +3904,7 @@
 		break;
 
 	case SIOCSMIIREG:
+	case SIOCDEVPRIVATE + 2:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 		if (netif_running(dev)) {
diff -Naru linux-2.4.20.orig/drivers/net/ibm_ocp/ibm_ocp_enet.c linux-2.4.20/drivers/net/ibm_ocp/ibm_ocp_enet.c
--- linux-2.4.20.orig/drivers/net/ibm_ocp/ibm_ocp_enet.c	2002-12-11 11:37:38.000000000 +0900
+++ linux-2.4.20/drivers/net/ibm_ocp/ibm_ocp_enet.c	2004-12-21 12:27:04.000000000 +0900
@@ -178,6 +178,14 @@
  *         any BD, ppc405_rx_fill() gets called anyway with i == fep->rx_slot. It will 
  *         corrupt the current BD (fep->rx_slot) and NUM_RX_BUFF packets will be lost 
  *
+ *	Century <www.centurysys.co.jp>
+ *		- Added re-link
+ *		- Added re-start
+ *		- Added Century's PHY
+ *	2002-01-03 ozawa CONFIG_OBSS
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -205,6 +213,7 @@
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <linux/crc32.h>
+#include <linux/mii.h>
 
 #include "ocp_zmii.h"
 #include "ibm_ocp_enet.h"
@@ -228,6 +237,10 @@
 static void ppc405_rx_fill(struct net_device *, int);
 static void ppc405_rx_clean(struct net_device *, int);
 
+#ifdef CONFIG_OBS200
+static void phy_link(int, void *, struct pt_regs *);
+#endif
+
 int ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value);
 int ocp_enet_mdio_write(struct net_device *dev, int reg);
 int ocp_enet_ioctl(struct net_device *, struct ifreq *rq, int cmd);
@@ -242,6 +255,17 @@
 
 int emac_max;
 
+/* create a link list of EMAC devices so a single Interrupt can be shared
+ * across all the EMACs
+ */
+typedef struct dev_list{
+        struct net_device *dev;
+        struct dev_list *next;
+} dev_list_t;
+
+ dev_list_t * emac_dev_list = NULL;
+ dev_list_t * cur_dev_list; /* end of the list */
+
 static int skb_res = SKB_RES;
 MODULE_PARM(skb_res, "i");
 MODULE_PARM_DESC(skb_res, "Amount of data to reserve on skb buffs\n"
@@ -383,6 +407,10 @@
 
 	/* set transmit and receive enable */
 	out_be32(&emacp->em0mr0, EMAC_M0_TXE | EMAC_M0_RXE);
+#ifdef CONFIG_OBS200
+	request_irq(OBSS_ETH_RELINK_IRQ, &phy_link, 0, "405eth Re-link", dev);
+	ocp_enet_mdio_write(dev, mk_mii_write(PHY_MIPSCR, 0x0500));
+#endif
 	netif_start_queue(dev);
 	printk(KERN_NOTICE "%s: IBM EMAC: open completed\n\n", dev->name);
 
@@ -468,7 +496,9 @@
 		free_irq(BL_MAL_RXEOB,dev);
 	}
 
-
+#ifdef CONFIG_OBS200
+	free_irq(OBSS_ETH_RELINK_IRQ, dev);
+#endif
 	free_phy(dev);
 	return 0;
 }
@@ -552,12 +582,37 @@
 	struct ocp_enet_private *ep;
 	struct ocp_dev *emac_driver;
 
+        dev_list_t *new_dev_list;
+	
 	dev = init_etherdev(NULL, sizeof (struct ocp_enet_private));
 	if (dev == NULL) {
 		printk(KERN_ERR
 		       "ibm_ocp_enet: Could not allocate ethernet device.\n");
 		return -1;
 	}
+
+        /* create devlist instance */
+        new_dev_list = (dev_list_t *)kmalloc(sizeof(struct dev_list),
+                        GFP_ATOMIC);
+        if(new_dev_list == NULL)
+        {
+                printk(KERN_ERR "IBM_OCP_ENET: dev_list alloc failed \n");
+                return -1;
+        }
+        new_dev_list->next = NULL;
+        new_dev_list->dev = dev;
+        if (emac_dev_list == NULL)
+        {
+                emac_dev_list = new_dev_list;
+                cur_dev_list = new_dev_list;
+	}
+        else
+        {
+                cur_dev_list->next = new_dev_list;
+                cur_dev_list = new_dev_list;
+	}
+
+	
 	ep = dev->priv;
 	ep->emac_num = curr_emac;
 	ep->mal = DCRN_MAL_BASE;
@@ -669,6 +724,17 @@
 	struct ocp_enet_private *fep = dev->priv;
 	volatile emac_t *emacp = fep->emacp;
 
+#ifdef CONFIG_405EP
+        struct ocp_enet_private *fep0;
+
+        /*
+         * On 405 EP only EMAC0 has an MDIO interface.
+         * For this chip always force emacp to EMAC0 (1st dev in list).
+         */
+        fep0 = emac_dev_list->dev->priv;
+        emacp = fep0->emacp;
+#endif
+
 	/* Wait for data transfer complete bit */
 	enable_zmii_port(dev);
 	for (i = 0; i < OCP_RESET_DELAY; ++i) {
@@ -793,9 +859,12 @@
 {
 	struct ocp_enet_private *fep = dev->priv;
 	uint *data = (uint *) & rq->ifr_data;
+	struct mii_ioctl_data *odata = (struct mii_ioctl_data *) & rq->ifr_data;
+	uint wdata[4];
 
 	switch (cmd) {
 
+#if 0
 	case SIOCDEVPRIVATE:
 		data[0] = fep->phy_addr;
 	 /*FALLTHRU*/ case SIOCDEVPRIVATE + 1:
@@ -813,7 +882,32 @@
 			return -EIO;
 
 		return 0;
+#else
+	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
+	case SIOCDEVPRIVATE:
+		odata->phy_id = (u16) fep->phy_addr;
+	 /*FALLTHRU*/ case SIOCGMIIREG:		/* Read MII PHY register. */
+	 /*FALLTHRU*/ case SIOCDEVPRIVATE + 1:
+		wdata[1] = (uint) odata->reg_num;
+		if (ocp_enet_mdio_read(dev, mk_mii_read(wdata[1]), &wdata[3]) < 0)
+			return -EIO;
+		odata->val_out = (u16) wdata[3];
+		return 0;
+
+	case SIOCSMIIREG:		/* Write MII PHY register. */
+	case SIOCDEVPRIVATE + 2:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		wdata[1] = (uint) odata->reg_num;
+		wdata[2] = (uint) odata->val_in;
+
+		if (ocp_enet_mdio_write(dev, mk_mii_write(wdata[1], wdata[2])) <
+		    0)
+			return -EIO;
 
+		return 0;
+#endif
 	default:
 		return -EOPNOTSUPP;
 	}
@@ -1094,6 +1188,7 @@
 ppc405_eth_rxde(int irq, void *dev_instance, struct pt_regs *regs)
 {
 	int i, isr;
+	int reenable_rxchans = 0;
  	struct net_device *dev = dev_instance;
        	struct ocp_enet_private *fep = dev->priv;
 
@@ -1120,7 +1215,7 @@
 
 	disable_irq(BL_MAL_RXEOB);
 	for (i = 0; i < emac_max; i++) {
-		isr = get_mal_dcrn(fep, DCRN_MALRXEOBISR);
+		isr = get_mal_dcrn(fep, DCRN_MALRXDEIR);
 		if (isr & 0x80000000 >> i) {
 			dev = emac_dev[i];
 			fep = dev->priv;
@@ -1136,8 +1231,7 @@
 
 			fep->rx_slot = 0;
 			ppc405_rx_fill(dev, 0);
-
-			set_mal_dcrn(fep, DCRN_MALRXEOBISR, 0x80000000 >> i);
+			reenable_rxchans |= fep->rxchan;
 		}
 	}
 
@@ -1147,7 +1241,8 @@
 	enable_irq(BL_MAL_RXEOB);
 
 	/* Reenable the receive channels */
-	set_mal_dcrn(fep, DCRN_MALRXCASR, get_mal_dcrn(fep, DCRN_MALRXCASR));
+	set_mal_dcrn(fep, DCRN_MALRXCASR, 
+		     get_mal_dcrn(fep, DCRN_MALRXCASR) | reenable_rxchans);
 }
 
 static void
@@ -1226,3 +1321,86 @@
 
 module_init(init_ppc405_enet);
 module_exit(exit_ppc405_enet);
+
+#ifdef CONFIG_OBS200
+/* INT 31 handler. wakes up while link status change or auto-negotiation comp */
+static void
+phy_link(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	uint interrupt, data;
+	unsigned long mode_reg;
+	struct net_device *dev;
+	struct ocp_enet_private *fep;
+	volatile emac_t *emacp;
+
+	emacp = (emac_t *)EMAC0_BASE;
+	dev     = (struct net_device *)dev_instance;
+	fep  = dev->priv;
+
+	printk("[phy_link] interrupt phy link %d\n", irq);
+	/* Read relevant registers from MII */
+	if (ocp_enet_mdio_read(dev, mk_mii_read(PHY_MIPSCR), &interrupt) < 0) {
+	  printk("[phy_link] ocp_enet_mdio_read(mk_mii_read(PHY_MIPSCR)) failed\n");
+	  return;
+	  }
+	printk("[phy_link] interrupt %04x\n", interrupt);
+	if (interrupt & 0x0004)
+	{
+		/* Link interrupt */
+		ocp_enet_mdio_read(dev, mk_mii_read(PHY_BMS), &data);
+		if (data & 0x0004)
+		{
+			printk("[phy_link] Link UP\n");
+		}
+		else
+		{
+			printk("[phy_link] Link DOWN\n");
+		}
+	}
+	if (interrupt & 0x0001)
+	{
+		/* ANE interrupt - ANE completed */
+		printk("[phy_link] ANE completed - reinitialize mode register\n");
+		fep->phy_speed = _10BASET;
+		fep->phy_duplex = HALF;
+		ocp_enet_mdio_read(dev, mk_mii_read(PHY_BMS), &data);
+		if (data & 0x0020)
+		{
+			/* Auto negotiation is completed - read the values of speed and duplex */
+			ocp_enet_mdio_read(dev, mk_mii_read(PHY_MIPGSR), &data);
+			if (data & 0x0800)
+				fep->phy_duplex = FULL;
+			if (data & 0x0400)
+				fep->phy_speed = _100BASET;
+ 		}
+
+		/* Read the mode register */
+		mode_reg = emacp->em0mr1;
+		/* Reinitialze the mode register */
+		if (fep->phy_speed == _100BASET)
+		{
+			mode_reg = mode_reg | EMAC_M1_MF_100MBPS;
+			printk("[phy_link] Mode register set 100 Base %08lX\n", mode_reg);
+		}
+		else
+		{
+			mode_reg = mode_reg & (~EMAC_M1_MF_100MBPS);
+			printk("[phy_link] Mode register set 10 Base %08lX\n", mode_reg);
+		}
+		if( fep->phy_duplex == FULL)
+		{
+			mode_reg = mode_reg | EMAC_M1_FDE | EMAC_M1_EIFC;
+			printk("[phy_link] Mode register set FULL duplex flow enable %08lX\n", mode_reg);
+		}
+		else
+		{
+			mode_reg = mode_reg & (~(EMAC_M1_FDE | EMAC_M1_EIFC));
+			printk("[phy_link] Mode register set HALF duplex flow disable %08lX\n", mode_reg);
+		}
+		emacp->em0mr1 = mode_reg;
+		eieio();
+	}
+	/* Reenable the interrupt */
+	ocp_enet_mdio_write(dev, mk_mii_write(PHY_MIPSCR, 0x0500));
+}
+#endif  /* CONFIG_OBS200 */
diff -Naru linux-2.4.20.orig/drivers/net/ibm_ocp/ibm_ocp_phy.c linux-2.4.20/drivers/net/ibm_ocp/ibm_ocp_phy.c
--- linux-2.4.20.orig/drivers/net/ibm_ocp/ibm_ocp_phy.c	2002-12-11 11:38:22.000000000 +0900
+++ linux-2.4.20/drivers/net/ibm_ocp/ibm_ocp_phy.c	2004-12-21 12:27:04.000000000 +0900
@@ -75,6 +75,13 @@
  *  	using zmii_phyid_adj() to adjust phy addrs on those cpus
  *  	that use a zmii bridge
  *  	fixed find_phy for zmii bridge support
+ *
+ * PlatHome <openlab.plathome.co.jp>
+ *	- Added TDK 78Q2120-64T phy support
+ *	- based on 2002-01-03 by ozawa
+ *
+ *      - Added MII_LXT971A_CFG for  OpenBlockS266
+ *
  */
 
 #include <linux/module.h>
@@ -399,6 +406,9 @@
 
 /* register definitions */
 
+#ifdef CONFIG_OBS266
+#define MII_LXT971A_CFG		16	/* PHY Configuration Register */
+#endif
 #define MII_LXT971A_SR2		17	/* PHY status Register #2 */
 #define MII_LXT971A_IER		18	/* PHY interrupt enable Register */
 #define MII_LXT971A_ISR		19	/* PHY interrupt status Register */
@@ -437,6 +447,13 @@
 
 			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
 			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+#ifdef CONFIG_OBS266
+	/* On OpenBlockS266 PHY is LXT972A bit 6 4;3 2 0 has no meaning. */
+	/* So direct write 0x0180 to disable TP Loopback.                */
+	/* When using LXT971A bit 6 0 come from hardware pin setting.    */
+	/* So first read register then set bit 8 and write to register.  */
+		 	     {mk_mii_write(MII_LXT971A_CFG,0x0180), NULL},
+#endif
 			     {mk_mii_end,}
 			     },
 	(const phy_cmd_t[]) {	/* startup - enable interrupts */
@@ -945,6 +962,75 @@
 			     },
 };
 
+#ifdef CONFIG_OBS200
+/* ------------------------------------------------------------------------- */
+/* TDK 78Q2120-64T is used on the Plat'Home OpenBlockSS */
+
+/* register definitions */
+
+#define MII_78Q2120_64T_PHYSTS	0x10	/* PHY Status Register */
+#define MII_78Q2120_64T_ISR	0x11	/* PHY interrupt control/status Register */
+#define MII_78Q2120_64T_DIAG	0x12	/* PHY diagnostic Register */
+
+static void mii_parse_78q2120_64t_diag(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch((mii_reg >> 10) & 3) {
+		case 0:
+			*s |= PHY_STAT_10HDX;
+			break;
+		case 1:
+			*s |= PHY_STAT_100HDX;
+			break;
+		case 2:
+			*s |= PHY_STAT_10FDX;
+			break;
+		case 3:
+			*s |= PHY_STAT_100FDX;
+			break;
+	}
+}
+
+static phy_info_t phy_info_78q2120_64t = {
+	0x0300e54,      /* the rightmost 4-bit is a revision number. so ignore it */
+	"78Q2120-64T",
+	4,              /* the rightmost 4-bit is a revision number. so ignore it */
+	(const phy_cmd_t []) {	/* config */
+
+		/* parse cr and anar to get some info */
+		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
+		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {	/* startup - enable interrupts */
+
+	        /* Link Status Change & Auto Negotiation Complete INT Enable */
+		{ mk_mii_write(MII_78Q2120_64T_ISR, 0x0500), NULL },
+		{ mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL }, /* autonegotiate */
+		{ mk_mii_end, }
+	},
+	( const phy_cmd_t []) { /* ack_int */
+
+		/* we need to read ISR, SR and ANER to acknowledge */
+		{ mk_mii_read(MII_78Q2120_64T_ISR), NULL },
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
+		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
+
+		/* read pcr to get info */
+		{ mk_mii_read(MII_78Q2120_64T_DIAG), mii_parse_78q2120_64t_diag },
+		{ mk_mii_end, }
+	},
+	( const phy_cmd_t []) {	/* shutdown - disable interrupts */
+		{ mk_mii_write(MII_78Q2120_64T_ISR, 0x0000), NULL },
+		{ mk_mii_end, }
+	},
+};
+#endif /* CONFIG_OBS200 */ 
+
 /* ------------------------------------------------------------------------- */
 
 static phy_info_t *phy_info[] = {
@@ -958,6 +1044,9 @@
 	&phy_info_bcm5221,
 	&phy_info_Am79C874,
 	&phy_info_Am79C875A,
+#ifdef CONFIG_OBS200
+	&phy_info_78q2120_64t,
+#endif
 	NULL
 };
 
diff -Naru linux-2.4.20.orig/drivers/net/setup.c linux-2.4.20/drivers/net/setup.c
--- linux-2.4.20.orig/drivers/net/setup.c	2002-12-11 11:38:01.000000000 +0900
+++ linux-2.4.20/drivers/net/setup.c	2004-12-21 12:27:04.000000000 +0900
@@ -1,6 +1,10 @@
 
 /*
  *	New style setup code for the network devices
+ *
+ *	PlatHome <openlab@plathome.co.jp>
+ *		- Modified probe order fec_enet and scc_enet
+ *		  for OpenBlockS 50
  */
  
 #include <linux/config.h>
@@ -66,12 +70,21 @@
 #if defined(CONFIG_ARCNET)
 	{arcnet_init, 0},
 #endif
+#ifdef CONFIG_OBS50
+#if defined(CONFIG_FEC_ENET)
+        {fec_enet_init, 0},
+#endif
+#if defined(CONFIG_SCC_ENET)
+        {scc_enet_init, 0},
+#endif
+#else
 #if defined(CONFIG_SCC_ENET)
         {scc_enet_init, 0},
 #endif
 #if defined(CONFIG_FEC_ENET)
         {fec_enet_init, 0},
 #endif
+#endif /* CONFIG_OBS50 */
 #if defined(CONFIG_COMX)
 	{comx_init, 0},
 #endif
diff -Naru linux-2.4.20.orig/drivers/net/tulip/interrupt.c linux-2.4.20/drivers/net/tulip/interrupt.c
--- linux-2.4.20.orig/drivers/net/tulip/interrupt.c	2002-12-11 11:36:55.000000000 +0900
+++ linux-2.4.20/drivers/net/tulip/interrupt.c	2004-12-21 12:27:04.000000000 +0900
@@ -99,12 +99,19 @@
 	return refilled;
 }
 
-
+#ifdef CONFIG_OBS266
+static int tulip_rx(struct net_device *dev,int rest_buf)
+#else
 static int tulip_rx(struct net_device *dev)
+#endif
 {
 	struct tulip_private *tp = (struct tulip_private *)dev->priv;
 	int entry = tp->cur_rx % RX_RING_SIZE;
+#ifdef CONFIG_OBS266
+	int rx_work_limit = tp->dirty_rx + rest_buf - tp->cur_rx;
+#else
 	int rx_work_limit = tp->dirty_rx + RX_RING_SIZE - tp->cur_rx;
+#endif
 	int received = 0;
 
 #ifdef CONFIG_NET_HW_FLOWCONTROL
@@ -285,7 +292,11 @@
                 }
         }
 
+#ifdef CONFIG_OBS266
+        return rest_buf+1; /* maxrx+1 */
+#else
         return RX_RING_SIZE+1; /* maxrx+1 */
+#endif
 #else
 	return received;
 #endif
@@ -353,7 +364,11 @@
                         if ((!tp->fc_bit) ||
 			    (!test_bit(tp->fc_bit, &netdev_fc_xoff)))
 #endif
+#ifdef CONFIG_OBS266
+				rx += tulip_rx(dev,RX_RING_SIZE - rx);
+#else
 				rx += tulip_rx(dev);
+#endif
 			tulip_refill_rx(dev);
 		}
 
@@ -540,6 +555,11 @@
 			break;
 		}
 
+#ifdef CONFIG_OBS266
+		if (rx > (RX_RING_SIZE*2/3))
+			break;
+#endif
+
 		work_count--;
 		if (work_count == 0)
 			break;
diff -Naru linux-2.4.20.orig/drivers/net/tulip/tulip.h linux-2.4.20/drivers/net/tulip/tulip.h
--- linux-2.4.20.orig/drivers/net/tulip/tulip.h	2002-12-11 11:40:35.000000000 +0900
+++ linux-2.4.20/drivers/net/tulip/tulip.h	2004-12-21 12:27:04.000000000 +0900
@@ -11,6 +11,9 @@
 	for more information on this driver, or visit the project
 	Web page at http://sourceforge.net/projects/tulip/
 
+	PlatHome <openlab.plathome.co.jp>
+		- Added for OpenBlockS 266
+
 */
 
 #ifndef __NET_TULIP_H__
@@ -261,8 +264,13 @@
    Making the Tx ring too large decreases the effectiveness of channel
    bonding and packet priority.
    There are no ill effects from too-large receive rings. */
+#ifdef CONFIG_OBS266
+#define TX_RING_SIZE	32	/* Original 16 */
+#define RX_RING_SIZE	64	/* Original 32 */
+#else
 #define TX_RING_SIZE	16
 #define RX_RING_SIZE	32
+#endif
 
 #define MEDIA_MASK     31
 
@@ -332,6 +340,10 @@
 
 struct ring_info {
 	struct sk_buff	*skb;
+#ifdef CONFIG_OBS266
+	char *bounce_buffer;
+	size_t bb_size;
+#endif
 	dma_addr_t	mapping;
 };
 
diff -Naru linux-2.4.20.orig/drivers/net/tulip/tulip_core.c linux-2.4.20/drivers/net/tulip/tulip_core.c
--- linux-2.4.20.orig/drivers/net/tulip/tulip_core.c	2002-12-11 11:37:38.000000000 +0900
+++ linux-2.4.20/drivers/net/tulip/tulip_core.c	2004-12-21 12:27:04.000000000 +0900
@@ -11,6 +11,9 @@
 	Please refer to Documentation/DocBook/tulip.{pdf,ps,html}
 	for more information on this driver, or visit the project
 	Web page at http://sourceforge.net/projects/tulip/
+	
+	PlatHome <openlab.plathome.co.jp>
+		- Added for OpenBlockS 266
 
 */
 
@@ -702,6 +705,10 @@
 	for (i = 0; i < TX_RING_SIZE; i++) {
 		tp->tx_buffers[i].skb = NULL;
 		tp->tx_buffers[i].mapping = 0;
+#ifdef CONFIG_OBS266
+		tp->tx_buffers[i].bounce_buffer = NULL;
+		tp->tx_buffers[i].bb_size = 0;
+#endif
 		tp->tx_ring[i].status = 0x00000000;
 		tp->tx_ring[i].buffer2 = cpu_to_le32(tp->tx_ring_dma + sizeof(struct tulip_tx_desc) * (i + 1));
 	}
@@ -723,8 +730,28 @@
 	entry = tp->cur_tx % TX_RING_SIZE;
 
 	tp->tx_buffers[entry].skb = skb;
+#ifdef CONFIG_OBS266
+	{
+	  /*realloc bounce buffer*/
+	  u32 ptr; /*XXX I want to use uintptr_t */
+	  if(tp->tx_buffers[entry].bb_size < skb->len){ 
+	    tp->tx_buffers[entry].bb_size = skb->len;
+	    if(tp->tx_buffers[entry].bounce_buffer)
+	      kfree(tp->tx_buffers[entry].bounce_buffer);
+	    tp->tx_buffers[entry].bounce_buffer = kmalloc(skb->len+3,
+							  GFP_ATOMIC);
+	  }
+	  /*Align 4 byte boundary*/
+	  ptr = (u32)tp->tx_buffers[entry].bounce_buffer + 3;
+	  ptr &= ~3;
+	  
+	  memcpy((void *)ptr, skb->data, skb->len);
+	  mapping = pci_map_single(tp->pdev, (void *)ptr, skb->len, PCI_DMA_TODEVICE);
+	}
+#else
 	mapping = pci_map_single(tp->pdev, skb->data,
 				 skb->len, PCI_DMA_TODEVICE);
+#endif
 	tp->tx_buffers[entry].mapping = mapping;
 	tp->tx_ring[entry].buffer1 = cpu_to_le32(mapping);
 
@@ -887,6 +914,13 @@
 		}
 		tp->tx_buffers[i].skb = NULL;
 		tp->tx_buffers[i].mapping = 0;
+#ifdef CONFIG_OBS266
+		if(tp->tx_buffers[i].bounce_buffer != NULL) {
+			kfree(tp->tx_buffers[i].bounce_buffer);
+		}
+		tp->tx_buffers[i].bounce_buffer = NULL;
+		tp->tx_buffers[i].bb_size = 0;
+#endif
 	}
 
 	MOD_DEC_USE_COUNT;
diff -Naru linux-2.4.20.orig/include/asm-ppc/commproc.h linux-2.4.20/include/asm-ppc/commproc.h
--- linux-2.4.20.orig/include/asm-ppc/commproc.h	2002-12-11 11:39:17.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/commproc.h	2004-12-21 12:27:04.000000000 +0900
@@ -17,6 +17,10 @@
  * bytes of the DP RAM and relocates the I2C parameter area to the
  * IDMA1 space.  The remaining DP RAM is available for buffer descriptors
  * or other use.
+ * 
+ * for OpenBlockS 50
+ * Copyright (C) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ * 
  */
 #ifndef __CPM_8XX__
 #define __CPM_8XX__
@@ -587,6 +591,29 @@
 #define SICR_ENET_CLKRT	((uint)0x00260000)
 #endif	/* CONFIG_SM850 */
 
+/***  OpenBlockS  ****************************************************/
+
+#ifdef CONFIG_OBS50
+
+/*
+ * for OpenBlockS
+ * Copyright (C) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ * 
+ * This ENET stuff is for the MPC860 with ethernet on SCC2.
+ * This is unique to the OpenBlockS.
+ */
+#define PA_ENET_RXD	((ushort)0x0004)
+#define PA_ENET_TXD	((ushort)0x0008)
+#define PA_ENET_TCLK	((ushort)0x0100)
+#define PA_ENET_RCLK	((ushort)0x0200)
+#define PB_ENET_TENA	((uint)0x00002000)
+#define PC_ENET_CLSN	((ushort)0x0040)
+#define PC_ENET_RENA	((ushort)0x0080)
+
+#define SICR_ENET_MASK	((uint)0x0000ff00)
+#define SICR_ENET_CLKRT	((uint)0x00002c00)	/* RCLK:TCLK = CLK2:CLK1 */
+#endif /* CONFIG_OBS50 */
+
 /*********************************************************************/
 
 /* SCC Event register as used by Ethernet.
diff -Naru linux-2.4.20.orig/include/asm-ppc/ibm4xx.h linux-2.4.20/include/asm-ppc/ibm4xx.h
--- linux-2.4.20.orig/include/asm-ppc/ibm4xx.h	2002-12-11 11:38:55.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/ibm4xx.h	2004-12-21 12:27:04.000000000 +0900
@@ -8,6 +8,11 @@
  *	A generic include file which pulls in appropriate include files
  *      for specific board types based on configuration settings.
  *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added CONFIG_OBS200
+ *		- Added CONFIG_EBK405GPR
+ *		- Added CONFIG_OBS266
+ *
  */
 
 #ifdef __KERNEL__
@@ -113,6 +118,18 @@
 #include <platforms/sycamore.h>
 #endif
 
+#if defined(CONFIG_EBK405GPR)
+#include <platforms/ebk405gpr.h>
+#endif
+
+#if defined(CONFIG_OBS200)
+#include <platforms/openblocks200.h>
+#endif
+
+#if defined(CONFIG_OBS266)
+#include <platforms/openblocks266.h>
+#endif
+
 #ifndef PPC4xx_MACHINE_NAME
 #define PPC4xx_MACHINE_NAME	"Unidentified 4xx class"
 #endif
diff -Naru linux-2.4.20.orig/include/asm-ppc/ide.h linux-2.4.20/include/asm-ppc/ide.h
--- linux-2.4.20.orig/include/asm-ppc/ide.h	2002-12-11 11:38:22.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/ide.h	2004-12-21 12:27:04.000000000 +0900
@@ -6,6 +6,9 @@
  *
  *  Copyright (C) 1994-1996 Linus Torvalds & authors */
 
+/*	PlatHome <openlab@plathome.co.jp>
+ *		- Added for OpenBlockS 50
+ */
 /*
  *  This file contains the ppc architecture specific IDE code.
  */
@@ -180,6 +183,21 @@
 #define ide_release_lock(lock)		do {} while (0)
 #define ide_get_lock(lock, hdlr, data)	do {} while (0)
 
+#ifdef CONFIG_OBS50
+/* the drive addressing is done through a controller register */
+void OUT_BYTE(unsigned char dat, ide_ioreg_t port);
+unsigned char IN_BYTE(ide_ioreg_t port);
+#define HAVE_ARCH_OUT_BYTE
+#define HAVE_ARCH_IN_BYTE
+
+#undef outsw
+#define outsw(port, buf, ns)	_outsw((u16 *)(port), (buf), (ns))
+
+#undef insw
+#define insw(port, buf, ns)	_insw((u16 *)(port), (buf), (ns))
+
+#endif /* CONFIG_OBS50 */
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASMPPC_IDE_H */
diff -Naru linux-2.4.20.orig/include/asm-ppc/ioctls.h linux-2.4.20/include/asm-ppc/ioctls.h
--- linux-2.4.20.orig/include/asm-ppc/ioctls.h	2002-12-11 11:37:10.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/ioctls.h	2004-12-21 12:27:04.000000000 +0900
@@ -1,6 +1,10 @@
 /*
  * BK Id: %F% %I% %G% %U% %#%
  */
+/*
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- added UPS control for OpenBlockS 266
+*/
 #ifndef _ASM_PPC_IOCTLS_H
 #define _ASM_PPC_IOCTLS_H
 
@@ -108,4 +112,11 @@
 #define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
 #define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
 
+#ifdef CONFIG_OBS266
+#define	UPSIOINIT	_IOW('U', 0x30, int)	/* initialize UPS func */
+#define	UPSIOSTART	_IOW('U', 0x31, int)	/* start UPS func */
+#define	UPSIOSTOP	_IOW('U', 0x32, int)	/* stop UPS func */
+#define	UPSIOTIME	_IOW('U', 0x33, int)	/* set ups timeout */
+#endif
+
 #endif /* _ASM_PPC_IOCTLS_H */
diff -Naru linux-2.4.20.orig/include/asm-ppc/mpc8xx.h linux-2.4.20/include/asm-ppc/mpc8xx.h
--- linux-2.4.20.orig/include/asm-ppc/mpc8xx.h	2002-12-11 11:37:40.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/mpc8xx.h	2004-12-21 12:27:04.000000000 +0900
@@ -7,6 +7,10 @@
  * we have a unique include file for each.  Rather than change every
  * file that has to include MPC8xx configuration, they all include
  * this one and the configuration switching is done here.
+ *
+ * 	PlatHome<openlab@plathome.co.jp>
+ *		- Added for OpenBlockS 50
+ *
  */
 #ifdef __KERNEL__
 #ifndef __CONFIG_8xx_DEFS
@@ -48,6 +52,10 @@
 #include <platforms/ivms8.h>
 #endif
 
+#if defined(CONFIG_OBS50)
+#include <platforms/openblocks50.h>
+#endif
+
 #if defined(CONFIG_HERMES_PRO)
 #include <platforms/hermes.h>
 #endif
diff -Naru linux-2.4.20.orig/include/asm-ppc/pgtable.h linux-2.4.20/include/asm-ppc/pgtable.h
--- linux-2.4.20.orig/include/asm-ppc/pgtable.h	2002-12-11 11:37:04.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/pgtable.h	2004-12-21 12:27:04.000000000 +0900
@@ -1,5 +1,9 @@
 /*
  * BK Id: %F% %I% %G% %U% %#%
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		by yhirano@mbc.nifty.com
+ *
  */
 #ifdef __KERNEL__
 #ifndef _PPC_PGTABLE_H
@@ -686,11 +690,19 @@
  * must not include the _PAGE_PRESENT bit, or the _PAGE_HASHPTE bit
  * (if used).  -- paulus
  */
+#ifdef CONFIG_OBS2xx
+#define SWP_TYPE(entry)			((entry).val & 0x3f)
+#define SWP_OFFSET(entry)		((entry).val >> 10)
+#define SWP_ENTRY(type, offset)		((swp_entry_t) { (type) | ((offset) << 10) })
+#define pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 2 })
+#define swp_entry_to_pte(x)		((pte_t) { (x).val << 2 })
+#else
 #define SWP_TYPE(entry)			((entry).val & 0x3f)
 #define SWP_OFFSET(entry)		((entry).val >> 6)
 #define SWP_ENTRY(type, offset)		((swp_entry_t) { (type) | ((offset) << 6) })
 #define pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 2 })
 #define swp_entry_to_pte(x)		((pte_t) { (x).val << 2 })
+#endif
 
 /* CONFIG_APUS */
 /* For virtual address to physical address conversion */
diff -Naru linux-2.4.20.orig/include/asm-ppc/ppcboot.h linux-2.4.20/include/asm-ppc/ppcboot.h
--- linux-2.4.20.orig/include/asm-ppc/ppcboot.h	2002-12-11 11:39:42.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/ppcboot.h	2004-12-21 12:27:04.000000000 +0900
@@ -16,6 +16,9 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
+ *
+ * 	PlatHome <openlab@plathome.co.jp>
+ *		- Added for OpenBlockS 50
  */
 
 #ifndef __ASM_PPCBOOT_H__
@@ -84,6 +87,9 @@
 	unsigned char	bi_enet1addr[6];
 	unsigned char	bi_enet2addr[6];
 #endif
+#if defined(CONFIG_OBS50)
+	unsigned char	bi_enet1addr[6]; /* 2nd Ethernet address */
+#endif
 	mon_fnc_t	*bi_mon_fnc;	/* Pointer to monitor functions	*/
 } bd_t;
 
diff -Naru linux-2.4.20.orig/include/asm-ppc/pushsw_obs2xx.h linux-2.4.20/include/asm-ppc/pushsw_obs2xx.h
--- linux-2.4.20.orig/include/asm-ppc/pushsw_obs2xx.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/pushsw_obs2xx.h	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,19 @@
+/*
+ *	Century <www.centurysys.co.jp>
+ *		- Century's push switch driver header
+ */
+
+#include <linux/ioctl.h>
+#include <linux/major.h>
+/* #include <linux/miscdevice.h> */
+
+#define PUSHSW_MAJOR		(MISC_MAJOR)
+
+#define	PUSHSW_IOCTL_BASE	'P'
+
+#define	PSWIOC_GETSTATUS	_IOR(PUSHSW_IOCTL_BASE, 0, int)
+#define	PSWIOC_WAITPUSH		_IOR(PUSHSW_IOCTL_BASE, 1, int)
+#define	PSWIOC_GETWAITPID	_IOR(PUSHSW_IOCTL_BASE, 2, int)
+
+#define PSWIOF_PUSHED		(1)
+#define PSWIOF_NOTPUSHED	(0)
diff -Naru linux-2.4.20.orig/include/asm-ppc/segled_obs200.h linux-2.4.20/include/asm-ppc/segled_obs200.h
--- linux-2.4.20.orig/include/asm-ppc/segled_obs200.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.20/include/asm-ppc/segled_obs200.h	2004-12-21 12:27:04.000000000 +0900
@@ -0,0 +1,62 @@
+/*
+ * 	Century <www.centurysys.co.jp>
+ *		- Header for Century's 7 segment LED driver
+ *
+ */
+
+#include <linux/ioctl.h>
+#include <linux/major.h>
+/* #include <linux/miscdevice.h> */
+
+#define SEGLED_MAJOR		(MISC_MAJOR)
+
+#define	SEGLED_IOCTL_BASE	'S'
+
+#define	SLIOC_TEST		_IOR(SEGLED_IOCTL_BASE, 0, int)
+#define	SLIOC_SETVAL		_IOR(SEGLED_IOCTL_BASE, 1, int)
+#define	SLIOC_SETSEG		_IOR(SEGLED_IOCTL_BASE, 2, int)
+#define SLIOC_GET_OWNER_PID	_IOR(SEGLED_IOCTL_BASE, 3, int)
+#define SLIOC_RESERVE		_IOR(SEGLED_IOCTL_BASE, 4, int)
+#define	SLIOC_TEST405		_IOR(SEGLED_IOCTL_BASE, 5, int)
+
+/* @@ MA 360 boards
+#define SL_A	(0x01)
+#define SL_B	(0x02)
+#define SL_C	(0x80)
+#define SL_D	(0x20)
+#define SL_E	(0x40)
+#define SL_F	(0x04)
+#define SL_G	(0x08)
+#define SL_DP	(0x10)
+#define SL_NONE	(0x00)
+#define SL_ALL	(SL_A | SL_B | SL_C | SL_D | SL_E | SL_F | SL_G | SL_DP)
+*/
+
+/* @@ MA 300 */
+#define SL_A	(0x08)
+#define SL_B	(0x04)
+#define SL_C	(0x01)
+#define SL_D	(0x10)
+#define SL_E	(0x20)
+#define SL_F	(0x02)
+#define SL_G	(0x80)
+#define SL_DP	(0x40)
+#define SL_NONE	(0x00)
+#define SL_ALL	(SL_A | SL_B | SL_C | SL_D | SL_E | SL_F | SL_G | SL_DP)
+
+#define SL_V0	(SL_A | SL_B | SL_C | SL_D | SL_E | SL_F)
+#define SL_V1	(SL_B | SL_C)
+#define SL_V2	(SL_A | SL_B | SL_D | SL_E | SL_G)
+#define SL_V3	(SL_A | SL_B | SL_C | SL_D | SL_G)
+#define SL_V4	(SL_B | SL_C | SL_F | SL_G)
+#define SL_V5	(SL_C | SL_F | SL_A | SL_G | SL_D)
+#define SL_V6	(SL_C | SL_F | SL_A | SL_G | SL_E | SL_D)
+#define SL_V7	(SL_C | SL_F | SL_B | SL_A)
+#define SL_V8	(SL_A | SL_B | SL_C | SL_D | SL_E | SL_F | SL_G)
+#define SL_V9	(SL_A | SL_B | SL_C | SL_D | SL_F | SL_G)
+#define SL_VA	(SL_A | SL_B | SL_C | SL_E | SL_F | SL_G)
+#define SL_VB	(SL_C | SL_F | SL_G | SL_E | SL_D)
+#define SL_VC	(SL_F | SL_A | SL_E | SL_D)
+#define SL_VD	(SL_C | SL_B | SL_G | SL_E | SL_D)
+#define SL_VE	(SL_F | SL_A | SL_G | SL_E | SL_D)
+#define SL_VF	(SL_F | SL_A | SL_G | SL_E)
diff -Naru linux-2.4.20.orig/include/linux/miscdevice.h linux-2.4.20/include/linux/miscdevice.h
--- linux-2.4.20.orig/include/linux/miscdevice.h	2002-12-11 11:38:49.000000000 +0900
+++ linux-2.4.20/include/linux/miscdevice.h	2004-12-21 12:27:04.000000000 +0900
@@ -1,3 +1,7 @@
+/*
+	PlatHome <openlab.plathome.co.jp>
+		- Added PUSHSW_MINOR, SEGLED_MINOR for OpenBlockS
+*/
 #ifndef _LINUX_MISCDEVICE_H
 #define _LINUX_MISCDEVICE_H
 
@@ -21,6 +25,8 @@
 #define SUN_OPENPROM_MINOR 139
 #define NVRAM_MINOR 144
 #define I2O_MINOR 166
+#define PUSHSW_MINOR	170
+#define SEGLED_MINOR	171
 #define MICROCODE_MINOR		184
 #define MWAVE_MINOR	219		/* ACP/Mwave Modem */
 #define MPT_MINOR	220
diff -Naru linux-2.4.20.orig/init/do_mounts.c linux-2.4.20/init/do_mounts.c
--- linux-2.4.20.orig/init/do_mounts.c	2002-12-11 11:40:07.000000000 +0900
+++ linux-2.4.20/init/do_mounts.c	2004-12-21 12:27:04.000000000 +0900
@@ -1,3 +1,12 @@
+/*
+	ozawa CONFIG_OBSS
+	PlatHome <openlab.plathome.co.jp>
+		- Modified CONFIG_OBSS to CONFIG_OBS200
+		- Added do_restore()
+		- write able root mount if load user configuration
+		  in prepare_namespace()
+		- Added for CONFIG_OBS266, ONFIG_OBS2xx, ONFIG_OBS50 
+*/
 #define __KERNEL_SYSCALLS__
 #include <linux/config.h>
 #include <linux/slab.h>
@@ -9,12 +18,24 @@
 #include <linux/tty.h>
 #include <linux/init.h>
 
+#ifdef CONFIG_OBS200
+#include <asm/io.h>
+#include <asm/bugs.h>
+#endif
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
 #include <linux/nfs_mount.h>
 #include <linux/minix_fs.h>
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
+#ifdef CONFIG_OBS200
+#include <asm/segled_obs200.h>
+#define OPNT ((volatile unsigned char *)(0x40000000))
+#endif
+#ifdef CONFIG_OBS50
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+#endif
 
 #define BUILD_CRAMDISK
 
@@ -471,6 +492,16 @@
 	int nblocks = -1;
 	unsigned char *buf;
 
+#ifdef CONFIG_OBS50
+	printk("check dipsw:   ");
+	if ((((immap_t *)IMAP_ADDR)->im_ioport.iop_padat & 0xc000) != 0x0000) {
+		printk("hdroot\n");
+		/* image could not be found. */
+		return -1;
+	} else {
+		printk("ramroot\n");
+	}
+#endif
 	buf = kmalloc(size, GFP_KERNEL);
 	if (buf == 0)
 		return -1;
@@ -549,8 +580,12 @@
 
 #ifdef CONFIG_BLK_DEV_RAM
 	int in_fd, out_fd;
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+	int nblocks, rd_blocks, devblocks, i;
+#else
 	unsigned long rd_blocks, devblocks;
 	int nblocks, i;
+#endif
 	char *buf;
 	unsigned short rotate = 0;
 #if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC_ISERIES)
@@ -620,6 +655,10 @@
 		goto done;
 	}
 
+#ifdef CONFIG_OBS200
+	*OPNT = (unsigned char)~(SL_V5);
+#endif
+
 	printk(KERN_NOTICE "RAMDISK: Loading %d blocks [%d disk%s] into ram disk... ", 
 		nblocks, ((nblocks-1)/devblocks)+1, nblocks>devblocks ? "s" : "");
 	for (i=0; i < nblocks; i++) {
@@ -779,7 +818,33 @@
 	return execve(shell, argv, envp_init);
 }
 
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+static int do_restore(void *shell)
+{
+	static char *argv[] = { "flashcfg",
+#if defined(CONFIG_OBS266)
+				"-x",
+#endif
+				NULL, };
+	extern char *envp_init[];
+
+#ifdef CONFIG_OBS266
+	close(old_fd);
+	close(root_fd);
 #endif
+	close(0);
+	close(1);
+	close(2);
+	setsid();
+	(void) open("/dev/console",O_RDWR,0);
+	(void) dup(0);
+	(void) dup(0);
+	execve(shell, argv, envp_init);
+	printk("[do_restore] Error starting restore thread!\n");
+	return (-1);
+}
+#endif /* CONFIG_OBS2xx || CONFIG_OBS50 */
+#endif /* CONFIG_BLK_DEV_INITRD */
 
 static void __init handle_initrd(void)
 {
@@ -863,6 +928,10 @@
 	arch_discover_root();
 #endif /* CONFIG_ALL_PPC */
 #ifdef CONFIG_BLK_DEV_INITRD
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+	bd_t *bip = (bd_t *)__res;
+	int real_root_mountflags;
+#endif
 	if (!initrd_start)
 		mount_initrd = 0;
 	real_root_dev = ROOT_DEV;
@@ -883,12 +952,52 @@
 		}
 	} else if (is_floppy && rd_doload && rd_load_disk(0))
 		ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+	/* write able root mount if load user configuration from flash necessary. */
+#if defined(CONFIG_OBS266)
+	if (bip->bi_r_version[0] && mount_initrd) {
+#else
+	if (mount_initrd) {
+#endif
+		real_root_mountflags = root_mountflags;
+		root_mountflags &= ~MS_RDONLY;
+	}
+#endif
 	mount_root();
 out:
 	sys_umount("/dev", 0);
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
 	mount_devfs_fs ();
+
+#ifdef CONFIG_OBS200
+	*OPNT = (unsigned char)~(SL_V4);
+#endif
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+
+	/*
+	 *	If initrd has been mounted, load user configuration
+	 *	from flash if necessary.
+	 */
+#if defined(CONFIG_OBS2xx)
+	if (bip->bi_s_version[0] && mount_initrd) {
+#else
+	if (mount_initrd) {
+#endif
+		root_mountflags = real_root_mountflags;
+		printk("[prepare_namespace] Executing flashcfg...\n");
+		if ((MAJOR(ROOT_DEV) == RAMDISK_MAJOR) && (MINOR(ROOT_DEV) == 0)) {
+			int pid,i;
+			pid = kernel_thread(do_restore, "/usr/sbin/flashcfg", SIGCHLD);
+			if (pid > 0) {
+				while (pid != wait(&i));
+			}
+			else printk("[prepare_namespace] Error starting restore thread!\n");
+		}
+		printk("[prepare_namespace] Finished executing flashcfg\n");
+	}
+#endif /* CONFIG_OBS2xx || CONFIG_OBS50 */
 }
 
 #if defined(BUILD_CRAMDISK) && defined(CONFIG_BLK_DEV_RAM)
diff -Naru linux-2.4.20.orig/init/main.c linux-2.4.20/init/main.c
--- linux-2.4.20.orig/init/main.c	2002-12-11 11:37:59.000000000 +0900
+++ linux-2.4.20/init/main.c	2004-12-21 12:27:04.000000000 +0900
@@ -7,6 +7,15 @@
  *  Added initrd & change_root: Werner Almesberger & Hans Lermen, Feb '96
  *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May '96
  *  Simplified starting of init:  Michael A. Griffith <grif@acm.org> 
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Added LED display
+ *		- Added recovery mode handling
+ *	2001-12-25 ozawa CONFIG_OBSS
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *		- Added for OpenBlockS 266
+ *
  */
 
 #define __KERNEL_SYSCALLS__
@@ -30,6 +39,10 @@
 
 #include <asm/io.h>
 #include <asm/bugs.h>
+#if defined(CONFIG_OBS200)
+#include <asm/segled_obs200.h>
+#define OPNT ((volatile unsigned char *)(0x40000000))
+#endif
 
 #if defined(CONFIG_ARCH_S390)
 #include <asm/s390mach.h>
@@ -107,6 +120,10 @@
 extern void ipc_init(void);
 #endif
 
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+extern int obsled_out(int);
+#endif
+
 /*
  * Boot command-line arguments
  */
@@ -121,7 +138,11 @@
 char *execute_command;
 
 static char * argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
+#if defined(CONFIG_OBS200)
+char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=vt100", NULL, };
+#else
 char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
+#endif
 
 static int __init profile_setup(char *str)
 {
@@ -354,6 +375,9 @@
  * enable them
  */
 	lock_kernel();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	obsled_out(2);
+#endif
 	printk(linux_banner);
 	setup_arch(&command_line);
 	printk("Kernel command line: %s\n", saved_command_line);
@@ -460,6 +484,9 @@
  */
 static void __init do_basic_setup(void)
 {
+#if defined(CONFIG_OBS200)
+	*OPNT = (unsigned char)~(SL_V2);
+#endif
 
 	/*
 	 * Tell the world that we're going to be the grim
@@ -543,9 +570,15 @@
 static int init(void * unused)
 {
 	lock_kernel();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	obsled_out(3);
+#endif
 	do_basic_setup();
 
 	prepare_namespace();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	obsled_out(5);
+#endif
 
 	/*
 	 * Ok, we have completed the initial bootup, and
@@ -568,6 +601,13 @@
 	 * trying to recover a really broken machine.
 	 */
 
+#if defined(CONFIG_OBS200)
+	*OPNT = (unsigned char)~(SL_V6);
+#endif
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	obsled_out(6);
+#endif
+
 	if (execute_command)
 		execve(execute_command,argv_init,envp_init);
 	execve("/sbin/init",argv_init,envp_init);
diff -Naru linux-2.4.20.orig/kernel/time.c linux-2.4.20/kernel/time.c
--- linux-2.4.20.orig/kernel/time.c	2002-12-11 11:38:44.000000000 +0900
+++ linux-2.4.20/kernel/time.c	2004-12-21 12:27:04.000000000 +0900
@@ -22,6 +22,9 @@
  *	"A Kernel Model for Precision Timekeeping" by Dave Mills
  *	Allow time_constant larger than MAXTC(6) for NTP v4 (MAXTC == 10)
  *	(Even though the technical memorandum forbids it)
+ *
+ *	PlatHome <openlab@plathome.co.jp>
+ *		- Added for OpenBlockS 50
  */
 
 #include <linux/mm.h>
@@ -89,6 +92,9 @@
 	time_maxerror = NTP_PHASE_LIMIT;
 	time_esterror = NTP_PHASE_LIMIT;
 	write_unlock_irq(&xtime_lock);
+#ifdef CONFIG_OBS50
+	rtcbak_set_time(value);
+#endif
 	return 0;
 }
 
