diff -Naru linux-2.4.28.orig/Rules.make linux-2.4.28/Rules.make
--- linux-2.4.28.orig/Rules.make	2004-02-18 22:36:30.000000000 +0900
+++ linux-2.4.28/Rules.make	2005-01-31 11:52:56.000000000 +0900
@@ -177,6 +177,8 @@
 ifneq "$(strip $(ALL_MOBJS))" ""
 	mkdir -p $(MODLIB)/kernel/$(MOD_DESTDIR)
 	cp $(sort $(ALL_MOBJS)) $(MODLIB)/kernel/$(MOD_DESTDIR)
+	${STRIP} -S $(MODLIB)/kernel/$(MOD_DESTDIR)/*.o
+	gzip -9 $(MODLIB)/kernel/$(MOD_DESTDIR)/*.o
 endif
 
 .PHONY: modules_install
diff -Naru linux-2.4.28.orig/arch/ppc/8xx_io/Config.in linux-2.4.28/arch/ppc/8xx_io/Config.in
--- linux-2.4.28.orig/arch/ppc/8xx_io/Config.in	2004-02-18 22:36:30.000000000 +0900
+++ linux-2.4.28/arch/ppc/8xx_io/Config.in	2005-01-31 11:52:56.000000000 +0900
@@ -21,25 +21,32 @@
   bool '8xxT FEC Ethernet' CONFIG_FEC_ENET
   if [ "$CONFIG_FEC_ENET" = "y" ]; then
     bool 'Use MDIO for PHY configuration' CONFIG_USE_MDIO
+    bool 'Configure FEC Ethernet before SCC Ethernet' CONFIG_FEC_ENET_BEFORE_SCC_ENET
   fi
   bool 'Use Big CPM Ethernet Buffers' CONFIG_ENET_BIG_BUFFERS
 fi
-if [ "$CONFIG_SCC3_ENET" != "y" ]; then
-  bool 'Use SMC1 for UART' CONFIG_8xx_SMC1
-fi
-bool 'Use SMC2 for UART' CONFIG_8xx_SMC2
-if [ "$CONFIG_8xx_SMC2" = "y" ]; then
-  bool 'Use Alternate SMC2 I/O (823/850)' CONFIG_ALTSMC2
-  bool 'Use SMC2 for Console' CONFIG_CONS_SMC2
-fi
-if [ "$CONFIG_SCC1_ENET" != "y" ]; then
-  bool 'Use SCC1 for UART' CONFIG_8xx_SCC1 
-fi
-if [ "$CONFIG_SCC2_ENET" != "y" ]; then
-  bool 'Use SCC2 for UART' CONFIG_8xx_SCC2
-fi
-if [ "$CONFIG_SCC3_ENET" != "y" ]; then
-  bool 'Use SCC3 for UART' CONFIG_8xx_SCC3
+if [ "$CONFIG_OBS50" = "y" ]; then
+	define_bool CONFIG_8xx_SCC1 y
+	define_bool CONFIG_8xx_SCC2 n
+	define_bool CONFIG_8xx_SCC3 n
+else
+	if [ "$CONFIG_SCC3_ENET" != "y" ]; then
+	  bool 'Use SMC1 for UART' CONFIG_8xx_SMC1
+	fi
+	bool 'Use SMC2 for UART' CONFIG_8xx_SMC2
+	if [ "$CONFIG_8xx_SMC2" = "y" ]; then
+	  bool 'Use Alternate SMC2 I/O (823/850)' CONFIG_ALTSMC2
+	  bool 'Use SMC2 for Console' CONFIG_CONS_SMC2
+	fi
+	if [ "$CONFIG_SCC1_ENET" != "y" ]; then
+	  bool 'Use SCC1 for UART' CONFIG_8xx_SCC1 
+	fi
+	if [ "$CONFIG_SCC2_ENET" != "y" ]; then
+	  bool 'Use SCC2 for UART' CONFIG_8xx_SCC2
+	fi
+	if [ "$CONFIG_SCC3_ENET" != "y" ]; then
+	  bool 'Use SCC3 for UART' CONFIG_8xx_SCC3
+	fi
 fi
 bool 'Use SCC4 for UART' CONFIG_8xx_SCC4
 endmenu
diff -Naru linux-2.4.28.orig/arch/ppc/8xx_io/enet.c linux-2.4.28/arch/ppc/8xx_io/enet.c
--- linux-2.4.28.orig/arch/ppc/8xx_io/enet.c	2003-11-29 03:26:19.000000000 +0900
+++ linux-2.4.28/arch/ppc/8xx_io/enet.c	2005-01-31 11:52:56.000000000 +0900
@@ -21,6 +21,10 @@
  * will be much more memory efficient and will easily handle lots of
  * small packets.
  *
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Replace bi_enetaddr to bi_enet1addr for OpenBlockS 50
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -804,7 +808,11 @@
 	 */
 	eap = (unsigned char *)&(ep->sen_paddrh);
 	for (i=5; i>=0; i--)
+#ifdef CONFIG_OBS50
+		*eap++ = dev->dev_addr[i] = bd->bi_enet1addr[i];
+#else
 		*eap++ = dev->dev_addr[i] = bd->bi_enetaddr[i];
+#endif
 
 	ep->sen_pper = 0;	/* 'cause the book says so */
 	ep->sen_taddrl = 0;	/* temp address (LSB) */
diff -Naru linux-2.4.28.orig/arch/ppc/8xx_io/fec.c linux-2.4.28/arch/ppc/8xx_io/fec.c
--- linux-2.4.28.orig/arch/ppc/8xx_io/fec.c	2003-11-29 03:26:19.000000000 +0900
+++ linux-2.4.28/arch/ppc/8xx_io/fec.c	2005-01-31 11:52:56.000000000 +0900
@@ -23,15 +23,23 @@
  * Make use of MII for PHY control configurable.
  * Some fixes.
  * Copyright (c) 2000 Wolfgang Denk, DENX Software Engineering.
+ *
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Support for 78Q2120 PHY
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 
 /* List of PHYs we wish to support.
 */
 #undef	CONFIG_FEC_LXT970
-#define	CONFIG_FEC_LXT971
+#undef	CONFIG_FEC_LXT971
 #undef	CONFIG_FEC_QS6612
 #undef	CONFIG_FEC_DP83843
 #undef	CONFIG_FEC_DP83846A
+#ifdef	CONFIG_OBS50
+#define	CONFIG_FEC_78Q2120
+#endif
 
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -1045,10 +1053,70 @@
 	},
 };
 
-
 #endif /* CONFIG_FEC_QS6612 */
 
 
+#ifdef	CONFIG_FEC_78Q2120
+
+/* -------------------------------------------------------------------- */
+/* The TDK SEMICONDUCTOR CORP. 78Q2120 is used on OpenBlockS 50		*/
+/* -------------------------------------------------------------------- */
+
+#define MII_78Q2120_VENDOR	16	/* Vendor Specific Register  */
+#define MII_78Q2120_ICSR	17	/* Interrupt Control/Status Register */
+#define MII_78Q2120_DIAG	18	/* Diagnostic Register */
+
+static void mii_parse_78q2120_diag(uint mii_reg, struct net_device *dev)
+{
+	struct fec_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	/* DPLX, RATE */
+	switch((mii_reg >> 10) & 3) {
+		case 0: *s |= PHY_STAT_10HDX; break;
+		case 1: *s |= PHY_STAT_100HDX; break;
+		case 2: *s |= PHY_STAT_10FDX; break;
+		case 3: *s |= PHY_STAT_100FDX; break;
+	}
+}
+
+static phy_info_t phy_info_78q2120 = {
+	0x00300e54,
+	"78Q2120",
+
+	(const phy_cmd_t []) {  /* config */
+#if 0
+		{ mk_mii_write(MII_78Q2120_VENDOR, 0x0140), NULL },
+#endif
+		{ mk_mii_read(MII_REG_CR), mii_parse_cr },
+		{ mk_mii_read(MII_REG_ANAR), mii_parse_anar },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {  /* startup - enable interrupts */
+		/* Link Status Change Interrupt Enable */
+		{ mk_mii_write(MII_78Q2120_ICSR, 0x0400), NULL },
+		{ mk_mii_write(MII_REG_CR, 0x1200), NULL }, /* autonegotiate */
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) { /* ack_int */
+		/* read SR and ICSR to acknowledge */
+		{ mk_mii_read(MII_78Q2120_ICSR), NULL },
+		{ mk_mii_read(MII_REG_SR), mii_parse_sr },
+		/* find out the current status */
+		{ mk_mii_read(MII_78Q2120_DIAG), mii_parse_78q2120_diag },
+		{ mk_mii_end, }
+	},
+	(const phy_cmd_t []) {  /* shutdown - disable interrupts */
+		{ mk_mii_write(MII_78Q2120_ICSR, 0x0000), NULL },
+		{ mk_mii_end, }
+	},
+};
+
+#endif	/* CONFIG_FEC_78Q2120 */
+
+
 /* -------------------------------------------------------------------- */
 /* The National Semiconductor DP83843BVJE is used on a Mediatrix board  */
 /* -------------------------------------------------------------------- */
@@ -1197,6 +1265,10 @@
 	&phy_info_lxt971,
 #endif /* CONFIG_FEC_LXT971 */
 
+#ifdef CONFIG_FEC_78Q2120
+	&phy_info_78q2120,
+#endif /* CONFIG_FEC_78Q2120 */
+
 #ifdef CONFIG_FEC_QS6612
 	&phy_info_qs6612,
 #endif /* CONFIG_FEC_LXT971 */
@@ -1751,6 +1823,7 @@
 	eap = (unsigned char *)my_enet_addr;
 	iap = bd->bi_enetaddr;
 
+#ifndef CONFIG_OBS50
 #ifdef CONFIG_SCC_ENET
 	/*
          * If a board has Ethernet configured both on a SCC and the
@@ -1764,6 +1837,7 @@
 	tmpaddr[3] |= 0x80;
 	iap = tmpaddr;
 #endif
+#endif /* CONFIG_OBS50 */
 
 	for (i=0; i<6; i++) {
 		dev->dev_addr[i] = *eap++ = *iap++;
diff -Naru linux-2.4.28.orig/arch/ppc/8xx_io/uart.c linux-2.4.28/arch/ppc/8xx_io/uart.c
--- linux-2.4.28.orig/arch/ppc/8xx_io/uart.c	2003-11-29 03:26:19.000000000 +0900
+++ linux-2.4.28/arch/ppc/8xx_io/uart.c	2005-01-31 11:52:56.000000000 +0900
@@ -16,6 +16,11 @@
  * This module exports the following rs232 io functions:
  *
  *	int rs_8xx_init(void);
+ *
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Modified for OpenBlockS 50
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 
 #include <linux/config.h>
@@ -78,6 +83,13 @@
 #define CONFIG_SERIAL_CONSOLE_PORT	2
 #endif
 
+/* SCC1 for console
+*/
+#ifdef CONFIG_OBS50
+#undef CONFIG_SERIAL_CONSOLE_PORT
+#define CONFIG_SERIAL_CONSOLE_PORT	1
+#endif
+
 #define TX_WAKEUP	ASYNC_SHARE_IRQ
 
 static char *serial_name = "CPM UART driver";
@@ -2695,11 +2707,18 @@
 	 */
 #ifdef CONFIG_USE_SCC_IO
 #ifndef CONFIG_MBX
+#ifdef CONFIG_OBS50
+	/* Port A for SCC1 serial port */
+	immap->im_ioport.iop_papar |=  0x0003;
+	immap->im_ioport.iop_padir &= ~0x0003;
+	immap->im_ioport.iop_paodr &= ~0x0003;
+#else
 	/* The "standard" configuration through the 860.
 	*/
 	immap->im_ioport.iop_papar |= 0x00fc;
 	immap->im_ioport.iop_padir &= ~0x00fc;
 	immap->im_ioport.iop_paodr &= ~0x00fc;
+#endif /* CONFIG_OBS50 */
 #else
 	/* On the MBX, SCC3 is through Port D.
 	*/
diff -Naru linux-2.4.28.orig/arch/ppc/boot/images/Makefile linux-2.4.28/arch/ppc/boot/images/Makefile
--- linux-2.4.28.orig/arch/ppc/boot/images/Makefile	2003-11-29 03:26:19.000000000 +0900
+++ linux-2.4.28/arch/ppc/boot/images/Makefile	2005-01-31 11:52:56.000000000 +0900
@@ -9,4 +9,4 @@
 	gzip -vf9 vmlinux
 
 clean:
-	rm -f sImage vmapus vmlinux* miboot* zImage* zvmlinux* uImage
+	rm -f sImage vmapus vmlinux* miboot* zImage* zvmlinux* uImage*
diff -Naru linux-2.4.28.orig/arch/ppc/boot/simple/Makefile linux-2.4.28/arch/ppc/boot/simple/Makefile
--- linux-2.4.28.orig/arch/ppc/boot/simple/Makefile	2004-02-18 22:36:30.000000000 +0900
+++ linux-2.4.28/arch/ppc/boot/simple/Makefile	2005-01-31 11:52:56.000000000 +0900
@@ -14,6 +14,9 @@
 # (2) For machine targets which use the mktree program you can optionally
 # set ENTRYPOINT which the image should be loaded at.  The optimal setting
 # for ENTRYPOINT is the link address.
+#
+#	PlatHome <openlab.plathome.co.jp>
+#		- added for OpenBlockS 50
 
 USE_STANDARD_AS_RULE		:= true
 
@@ -112,9 +115,14 @@
 obj-$(CONFIG_MBX)		+= iic.o
 obj-$(CONFIG_RPXCLASSIC)	+= iic.o
 obj-$(CONFIG_RPXLITE)		+= iic.o
+obj-$(CONFIG_OBS50)		+= iic.o
 # Different boards need different serial implementations.
 ifeq ($(CONFIG_SERIAL_CONSOLE),y)
+ifeq ($(CONFIG_OBS50),y)
+obj-$(CONFIG_OBS50)		+= m8xx_obs_tty.o
+else
 obj-$(CONFIG_8xx)		+= m8xx_tty.o
+endif
 obj-$(CONFIG_8260)		+= m8260_tty.o
 obj-$(CONFIG_SERIAL)		+= ../common/ns16550.o
 endif
diff -Naru linux-2.4.28.orig/arch/ppc/boot/simple/embed_config.c linux-2.4.28/arch/ppc/boot/simple/embed_config.c
--- linux-2.4.28.orig/arch/ppc/boot/simple/embed_config.c	2004-04-14 22:05:27.000000000 +0900
+++ linux-2.4.28/arch/ppc/boot/simple/embed_config.c	2005-01-31 11:52:56.000000000 +0900
@@ -5,6 +5,15 @@
  * under  the terms of  the GNU General  Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Add the board information structure for Century's board
+ *	2001-12-25 ozawa CONFIG_OBSS
+ *	Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *		- Added for OpenBlockS 50
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *		- Modified CONFIG_OBS to CONFIG_OBS50
  */
 
 #include <linux/types.h>
@@ -22,6 +31,26 @@
 #if defined(CONFIG_405GP) || defined(CONFIG_NP405H) || defined(CONFIG_NP405L)
 #include <linux/netdevice.h>
 #endif
+#ifdef CONFIG_OBS200
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+#include <asm/serial.h>
+#endif
+#ifdef CONFIG_OBS50
+#include <asm/spinlock.h>
+#include <linux/time.h>
+#include <linux/mc146818rtc.h>
+#include <asm/commproc.h>
+#endif
+
+#if defined(CONFIG_OBS200) || defined(CONFIG_OBS50)
+#ifdef CONFIG_SERIAL_CONSOLE_BAUD
+#define SERIAL_BAUD    CONFIG_SERIAL_CONSOLE_BAUD
+#else
+#define SERIAL_BAUD    9600
+#endif /* CONFIG_SERIAL_CONSOLE_BAUD */
+#endif /* CONFIG_OBS200 || CONFIG_OBS50 */
+
 extern unsigned long timebase_period_ns;
 
 /* For those boards that don't provide one.
@@ -616,6 +645,64 @@
 }
 #endif /* ADS8260 */
 
+#ifdef CONFIG_OBS50
+#define	M24C16_ADDR	0xa0
+#define	DS1307_ADDR	0xd0
+void
+embed_config(bd_t **bdp)
+{
+	u_char  *cp;
+	int     i;
+	u_char		eebuf[128];
+	unsigned int	year, mon, day, hour, min, sec;
+	unsigned long	time;
+	bd_t	*bd;
+
+	bd = &bdinfo;
+	*bdp = bd;
+
+	/* get mac address from iic serial eeprom */
+	i = 0x780; /* last 128[byte] */
+	iic_read(M24C16_ADDR | (i >> 7), eebuf, i, 128);
+
+	cp = (u_char *)&eebuf[0x58];
+	for (i = 0; i < 6; i++)
+		bd->bi_enetaddr[i] = cp[i];
+
+	cp = (u_char *)&eebuf[0x5e];
+	for (i = 0; i < 6; i++)
+		bd->bi_enet1addr[i] = cp[i];
+
+	/* get time from iic serial rtc */
+	iic_read(DS1307_ADDR, eebuf, 0, 8);
+	sec = eebuf[0];
+	min = eebuf[1];
+	hour = eebuf[2];
+	day = eebuf[4];
+	mon = eebuf[5];
+	year = eebuf[6];
+	BCD_TO_BIN(sec);
+	BCD_TO_BIN(min);
+	BCD_TO_BIN(hour);
+	BCD_TO_BIN(day);
+	BCD_TO_BIN(mon);
+	BCD_TO_BIN(year);
+	year += ((year >= 70) ? 1900 : 2000);
+	time = mktime(year, mon, day, hour, min, sec);
+	((volatile immap_t *)IMAP_ADDR)->im_sitk.sitk_rtck = KAPWR_KEY;
+	((volatile immap_t *)IMAP_ADDR)->im_sit.sit_rtc = time;
+	((volatile immap_t *)IMAP_ADDR)->im_sitk.sitk_rtck = ~KAPWR_KEY;
+
+	/* The rest of this should come from the environment as well.
+	*/
+	bd->bi_memstart = 0;
+	bd->bi_memsize = (16 * 1024 * 1024);
+	bd->bi_intfreq = 49152000;
+	bd->bi_busfreq = 49152000;
+	bd->bi_baudrate = SERIAL_BAUD;
+}
+#endif /* CONFIG_OBS50 */
+
 #ifdef CONFIG_WILLOW
 void
 embed_config(bd_t **bdp)
@@ -650,6 +737,46 @@
 }
 #endif /* WILLOW */
 
+#if defined(CONFIG_OBS200)
+
+extern void (outb)(int port, unsigned char val);
+
+void
+embed_config(bd_t **bdp)
+{
+	bd_t	*bd;
+
+	bd = &bdinfo;
+	*bdp = bd;
+
+	switch (*OBSS_RAM_SIZE) {
+		case 4: case 8: case 16: case 32: case 64: case 128:
+			bd->bi_memsize = *OBSS_RAM_SIZE * 0x00100000; break;
+		default:
+			bd->bi_memsize = 64 * 0x00100000;	/* assume 64MB */
+	}
+	bd->bi_intfreq = 0x0bebc200;				/* 200MHz */
+	bd->bi_busfreq = 0x05f5e100;				/* 100MHz */
+	bd->bi_pci_busfreq = 0x01f78a40;			/*  33MHz */
+	bd->bi_enetaddr[0] = OBSS_ENET_MACADDR[0];
+	bd->bi_enetaddr[1] = OBSS_ENET_MACADDR[1];
+	bd->bi_enetaddr[2] = OBSS_ENET_MACADDR[2];
+	bd->bi_enetaddr[3] = OBSS_ENET_MACADDR[3];
+	bd->bi_enetaddr[4] = OBSS_ENET_MACADDR[4];
+	bd->bi_enetaddr[5] = OBSS_ENET_MACADDR[5];
+
+	/* preinit UART0 */
+	/* Input clock. */
+	(outb)(UART0_IO_BASE+UART_LCR, 0x80);
+	(outb)(UART0_IO_BASE+UART_DLL, (BASE_BAUD / SERIAL_BAUD));
+	(outb)(UART0_IO_BASE+UART_DLM, (BASE_BAUD / SERIAL_BAUD) >> 8);
+	/* 8 data, 1 stop, no parity */
+	(outb)(UART0_IO_BASE+UART_LCR, 0x03);
+	/* RTS/DTR */
+	(outb)(UART0_IO_BASE+UART_MCR, 0x03);
+}
+#else /* CONFIG_OBS200 */
+
 #ifdef CONFIG_IBM_OPENBIOS
 /* This could possibly work for all treeboot roms.
 */
@@ -713,6 +840,7 @@
 	}
 }
 #endif
+#endif /* CONFIG_OBS200 */
 
 #ifdef CONFIG_EP405
 void
diff -Naru linux-2.4.28.orig/arch/ppc/boot/simple/m8xx_obs_tty.c linux-2.4.28/arch/ppc/boot/simple/m8xx_obs_tty.c
--- linux-2.4.28.orig/arch/ppc/boot/simple/m8xx_obs_tty.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/boot/simple/m8xx_obs_tty.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,318 @@
+/* Minimal serial functions needed to send messages out the serial
+ * port on the MBX console.
+ *
+ * The MBX uxes SMC1 for the serial port.  We reset the port and use
+ * only the first BD that EPPC-Bug set up as a character FIFO.
+ *
+ * Later versions (at least 1.4, maybe earlier) of the MBX EPPC-Bug
+ * use COM1 instead of SMC1 as the console port.  This kinda sucks
+ * for the rest of the kernel, so here we force the use of SMC1 again.
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <asm/uaccess.h>
+#include <asm/mpc8xx.h>
+#include <asm/commproc.h>
+
+#define PROFF_CONS	PROFF_SCC1
+#define CPM_CR_CH_CONS	CPM_CR_CH_SCC1
+#define SCC_INDEX	0
+
+/*
+ * ---------------------------------------------------------------
+ * for OpenBlockS
+ * Copyright (C) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *
+ *	input:
+ *		MODCK[1-2] = "11"    ... x5 clock mode(default)
+ *		EXTCLK     = 4.096 [MHz]
+ *	result:
+ *		OSCCLK     = 4.096 [MHz]
+ *		VCOOUT     = 49.152 [MHz] = OSCCLK x (11 + 1)
+ *		GCLK1/2/C  = 49.152 [MHz]
+ *		GCLK1/2_50 = 49.152 [MHz]
+ *		CLKOUT     = 49.152 [MHz]
+ *		BRGCLK     = 49.152 [MHz]
+ *		SYNCCLK    = 49.152 [MHz]
+ *		TMBCLK     =  3.072 [MHz] = GCLK2 / 16
+ *		PITRTCLK   =  8.000 [kHz] = EXTCLK / 512
+ * ---------------------------------------------------------------
+ */
+
+static
+void init_cpm(bd_t *bd)
+{
+	volatile	cpm8xx_t	*cp;
+	volatile	immap_t		*immap;
+
+	immap = (immap_t *)IMAP_ADDR;
+	cp = (cpm8xx_t *)&(immap->im_cpm);
+
+	/* CPM reset already done in iic_read() */
+	/* cp->cp_cpcr = 0x8001; */
+
+	/*
+	 * SCC1 for serial port.
+	 */
+
+	/* Port A for SCC1 serial port. */
+	immap->im_ioport.iop_paodr &=  ~0x0003;
+	immap->im_ioport.iop_padir &=  ~0x0003;
+	immap->im_ioport.iop_papar |=   0x0003;
+
+	/* Port B */
+/*	cp->cp_pbodr  =  0; */
+	cp->cp_pbdat  =  0x3c00b;
+	cp->cp_pbdir |=  0x3c00f;	/* I/O port. 7-SEG LED output */
+	cp->cp_pbpar &= ~0x3c00f;
+
+	/* Port C */
+/*	immap->im_ioport.iop_pcdat = 0; */
+	immap->im_ioport.iop_pcdir &= ~0x030;
+/*	immap->im_ioport.iop_pcint = 0; */
+	immap->im_ioport.iop_pcso  &= ~0x030;
+	immap->im_ioport.iop_pcpar &= ~0x030;
+
+	/*
+	 * BRG
+	 */
+	cp->cp_brgc1 =
+		((((bd->bi_intfreq /** 1000000*/)/16)/ bd->bi_baudrate) << 1)
+		| CPM_BRG_EN;
+
+	/* Enable SDMA. */
+	immap->im_sdma.sdma_sdsr = 0x83;
+	immap->im_siu_conf.sc_sdcr = 0x00000001;
+
+	/*
+	 * SI Global Mode Register
+	 * 	ENB (4)         = 0     ...disable TDMb
+	 * 	ENA (5)         = 0     ...disable TDMa
+	 * 	RDM (6-7        = 0     ...RAM division mode.Static.
+	 */
+	cp->cp_sigmr = 0;
+
+	/*
+	 * Set the value of SI Mode Register
+	 * 	SMC2,SMC2CS,SDMb,RFSDb          (0-7)   = 0 000(BRG1) 00 00
+	 * 	DSCb,CRTb,STZb,CEb,FEb,GMb,TFSDb(8-15)  = 000000 00
+	 * 	SMC1,SMC1CS,SDMa,RFSDa          (16-23) = 0 000(BRG1) 00 00
+	 * 	DSCa,CRTa,STZa,CEa,FEa,GMa,TFSDa(24-31) = 000000 00
+	 */
+	cp->cp_simode = 0x00000000;
+
+	/*
+	 * SI Clock Route Register
+	 * 	GR4,SC4,R4CS,T4CS(0-7)       = 00 000 000 (BRG1:BRG1)
+	 * 	GR3,SC3,R3CS,T3CS(8-15)      = 00 000 000 (BRG1:BRG1)
+	 * 	GR2,SC2,R2CS,T2CS(16-23)     = 00 000 000 (BRG1:BRG1)
+	 * 	GR1,SC1,R1CS,T1CS(24-31)     = 00 000 000 (BRG1:BRG1)
+	 */
+	cp->cp_sicr = 0x0;	/* FIXME */
+}
+
+static
+void init_scc1uart(void)
+{
+	uint		dp_addr, mem_addr;
+	volatile	cbd_t		*bdp;
+	volatile	cpm8xx_t	*cp;
+	volatile	scc_t		*scp;
+	volatile	scc_uart_t	*sup;
+
+
+/*	cp = cpmp;	** Get pointer to Communication Processor */
+	cp = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+
+	scp = &cp->cp_scc[SCC_INDEX];
+	sup = (scc_uart_t *)&cp->cp_dparam[PROFF_CONS];
+
+	/* Allocate space for two buffer descriptors in the DP ram.
+	*/
+	dp_addr = 0x0800;	/* m8xx_cpm_dpalloc(sizeof(cbd_t) * 2); */
+
+	/* Allocate space for two 2 byte FIFOs in the host memory.
+	*/
+	mem_addr = 0x880;	/* m8xx_cpm_hostalloc(8); */
+
+	/* Set the physical address of the host memory buffers in
+	 * the buffer descriptors.
+	 */
+	bdp = (cbd_t *)&cp->cp_dpmem[dp_addr];
+
+/*	bdp->cbd_bufaddr = __pa(mem_addr); */
+/*	(bdp+1)->cbd_bufaddr = __pa(mem_addr+4); */
+	bdp->cbd_bufaddr = mem_addr;
+	(bdp+1)->cbd_bufaddr = mem_addr+4;
+
+	/* For the receive, set empty and wrap.
+	 * For transmit, set wrap.
+	 */
+	bdp->cbd_sc = BD_SC_EMPTY | BD_SC_WRAP;
+	(bdp+1)->cbd_sc = BD_SC_WRAP;
+
+	/* Set up the uart parameters in the parameter ram.
+	*/
+	sup->scc_genscc.scc_rbase = dp_addr;
+	sup->scc_genscc.scc_tbase = dp_addr + sizeof(cbd_t);
+
+	/* Set up the uart parameters in the
+	 * parameter ram.
+	 */
+	sup->scc_genscc.scc_rfcr = SMC_EB;
+	sup->scc_genscc.scc_tfcr = SMC_EB;
+
+	/* Set this to 1 for now, so we get single
+	 * character interrupts.  Using idle charater
+	 * time requires some additional tuning.
+	 */
+	sup->scc_genscc.scc_mrblr = 1;
+	sup->scc_maxidl = 0;
+	sup->scc_brkcr = 1;
+	sup->scc_parec = 0;
+	sup->scc_frmec = 0;
+	sup->scc_nosec = 0;
+	sup->scc_brkec = 0;
+	sup->scc_uaddr1 = 0;
+	sup->scc_uaddr2 = 0;
+	sup->scc_toseq = 0;
+	sup->scc_char1 = 0x8000;
+	sup->scc_char2 = 0x8000;
+	sup->scc_char3 = 0x8000;
+	sup->scc_char4 = 0x8000;
+	sup->scc_char5 = 0x8000;
+	sup->scc_char6 = 0x8000;
+	sup->scc_char7 = 0x8000;
+	sup->scc_char8 = 0x8000;
+	sup->scc_rccm = 0xc0ff;
+
+	/* Send the CPM an initialize command.
+	*/
+	cp->cp_cpcr = mk_cr_cmd(CPM_CR_CH_CONS, CPM_CR_INIT_TRX) | CPM_CR_FLG;
+	while (cp->cp_cpcr & CPM_CR_FLG) {
+		*(volatile unsigned long *)0xff000ac4 ^= 2;
+	}
+
+
+	/* Set UART mode, 8 bit, no parity, one stop.
+	 * Enable receive and transmit.
+	 */
+	scp->scc_gsmrh = 0;
+	scp->scc_gsmrl =
+		(SCC_GSMRL_MODE_UART | SCC_GSMRL_TDCR_16 | SCC_GSMRL_RDCR_16);
+
+	/* Disable all interrupts and clear all pending
+	 * events.
+	 */
+	scp->scc_sccm = 0;
+	scp->scc_scce = 0xffff;
+	scp->scc_dsr = 0x7e7e;
+	scp->scc_pmsr = 0x3000;
+
+	scp->scc_gsmrl |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);
+}
+
+
+void
+serial_putc(void *ignored, const char c)
+{
+	volatile cbd_t		*bdp;
+	volatile cpm8xx_t	*cp;
+	volatile scc_uart_t	*sup;
+#if 0
+	if (c == '\n')
+		serial_putc(0, '\r');
+#endif
+	cp  = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+	sup = (scc_uart_t *)&cp->cp_dparam[PROFF_CONS];
+	bdp = (cbd_t *)&cp->cp_dpmem[sup->scc_genscc.scc_tbase];
+
+	/* Wait for last character to go.
+	*/
+	while (bdp->cbd_sc & BD_SC_READY)
+		;
+
+	*((char *)bdp->cbd_bufaddr) = c;
+	bdp->cbd_datlen = 1;
+	bdp->cbd_sc |= BD_SC_READY;
+}
+
+char
+serial_getc(void *ignored)
+{
+	volatile cbd_t		*rbdf;
+	volatile cpm8xx_t	*cp;
+	volatile scc_uart_t	*sup;
+	volatile char		*buf;
+	char			c;
+
+	cp  = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+	sup = (scc_uart_t *)&cp->cp_dparam[PROFF_CONS];
+	rbdf = (cbd_t *)&cp->cp_dpmem[sup->scc_genscc.scc_rbase];
+
+	/* Wait for character to show up.
+	*/
+	buf = (char *)rbdf->cbd_bufaddr;
+	while (rbdf->cbd_sc & BD_SC_EMPTY)
+		;
+	c = *buf;
+	rbdf->cbd_sc |= BD_SC_EMPTY;
+
+	return c;
+}
+
+int
+serial_tstc(void *ignored)
+{
+	volatile cbd_t		*rbdf;
+	volatile cpm8xx_t	*cp;
+	volatile scc_uart_t	*sup;
+
+	cp  = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+	sup = (scc_uart_t *)&cp->cp_dparam[PROFF_CONS];
+	rbdf = (cbd_t *)&cp->cp_dpmem[sup->scc_genscc.scc_rbase];
+
+	return !(rbdf->cbd_sc & BD_SC_EMPTY);
+}
+
+void puthex(unsigned long val);
+
+unsigned long
+serial_init(int ignored, bd_t *bd)
+{
+	volatile	immap_t		*immap;
+
+	immap = (immap_t *)IMAP_ADDR;
+
+	/*
+	 * siu initial
+	 */
+	/* TBS, RTDIV and RTSEL */
+	immap->im_clkrst.car_sccr = 0x03800000;
+	/* MF = 11 */
+	immap->im_clkrst.car_plprcr = 11 * (0x80000000 >> 11);
+	/* SWTC max, BMT max, BME, SWRI and SWP */
+	immap->im_siu_conf.sc_sypcr = 0xFFFF0000 | 0xFF00 | 0x83;
+	immap->im_sit.sit_tbscr = TBSCR_TBE;	/* for udelay() */
+
+	/*
+	 * for boot time console
+	 */
+	init_cpm(bd);
+	init_scc1uart();	/* use SCC1 port as UART */
+
+	/*
+	 * CPM Interrupt Configuration
+	 */
+	immap->im_cpic.cpic_cicr =
+	    (CICR_SCD_SCC4 | CICR_SCC_SCC3 | CICR_SCB_SCC2 | CICR_SCA_SCC1) |
+		((5/2) << 13) | CICR_HP_MASK;
+	immap->im_cpic.cpic_cimr = 0;
+	immap->im_cpic.cpic_cipr = 0x00000000;
+	immap->im_cpic.cpic_cisr = 0xFFFFFFFF;
+
+	serial_putc(0, '\n');
+	serial_putc(0, '\n');
+
+	return 0;
+}
diff -Naru linux-2.4.28.orig/arch/ppc/boot/simple/misc-embedded.c linux-2.4.28/arch/ppc/boot/simple/misc-embedded.c
--- linux-2.4.28.orig/arch/ppc/boot/simple/misc-embedded.c	2003-11-29 03:26:19.000000000 +0900
+++ linux-2.4.28/arch/ppc/boot/simple/misc-embedded.c	2005-01-31 11:52:56.000000000 +0900
@@ -10,6 +10,15 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  *
+ *	Century <www.centurysys.co.jp>
+ *		- Set the root file system and board memory size
+ *		- Move command line args higher on memory for larger kernels
+ *	2001-12-25 ozawa CONFIG_OBSS
+ *	2002-03-21 ozawa restructuring for OpenBlockSS
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *		- Added for OpenBlockS 50
+ *		- Added for OpenBlockS 266
  */
 
 #include <linux/config.h>
@@ -19,10 +28,17 @@
 #include <asm/ibm4xx.h>
 #include <asm/mmu.h>
 #include <asm/mpc8xx.h>
+#ifdef CONFIG_OBS50
+#include <asm/8xx_immap.h>
+#endif
 #include <asm/mpc8260.h>
 #include <asm/page.h>
 #include <asm/processor.h>
 #include <asm/residual.h>
+#ifdef CONFIG_OBS200
+#include <asm/segled_obs200.h>
+#define OPNT ((volatile unsigned char *)(0x40000000))
+#endif
 
 #include "nonstdio.h"
 #include "zlib.h"
@@ -62,7 +78,58 @@
 char compiled_string[] = CONFIG_CMDLINE;
 #endif
 char ramroot_string[] = "root=/dev/ram";
+#ifdef CONFIG_OBS50
+char hdroot_string[] = "root=/dev/hda1";
+#endif
+#ifdef CONFIG_OBS200
+char netroot_string[] = "root=/dev/hda1";
+#else
 char netroot_string[] = "root=/dev/nfs rw ip=on";
+#endif
+
+#ifdef CONFIG_OBS266
+char eeprom_root_string[30] = { 0 };
+static int get_root_parameter(bd_t *b, char *str)
+{
+	int i;
+	char *p = str;
+
+	if (b == NULL) return 1;	/* something error */
+
+#if 0	/* for debug */
+	puts("\n[");
+	for (i = 0; i < sizeof(b->bi_r_version); i++) {
+		puts(" ");
+		puthex(b->bi_r_version[i]);
+	}
+	puts("]\n");
+#endif
+	for (i = 0; i < sizeof(b->bi_r_version); i++) {
+		if (b->bi_r_version[i] == '\0') goto found;
+	}
+	return 2;	/* no null termination */
+found:
+	*p = '\0';
+	for (i += 1; i < sizeof(b->bi_r_version); i++) {
+		*p++ = b->bi_r_version[i];
+		if (b->bi_r_version[i] == '\0') {
+			if (p == str) return 3; /* Maybe old ROM Monitor... */
+			return 0;	/* OK */
+		}
+	}
+	return 4;	/* too long */
+}
+
+static int is_pushsw(bd_t *b)
+{
+#define PUSHSW_INT	26
+	if (mfdcr(DCRN_UIC_SR(UIC0)) & (1 << (31 - PUSHSW_INT))) {
+		b->bi_s_version[0] = '\0';
+		return 1;
+	}
+	return 0;
+}
+#endif
 
 /* Serial port to use. */
 unsigned long com_port;
@@ -78,6 +145,12 @@
 extern void flush_instruction_cache(void);
 extern void gunzip(void *, int, unsigned char *, int *);
 extern void embed_config(bd_t **bp);
+#ifdef CONFIG_OBS200
+extern void _printk(char const *fmt, ...);
+#endif
+#ifdef CONFIG_OBS50
+extern void serial_close(unsigned long com_port);
+#endif
 
 /* Weak function for boards which don't need to build the
  * board info struct because they are using PPCBoot/U-Boot.
@@ -103,7 +176,37 @@
 	 * initialize the serial console port.
 	 */
 	embed_config(&bp);
+#ifdef CONFIG_OBS200
+	/* Display a zero */
+	*OPNT = (unsigned char)~(SL_V0);
+#endif
 	com_port = serial_init(0, bp);
+#ifdef CONFIG_OBS200
+	_printk("[decompress_kernel] Ramsize %dMB (0x%08x)\n",
+		bp->bi_memsize/0x00100000, bp->bi_memsize);
+#ifdef CONFIG_CMDLINE_BOOL
+	initrd_size = 0;
+#else
+	switch (*OBSS_BOOT_MODE) {
+		case 0:
+			puts("[decompress_kernel] Entering initrd mode. Root FS: ram disk\n");
+			initrd_size = (unsigned long)(&__ramdisk_end)
+				- (unsigned long)(&__ramdisk_begin);
+			bp->bi_r_version[0] = 0x01;
+			break;
+		case 1:
+			puts("[decompress_kernel] Entering hard disk mode. Root FS: hard disk\n");
+			initrd_size = 0;
+			bp->bi_r_version[0] = 0x00;
+			break;
+		default:
+			puts("[decompress_kernel] Entering recover mode. Root FS: ram disk\n");
+			initrd_size = (unsigned long)(&__ramdisk_end)
+				- (unsigned long)(&__ramdisk_begin);
+			bp->bi_r_version[0] = 0x00;
+	}
+#endif	/* CONFIG_CMDLINE_BOOL */
+#endif	/* CONFIG_OBS200 */
 
 	/* copy board data */
 	if (bp)
@@ -143,8 +246,10 @@
 	zimage_size = (unsigned long)(&__image_end) -
 			(unsigned long)(&__image_begin);
 
+#ifndef CONFIG_OBS200
 	initrd_size = (unsigned long)(&__ramdisk_end) -
 		(unsigned long)(&__ramdisk_begin);
+#endif
 
 	/*
 	 * The zImage and initrd will be between start and _end, so they've
@@ -169,7 +274,9 @@
 
 	puts("avail ram:     "); puthex((unsigned long)avail_ram); puts(" ");
 	puthex((unsigned long)end_avail); puts("\n");
+#ifndef CONFIG_OBS50
 	puts("\nLinux/PPC load: ");
+#endif
 	cp = cmd_line;
 	/* This is where we try and pick the right command line for booting.
 	 * If we were given one at compile time, use it.  It Is Right.
@@ -179,10 +286,47 @@
 #ifdef CONFIG_CMDLINE_BOOL
 	memcpy (cmd_line, compiled_string, sizeof(compiled_string));
 #else
+#ifdef CONFIG_OBS50
+	/* DipSW setup */
+	((immap_t *)IMAP_ADDR)->im_ioport.iop_papar &= ~0xc000;
+	((immap_t *)IMAP_ADDR)->im_ioport.iop_padir &= ~0xc000;
+
+	if (initrd_size) {
+		/*
+		 * Kernel command line select by DipSW.
+		 * hdroot or ramroot.
+		 */
+		puts("check dipsw:   ");
+		if ((((immap_t *)IMAP_ADDR)->im_ioport.iop_padat & 0xc000) != 0x0000) {
+			puts("hdroot\n");
+			memcpy (cmd_line, hdroot_string, sizeof(hdroot_string));
+		} else {
+			puts("ramroot\n");
+			memcpy (cmd_line, ramroot_string, sizeof(ramroot_string));
+		}
+	} else {
+		/*
+		 * Not initrd, pick up hdroot.
+		 * FIXME: I want nfsroot.
+		 */
+		memcpy (cmd_line, hdroot_string, sizeof(hdroot_string));
+	}
+#else
 	if ( initrd_size )
 		memcpy (cmd_line, ramroot_string, sizeof(ramroot_string));
 	else
 		memcpy (cmd_line, netroot_string, sizeof(netroot_string));
+#endif /* CONFIG_OBS50 */
+#endif
+#ifdef CONFIG_OBS50
+	puts("\nLinux/PPC load: ");
+#endif
+#ifdef CONFIG_OBS266
+	if (!is_pushsw(hold_residual) && get_root_parameter(bp, eeprom_root_string) == 0) {
+		int len = strlen(eeprom_root_string);
+		memcpy (cmd_line, "root=/dev/", 10);
+		memcpy (cmd_line + 10, eeprom_root_string, len + 1);
+	}
 #endif
 	while ( *cp )
 		putc(*cp++);
@@ -191,7 +335,12 @@
 	 * If they have a console, allow them to edit the command line.
 	 * Otherwise, don't bother wasting the five seconds.
 	 */
-	while (timer++ < 5*1000) {
+#ifdef CONFIG_OBS266
+#define BOOT_WAIT_TIME (10*1000)	/* real 2sec */
+#else
+#define BOOT_WAIT_TIME (15*1000)
+#endif
+	while (timer++ < BOOT_WAIT_TIME) {
 		if (tstc()) {
 			while ((ch = getc()) != '\n' && ch != '\r') {
 				if (ch == '\b' || ch == '\177') {
@@ -218,8 +367,16 @@
 	*cp = 0;
 	puts("\nUncompressing Linux...");
 
+#ifdef CONFIG_OBS50
+	gunzip(0, 0x100000, zimage_start, &zimage_size);
+#else
 	gunzip(0, 0x400000, zimage_start, &zimage_size);
+#endif
 	flush_instruction_cache();
+#ifdef CONFIG_OBS200
+	/* Display a one */
+	*OPNT = (unsigned char)~(SL_V1);
+#endif
 	puts("done.\n");
 	{
 		struct bi_record *rec;
diff -Naru linux-2.4.28.orig/arch/ppc/config.in linux-2.4.28/arch/ppc/config.in
--- linux-2.4.28.orig/arch/ppc/config.in	2004-08-08 08:26:04.000000000 +0900
+++ linux-2.4.28/arch/ppc/config.in	2005-01-31 11:52:56.000000000 +0900
@@ -2,6 +2,12 @@
 # For a description of the syntax of this configuration file,
 # see Documentation/kbuild/config-language.txt.
 #
+#	PlatHome <openlab.plathome.co.jp>
+#		- Added CONFIG_OBS50
+#		- Added CONFIG_OBS2xx
+#		- Added CONFIG_OBS200
+#		- Added CONFIG_OBS266
+#
 define_bool CONFIG_UID16 n
 define_bool CONFIG_RWSEM_GENERIC_SPINLOCK n
 define_bool CONFIG_RWSEM_XCHGADD_ALGORITHM y
@@ -76,7 +82,10 @@
 	 Redwood-5	CONFIG_REDWOOD_5 	\
 	 Redwood-6	CONFIG_REDWOOD_6 	\
 	 Oak		CONFIG_OAK		\
-	 Walnut		CONFIG_WALNUT"		Walnut
+	 OpenBlockS200	CONFIG_OBS200		\
+	 OpenBlockS266	CONFIG_OBS266		\
+	 Walnut		CONFIG_WALNUT		\
+ 	 Xilinx-ML300	CONFIG_XILINX_ML300"	OpenBlockS266
 
    if [ "$CONFIG_EP405" = "y" ]; then
       bool 'EP405PC Support' CONFIG_EP405PC
@@ -110,7 +119,8 @@
 	 IVML24		CONFIG_IVML24		\
 	 SM850		CONFIG_SM850		\
 	 MBX		CONFIG_MBX		\
-	 WinCept	CONFIG_WINCEPT"		RPX-Lite
+	 WinCept	CONFIG_WINCEPT		\
+	 OpenBlockS50	CONFIG_OBS50"		OpenBlockS50
 
   if [ "$CONFIG_TQM823L" = "y" -o \
        "$CONFIG_TQM850L" = "y" -o \
@@ -213,6 +223,30 @@
     define_bool CONFIG_403GCX y
   fi
 
+   if [ "$CONFIG_EBK405GPR" = "y" ]; then
+     define_bool CONFIG_405GP y
+     define_bool CONFIG_BIOS_FIXUP y
+     define_bool CONFIG_IBM_OPENBIOS y
+     define_bool CONFIG_IBM405_ERR77 y
+     define_bool CONFIG_IBM_OCP y
+   fi
+   if [ "$CONFIG_OBS200" = "y" ]; then
+     define_bool CONFIG_405GP y
+     define_bool CONFIG_BIOS_FIXUP y
+     define_bool CONFIG_IBM_OPENBIOS y
+     define_bool CONFIG_IBM405_ERR77 y
+     define_bool CONFIG_IBM_OCP y
+     define_bool CONFIG_OBS2xx y
+     define_int CONFIG_SERIAL_CONSOLE_BAUD 9600
+   fi
+   if [ "$CONFIG_OBS266" = "y" ]; then
+     define_bool CONFIG_405GP y
+     define_bool CONFIG_BIOS_FIXUP y
+     define_bool CONFIG_IBM_OPENBIOS y
+     define_bool CONFIG_IBM405_ERR77 y
+     define_bool CONFIG_IBM_OCP y
+     define_bool CONFIG_OBS2xx y
+   fi
   if [ "$CONFIG_REDWOOD_5" = "y" -o "$CONFIG_REDWOOD_6" = "y" ]; then
     define_bool CONFIG_STB03xxx y
   fi
@@ -298,6 +332,11 @@
 if [ "$CONFIG_8xx" = "y" -o "$CONFIG_8260" = "y" ]; then
     define_bool CONFIG_EMBEDDEDBOOT y
 fi
+if [ "$CONFIG_8xx" = "y" ]; then
+  if [ "$CONFIG_OBS50" = "y" ]; then
+    	define_int CONFIG_SERIAL_CONSOLE_BAUD 9600
+  fi
+fi
 endmenu
 
 mainmenu_option next_comment
diff -Naru linux-2.4.28.orig/arch/ppc/configs/ebk405gpr_defconfig linux-2.4.28/arch/ppc/configs/ebk405gpr_defconfig
--- linux-2.4.28.orig/arch/ppc/configs/ebk405gpr_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/configs/ebk405gpr_defconfig	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,538 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+# CONFIG_UID16 is not set
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Platform support
+#
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_440 is not set
+# CONFIG_POWER3 is not set
+# CONFIG_8xx is not set
+# CONFIG_PPC_ISERIES is not set
+CONFIG_4xx=y
+# CONFIG_PPC_STD_MMU is not set
+# CONFIG_ASH is not set
+# CONFIG_CEDER is not set
+# CONFIG_BEECH is not set
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_OAK is not set
+# CONFIG_RAINIER is not set
+# CONFIG_REDWOOD_4 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_SYCAMORE is not set
+# CONFIG_TIVO is not set
+# CONFIG_WALNUT is not set
+CONFIG_EBK405GPR=y
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_ALL_PPC is not set
+# CONFIG_SMP is not set
+# CONFIG_MATH_EMULATION is not set
+CONFIG_405GP=y
+CONFIG_BIOS_FIXUP=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM_OCP=y
+# CONFIG_PM is not set
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_GEN550_KGDB=y
+CONFIG_IBM405_ERR51=y
+CONFIG_NOT_COHERENT_CACHE=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_OCP_PROC=y
+
+#
+# General setup
+#
+# CONFIG_HIGHMEM is not set
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_PCI=y
+# CONFIG_PC_KEYBOARD is not set
+CONFIG_NET=y
+CONFIG_SYSCTL=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_KCORE_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_KERNEL_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_PCI_NAMES is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+CONFIG_PPC_RTC=y
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+# CONFIG_IDE is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MACE is not set
+# CONFIG_BMAC is not set
+# CONFIG_GMAC is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Backplane Networking
+#
+# CONFIG_NPNET is not set
+
+#
+# On-chip net devices
+#
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Console drivers
+#
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL=y
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_IBM_OCP is not set
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_PROC is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+CONFIG_IBM_OCP_GPIO=y
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# IBM 4xx options
+#
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Library routines
+#
+# CONFIG_ZLIB_INFLATE is not set
+# CONFIG_ZLIB_DEFLATE is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_SERIAL_TEXT_DEBUG=y
diff -Naru linux-2.4.28.orig/arch/ppc/configs/obs200_defconfig linux-2.4.28/arch/ppc/configs/obs200_defconfig
--- linux-2.4.28.orig/arch/ppc/configs/obs200_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/configs/obs200_defconfig	2005-01-31 11:54:29.000000000 +0900
@@ -0,0 +1,1252 @@
+#
+# Automatically generated make config: don't edit
+#
+# CONFIG_UID16 is not set
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
+
+#
+# Platform support
+#
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+CONFIG_4xx=y
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_OAK is not set
+CONFIG_OBS200=y
+# CONFIG_OBS266 is not set
+# CONFIG_WALNUT is not set
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_SMP is not set
+CONFIG_MATH_EMULATION=y
+CONFIG_NOT_COHERENT_CACHE=y
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_405GP=y
+CONFIG_BIOS_FIXUP=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM_OCP=y
+CONFIG_OBS2xx=y
+CONFIG_SERIAL_CONSOLE_BAUD=9600
+CONFIG_IBM_OCP=y
+CONFIG_PPC_OCP=y
+CONFIG_405=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM405_ERR77=y
+# CONFIG_PPC4xx_DMA is not set
+
+#
+# General setup
+#
+# CONFIG_HIGHMEM is not set
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_PCI=y
+# CONFIG_PC_KEYBOARD is not set
+CONFIG_NET=y
+CONFIG_SYSCTL=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_KCORE_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_KERNEL_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_OOM_KILLER is not set
+CONFIG_PCI_NAMES=y
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+CONFIG_CARDBUS=y
+CONFIG_TCIC=y
+CONFIG_I82092=y
+CONFIG_I82365=y
+
+#
+# Parallel port support
+#
+CONFIG_PARPORT=m
+CONFIG_PARPORT_PC=m
+CONFIG_PARPORT_PC_CML1=m
+# CONFIG_PARPORT_SERIAL is not set
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+CONFIG_PARPORT_PC_PCMCIA=m
+# CONFIG_PARPORT_AMIGA is not set
+# CONFIG_PARPORT_MFC3 is not set
+# CONFIG_PARPORT_ATARI is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_SUNBPP is not set
+# CONFIG_PARPORT_IP22 is not set
+# CONFIG_PARPORT_OTHER is not set
+# CONFIG_PARPORT_1284 is not set
+# CONFIG_GEN_RTC is not set
+CONFIG_PPC_RTC=y
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=m
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_PARTITIONS is not set
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_CHAR is not set
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_GEN_PROBE is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_TQM8XXL is not set
+# CONFIG_MTD_RPXLITE is not set
+# CONFIG_MTD_MBX860 is not set
+# CONFIG_MTD_DBOX2 is not set
+# CONFIG_MTD_CFI_FLAGADM is not set
+# CONFIG_MTD_REDWOOD is not set
+# CONFIG_MTD_PCI is not set
+CONFIG_MTD_PCMCIA=m
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_TEST is not set
+CONFIG_CIPHERS=y
+
+#
+# 128 bit blocksize
+#
+CONFIG_CIPHER_AES=m
+
+#
+# 64 bit blocksize
+#
+CONFIG_CIPHER_3DES=m
+
+#
+# Deprecated
+#
+CONFIG_CIPHER_NULL=m
+CONFIG_CIPHER_DES=m
+CONFIG_DIGESTS=y
+CONFIG_DIGEST_MD5=m
+CONFIG_DIGEST_SHA1=m
+CONFIG_CRYPTODEV=y
+CONFIG_CRYPTOLOOP=m
+CONFIG_CRYPTOLOOP_ATOMIC=y
+# CONFIG_CRYPTOLOOP_IV_HACK is not set
+# CONFIG_CRYPTOLOOP_DEBUG is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+# CONFIG_NET_NEIGH_DEBUG is not set
+# CONFIG_NET_RESTRICTED_REUSE is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IPSEC=y
+# CONFIG_IPSEC_DEBUG is not set
+CONFIG_IPCOMP=y
+CONFIG_IPSEC_TUNNEL=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPIP_IPV6=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_IP_IPSEC is not set
+CONFIG_IPV4_IPSEC_TUNNEL=y
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+CONFIG_IP_NF_FTP=y
+CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_IRC=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_LIMIT=y
+CONFIG_IP_NF_MATCH_MAC=y
+CONFIG_IP_NF_MATCH_PKTTYPE=y
+CONFIG_IP_NF_MATCH_MARK=y
+CONFIG_IP_NF_MATCH_MULTIPORT=y
+CONFIG_IP_NF_MATCH_TOS=y
+# CONFIG_IP_NF_MATCH_RECENT is not set
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_DSCP=y
+CONFIG_IP_NF_MATCH_AH_ESP=y
+CONFIG_IP_NF_MATCH_LENGTH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_TCPMSS=y
+CONFIG_IP_NF_MATCH_HELPER=y
+CONFIG_IP_NF_MATCH_STATE=y
+CONFIG_IP_NF_MATCH_CONNTRACK=y
+CONFIG_IP_NF_MATCH_UNCLEAN=y
+CONFIG_IP_NF_MATCH_OWNER=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_MIRROR=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_NAT_LOCAL=y
+CONFIG_IP_NF_NAT_SNMP_BASIC=y
+CONFIG_IP_NF_NAT_IRC=y
+CONFIG_IP_NF_NAT_FTP=y
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_TOS=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_DSCP=y
+CONFIG_IP_NF_TARGET_MARK=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_TARGET_TCPMSS=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+# CONFIG_IP_NF_ARP_MANGLE is not set
+
+#
+#   IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_DEBUG is not set
+CONFIG_IPV6_DROP_FAKE_V4MAPPED=y
+CONFIG_IPV6_RESTRICTED_DOUBLE_BIND=y
+# CONFIG_IPV6_6TO4_NEXTHOP is not set
+# CONFIG_IPV6_PRIVACY is not set
+CONFIG_IPV6_ANYCAST=y
+CONFIG_IPV6_ANYCAST_GROUP=y
+# CONFIG_IPV6_ISATAP is not set
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_MLD6_ALL_DONE is not set
+# CONFIG_IPV6_NODEINFO is not set
+
+#
+#   IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IPV6_IPSEC is not set
+# CONFIG_IPV6_IPCOMP is not set
+CONFIG_IPV6_IPSEC_TUNNEL=y
+# CONFIG_IPV6_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MOBILITY is not set
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+CONFIG_ATALK=m
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+CONFIG_BLK_DEV_IDECS=m
+CONFIG_BLK_DEV_DELKIN=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
+# CONFIG_BLK_DEV_ATARAID_SII is not set
+
+#
+# SCSI support
+#
+CONFIG_SCSI=m
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_SD_EXTRA_DEVS=40
+CONFIG_CHR_DEV_ST=m
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SR_EXTRA_DEVS=2
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_ULI is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_DMA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_PPA is not set
+# CONFIG_SCSI_IMM is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NCR53C7xx is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_NCR53C8XX is not set
+# CONFIG_SCSI_SYM53C8XX is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+CONFIG_SCSI_PCMCIA=y
+CONFIG_PCMCIA_AHA152X=m
+# CONFIG_PCMCIA_FDOMAIN is not set
+CONFIG_PCMCIA_NINJA_SCSI=m
+CONFIG_PCMCIA_QLOGIC=m
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MACE is not set
+# CONFIG_BMAC is not set
+# CONFIG_GMAC is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=m
+# CONFIG_PCNET32_VMWARE is not set
+# CONFIG_AMD8111_ETH is not set
+CONFIG_ADAPTEC_STARFIRE=m
+# CONFIG_APRICOT is not set
+CONFIG_B44=m
+# CONFIG_CS89x0 is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_DE4X5 is not set
+CONFIG_DGRS=m
+# CONFIG_DM9102 is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_EEPRO100_PIO is not set
+CONFIG_E100=m
+# CONFIG_LNE390 is not set
+CONFIG_FEALNX=m
+CONFIG_NATSEMI=m
+CONFIG_NE2K_PCI=m
+CONFIG_FORCEDETH=m
+# CONFIG_NE3210 is not set
+# CONFIG_ES3210 is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+CONFIG_8139TOO_TUNE_TWISTER=y
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_SIS900=m
+CONFIG_EPIC100=m
+CONFIG_SUNDANCE=m
+# CONFIG_SUNDANCE_MMIO is not set
+CONFIG_TLAN=m
+CONFIG_VIA_RHINE=m
+# CONFIG_VIA_RHINE_MMIO is not set
+CONFIG_WINBOND_840=m
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+CONFIG_ACENIC=m
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+CONFIG_DL2K=m
+CONFIG_E1000=m
+# CONFIG_E1000_NAPI is not set
+# CONFIG_MYRI_SBUS is not set
+CONFIG_NS83820=m
+CONFIG_HAMACHI=m
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=m
+CONFIG_SK98LIN=m
+CONFIG_TIGON3=m
+
+#
+# On-chip net devices
+#
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_STRIP is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_ARLAN is not set
+# CONFIG_AIRONET4500 is not set
+# CONFIG_AIRONET4500_NONCS is not set
+# CONFIG_AIRONET4500_PROC is not set
+# CONFIG_AIRO is not set
+CONFIG_HERMES=m
+# CONFIG_PLX_HERMES is not set
+# CONFIG_TMD_HERMES is not set
+CONFIG_PCI_HERMES=m
+
+#
+# Wireless Pcmcia cards support
+#
+CONFIG_PCMCIA_HERMES=m
+CONFIG_AIRO_CS=m
+CONFIG_PCMCIA_ATMEL=m
+
+#
+# Prism54 PCI/PCMCIA GT/Duette Driver - 802.11(a/b/g)
+#
+CONFIG_PRISM54=m
+CONFIG_NET_WIRELESS=y
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+CONFIG_PCMCIA_3C589=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_PCMCIA_PCNET=m
+CONFIG_PCMCIA_AXNET=m
+CONFIG_PCMCIA_NMCLAN=m
+CONFIG_PCMCIA_SMC91C92=m
+CONFIG_PCMCIA_XIRC2PS=m
+# CONFIG_ARCNET_COM20020_CS is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_PCMCIA_XIRTULIP is not set
+CONFIG_NET_PCMCIA_RADIO=y
+CONFIG_PCMCIA_RAYCS=m
+CONFIG_PCMCIA_NETWAVE=m
+CONFIG_PCMCIA_WAVELAN=m
+# CONFIG_AIRONET4500_CS is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Console drivers
+#
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_UINPUT is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL=y
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+CONFIG_N_HDLC=y
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+# CONFIG_PRINTER is not set
+# CONFIG_PPDEV is not set
+# CONFIG_TIPAR is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200 is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_OBS200_PUSHSW=y
+CONFIG_OBS200_SLED=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+CONFIG_PCMCIA_SERIAL_CS=m
+CONFIG_SYNCLINK_CS=m
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+
+#
+# Video For Linux
+#
+CONFIG_VIDEO_PROC_FS=y
+# CONFIG_I2C_PARPORT is not set
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_BWQCAM is not set
+# CONFIG_VIDEO_CQCAM is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_TUNER_3036 is not set
+# CONFIG_VIDEO_STRADIS is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_ZORAN_BUZ is not set
+# CONFIG_VIDEO_ZORAN_DC10 is not set
+# CONFIG_VIDEO_ZORAN_LML33 is not set
+# CONFIG_VIDEO_ZR36120 is not set
+# CONFIG_VIDEO_MEYE is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_GEMTEK_PCI is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+# CONFIG_RADIO_MIROPCM20 is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+CONFIG_JBD_DEBUG=y
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_TRACE is not set
+# CONFIG_XFS_DEBUG is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_ROOT_NFS is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+CONFIG_NLS_CODEPAGE_932=y
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_MIDI is not set
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_ACM=y
+CONFIG_USB_PRINTER=y
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=m
+# CONFIG_USB_HIDINPUT is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_KBD=m
+CONFIG_USB_MOUSE=m
+CONFIG_USB_AIPTEK=m
+CONFIG_USB_WACOM=m
+CONFIG_USB_KBTAB=m
+CONFIG_USB_POWERMATE=m
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_DC2XX=m
+CONFIG_USB_MDC800=m
+CONFIG_USB_SCANNER=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USB_HPUSBSCSI=m
+
+#
+# USB Multimedia devices
+#
+CONFIG_USB_IBMCAM=m
+CONFIG_USB_KONICAWC=m
+# CONFIG_USB_OV511 is not set
+CONFIG_USB_PWC=m
+CONFIG_USB_SE401=m
+CONFIG_USB_STV680=m
+# CONFIG_USB_W9968CF is not set
+CONFIG_USB_VICAM=m
+CONFIG_USB_DSBR=m
+CONFIG_USB_DABUSB=m
+
+#
+# USB Network adaptors
+#
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_CATC=m
+CONFIG_USB_CDCETHER=m
+CONFIG_USB_USBNET=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_USS720=m
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_SERIAL_DEBUG is not set
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OMNINET=m
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_FW_LOADER=y
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=0
diff -Naru linux-2.4.28.orig/arch/ppc/configs/obs266_defconfig linux-2.4.28/arch/ppc/configs/obs266_defconfig
--- linux-2.4.28.orig/arch/ppc/configs/obs266_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/configs/obs266_defconfig	2005-01-31 11:54:40.000000000 +0900
@@ -0,0 +1,1321 @@
+#
+# Automatically generated make config: don't edit
+#
+# CONFIG_UID16 is not set
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
+
+#
+# Platform support
+#
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_6xx is not set
+CONFIG_40x=y
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+CONFIG_4xx=y
+# CONFIG_CPCI405 is not set
+# CONFIG_EP405 is not set
+# CONFIG_REDWOOD_5 is not set
+# CONFIG_REDWOOD_6 is not set
+# CONFIG_OAK is not set
+# CONFIG_OBS200 is not set
+CONFIG_OBS266=y
+# CONFIG_WALNUT is not set
+# CONFIG_XILINX_ML300 is not set
+# CONFIG_SMP is not set
+CONFIG_MATH_EMULATION=y
+CONFIG_NOT_COHERENT_CACHE=y
+CONFIG_UART0_TTYS0=y
+# CONFIG_UART0_TTYS1 is not set
+CONFIG_405GP=y
+CONFIG_BIOS_FIXUP=y
+CONFIG_IBM_OPENBIOS=y
+CONFIG_IBM405_ERR77=y
+CONFIG_IBM_OCP=y
+CONFIG_OBS2xx=y
+CONFIG_IBM_OCP=y
+CONFIG_PPC_OCP=y
+CONFIG_405=y
+CONFIG_IBM405_ERR51=y
+CONFIG_IBM405_ERR77=y
+CONFIG_PPC4xx_DMA=y
+CONFIG_PPC4xx_EDMA=y
+
+#
+# General setup
+#
+# CONFIG_HIGHMEM is not set
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+CONFIG_PCI=y
+# CONFIG_PC_KEYBOARD is not set
+CONFIG_NET=y
+CONFIG_SYSCTL=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_KCORE_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_KERNEL_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_OOM_KILLER is not set
+CONFIG_PCI_NAMES=y
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+CONFIG_CARDBUS=y
+CONFIG_TCIC=y
+CONFIG_I82092=y
+CONFIG_I82365=y
+
+#
+# Parallel port support
+#
+CONFIG_PARPORT=m
+CONFIG_PARPORT_PC=m
+CONFIG_PARPORT_PC_CML1=m
+# CONFIG_PARPORT_SERIAL is not set
+# CONFIG_PARPORT_PC_FIFO is not set
+# CONFIG_PARPORT_PC_SUPERIO is not set
+CONFIG_PARPORT_PC_PCMCIA=m
+# CONFIG_PARPORT_AMIGA is not set
+# CONFIG_PARPORT_MFC3 is not set
+# CONFIG_PARPORT_ATARI is not set
+# CONFIG_PARPORT_GSC is not set
+# CONFIG_PARPORT_SUNBPP is not set
+# CONFIG_PARPORT_IP22 is not set
+# CONFIG_PARPORT_OTHER is not set
+# CONFIG_PARPORT_1284 is not set
+# CONFIG_GEN_RTC is not set
+CONFIG_PPC_RTC=y
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+# CONFIG_MTD_CFI_NOSWAP is not set
+CONFIG_MTD_CFI_BE_BYTE_SWAP=y
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_CFI_B1=y
+CONFIG_MTD_CFI_B2=y
+CONFIG_MTD_CFI_B4=y
+# CONFIG_MTD_CFI_B8 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_TQM8XXL is not set
+# CONFIG_MTD_RPXLITE is not set
+# CONFIG_MTD_MBX860 is not set
+# CONFIG_MTD_DBOX2 is not set
+# CONFIG_MTD_CFI_FLAGADM is not set
+CONFIG_MTD_REDWOOD=y
+# CONFIG_MTD_PCI is not set
+CONFIG_MTD_PCMCIA=m
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=90112
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_TEST is not set
+CONFIG_CIPHERS=y
+
+#
+# 128 bit blocksize
+#
+CONFIG_CIPHER_AES=m
+
+#
+# 64 bit blocksize
+#
+CONFIG_CIPHER_3DES=m
+
+#
+# Deprecated
+#
+CONFIG_CIPHER_NULL=m
+CONFIG_CIPHER_DES=m
+CONFIG_DIGESTS=y
+CONFIG_DIGEST_MD5=m
+CONFIG_DIGEST_SHA1=m
+CONFIG_CRYPTODEV=y
+CONFIG_CRYPTOLOOP=m
+CONFIG_CRYPTOLOOP_ATOMIC=y
+# CONFIG_CRYPTOLOOP_IV_HACK is not set
+# CONFIG_CRYPTOLOOP_DEBUG is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+# CONFIG_NET_NEIGH_DEBUG is not set
+# CONFIG_NET_RESTRICTED_REUSE is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+# CONFIG_IPSEC is not set
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPIP_IPV6=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_IPV4_IPSEC_TUNNEL=y
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+CONFIG_IP_NF_FTP=y
+CONFIG_IP_NF_AMANDA=y
+CONFIG_IP_NF_TFTP=y
+CONFIG_IP_NF_IRC=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_LIMIT=y
+CONFIG_IP_NF_MATCH_MAC=y
+CONFIG_IP_NF_MATCH_PKTTYPE=y
+CONFIG_IP_NF_MATCH_MARK=y
+CONFIG_IP_NF_MATCH_MULTIPORT=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_RECENT=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_DSCP=y
+CONFIG_IP_NF_MATCH_AH_ESP=y
+CONFIG_IP_NF_MATCH_LENGTH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_TCPMSS=y
+CONFIG_IP_NF_MATCH_HELPER=y
+CONFIG_IP_NF_MATCH_STATE=y
+CONFIG_IP_NF_MATCH_CONNTRACK=y
+CONFIG_IP_NF_MATCH_UNCLEAN=y
+CONFIG_IP_NF_MATCH_OWNER=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_MIRROR=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_NAT_AMANDA=y
+CONFIG_IP_NF_NAT_LOCAL=y
+CONFIG_IP_NF_NAT_SNMP_BASIC=y
+CONFIG_IP_NF_NAT_IRC=y
+CONFIG_IP_NF_NAT_FTP=y
+CONFIG_IP_NF_NAT_TFTP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_TOS=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_DSCP=y
+CONFIG_IP_NF_TARGET_MARK=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_TARGET_TCPMSS=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+#   IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_DEBUG is not set
+CONFIG_IPV6_DROP_FAKE_V4MAPPED=y
+CONFIG_IPV6_RESTRICTED_DOUBLE_BIND=y
+# CONFIG_IPV6_6TO4_NEXTHOP is not set
+# CONFIG_IPV6_PRIVACY is not set
+CONFIG_IPV6_ANYCAST=y
+CONFIG_IPV6_ANYCAST_GROUP=y
+# CONFIG_IPV6_ISATAP is not set
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_MLD6_ALL_DONE is not set
+# CONFIG_IPV6_NODEINFO is not set
+
+#
+#   IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+CONFIG_IPV6_IPSEC_TUNNEL=y
+# CONFIG_IPV6_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MOBILITY is not set
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+CONFIG_ATALK=m
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_IDEDISK_STROKE=y
+CONFIG_BLK_DEV_IDECS=m
+CONFIG_BLK_DEV_DELKIN=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+CONFIG_BLK_DEV_IDEPCI=y
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_IDEPCI_SHARE_IRQ is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+CONFIG_IDEDMA_ONLYDISK=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_PCI_WIP is not set
+# CONFIG_BLK_DEV_ADMA100 is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_WDC_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_HPT34X_AUTODMA is not set
+CONFIG_BLK_DEV_HPT366=y
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_PDC202XX_BURST is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_BLK_DEV_SL82C105 is not set
+# CONFIG_IDE_CHIPSETS is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
+# CONFIG_BLK_DEV_ATARAID_SII is not set
+
+#
+# SCSI support
+#
+CONFIG_SCSI=m
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+CONFIG_SD_EXTRA_DEVS=40
+CONFIG_CHR_DEV_ST=m
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SR_EXTRA_DEVS=2
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_DEBUG_QUEUES is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_7000FASST is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_NV is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_ULI is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_DMA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_PPA is not set
+# CONFIG_SCSI_IMM is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_NCR53C7xx is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_NCR53C8XX is not set
+# CONFIG_SCSI_SYM53C8XX is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+CONFIG_SCSI_PCMCIA=y
+CONFIG_PCMCIA_AHA152X=m
+# CONFIG_PCMCIA_FDOMAIN is not set
+CONFIG_PCMCIA_NINJA_SCSI=m
+CONFIG_PCMCIA_QLOGIC=m
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MACE is not set
+# CONFIG_BMAC is not set
+# CONFIG_GMAC is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=m
+# CONFIG_PCNET32_VMWARE is not set
+# CONFIG_AMD8111_ETH is not set
+CONFIG_ADAPTEC_STARFIRE=m
+# CONFIG_APRICOT is not set
+CONFIG_B44=m
+# CONFIG_CS89x0 is not set
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_DE4X5 is not set
+CONFIG_DGRS=m
+# CONFIG_DM9102 is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_EEPRO100_PIO is not set
+CONFIG_E100=m
+# CONFIG_LNE390 is not set
+CONFIG_FEALNX=m
+CONFIG_NATSEMI=m
+CONFIG_NE2K_PCI=m
+CONFIG_FORCEDETH=m
+# CONFIG_NE3210 is not set
+# CONFIG_ES3210 is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_SIS900=m
+CONFIG_EPIC100=m
+CONFIG_SUNDANCE=m
+# CONFIG_SUNDANCE_MMIO is not set
+CONFIG_TLAN=m
+CONFIG_VIA_RHINE=m
+# CONFIG_VIA_RHINE_MMIO is not set
+CONFIG_WINBOND_840=m
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+CONFIG_ACENIC=m
+# CONFIG_ACENIC_OMIT_TIGON_I is not set
+CONFIG_DL2K=m
+CONFIG_E1000=m
+# CONFIG_E1000_NAPI is not set
+# CONFIG_MYRI_SBUS is not set
+CONFIG_NS83820=m
+CONFIG_HAMACHI=m
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=m
+CONFIG_SK98LIN=m
+CONFIG_TIGON3=m
+
+#
+# On-chip net devices
+#
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_STRIP is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_ARLAN is not set
+# CONFIG_AIRONET4500 is not set
+# CONFIG_AIRONET4500_NONCS is not set
+# CONFIG_AIRONET4500_PROC is not set
+# CONFIG_AIRO is not set
+CONFIG_HERMES=m
+# CONFIG_PLX_HERMES is not set
+# CONFIG_TMD_HERMES is not set
+CONFIG_PCI_HERMES=m
+
+#
+# Wireless Pcmcia cards support
+#
+CONFIG_PCMCIA_HERMES=m
+CONFIG_AIRO_CS=m
+CONFIG_PCMCIA_ATMEL=m
+
+#
+# Prism54 PCI/PCMCIA GT/Duette Driver - 802.11(a/b/g)
+#
+CONFIG_PRISM54=m
+CONFIG_NET_WIRELESS=y
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+CONFIG_PCMCIA_3C589=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_PCMCIA_PCNET=m
+CONFIG_PCMCIA_AXNET=m
+CONFIG_PCMCIA_NMCLAN=m
+CONFIG_PCMCIA_SMC91C92=m
+CONFIG_PCMCIA_XIRC2PS=m
+# CONFIG_ARCNET_COM20020_CS is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_PCMCIA_XIRTULIP is not set
+CONFIG_NET_PCMCIA_RADIO=y
+CONFIG_PCMCIA_RAYCS=m
+CONFIG_PCMCIA_NETWAVE=m
+CONFIG_PCMCIA_WAVELAN=m
+# CONFIG_AIRONET4500_CS is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Console drivers
+#
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_UINPUT is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL=y
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+CONFIG_N_HDLC=y
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+# CONFIG_PRINTER is not set
+# CONFIG_PPDEV is not set
+# CONFIG_TIPAR is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_ALGOPCF is not set
+CONFIG_I2C_IBM_OCP=y
+CONFIG_I2C_PPC405_ALGO=y
+CONFIG_I2C_PPC405_ADAP=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_PROC is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200 is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_X1226_RTC=y
+CONFIG_I2C_EEPROM=y
+CONFIG_OBS266_PUSHSW=y
+CONFIG_OBS266_LED=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+CONFIG_PCMCIA_SERIAL_CS=m
+CONFIG_SYNCLINK_CS=m
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+
+#
+# Video For Linux
+#
+CONFIG_VIDEO_PROC_FS=y
+# CONFIG_I2C_PARPORT is not set
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_BWQCAM is not set
+# CONFIG_VIDEO_CQCAM is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_TUNER_3036 is not set
+# CONFIG_VIDEO_STRADIS is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_ZORAN_BUZ is not set
+# CONFIG_VIDEO_ZORAN_DC10 is not set
+# CONFIG_VIDEO_ZORAN_LML33 is not set
+# CONFIG_VIDEO_ZR36120 is not set
+# CONFIG_VIDEO_MEYE is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_GEMTEK_PCI is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+# CONFIG_RADIO_MIROPCM20 is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+CONFIG_JBD_DEBUG=y
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_TRACE is not set
+# CONFIG_XFS_DEBUG is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_MIDI is not set
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=m
+# CONFIG_USB_HIDINPUT is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_KBD=m
+CONFIG_USB_MOUSE=m
+CONFIG_USB_AIPTEK=m
+CONFIG_USB_WACOM=m
+CONFIG_USB_KBTAB=m
+CONFIG_USB_POWERMATE=m
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_DC2XX=m
+CONFIG_USB_MDC800=m
+CONFIG_USB_SCANNER=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USB_HPUSBSCSI=m
+
+#
+# USB Multimedia devices
+#
+CONFIG_USB_IBMCAM=m
+CONFIG_USB_KONICAWC=m
+# CONFIG_USB_OV511 is not set
+CONFIG_USB_PWC=m
+CONFIG_USB_SE401=m
+CONFIG_USB_STV680=m
+CONFIG_USB_W9968CF=m
+CONFIG_USB_VICAM=m
+CONFIG_USB_DSBR=m
+CONFIG_USB_DABUSB=m
+
+#
+# USB Network adaptors
+#
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_CATC=m
+CONFIG_USB_CDCETHER=m
+CONFIG_USB_USBNET=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_USS720=m
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_SERIAL_DEBUG is not set
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OMNINET=m
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_FW_LOADER=y
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=0
diff -Naru linux-2.4.28.orig/arch/ppc/configs/obs50_defconfig linux-2.4.28/arch/ppc/configs/obs50_defconfig
--- linux-2.4.28.orig/arch/ppc/configs/obs50_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/configs/obs50_defconfig	2005-01-31 12:06:36.000000000 +0900
@@ -0,0 +1,689 @@
+#
+# Automatically generated make config: don't edit
+#
+# CONFIG_UID16 is not set
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
+
+#
+# Platform support
+#
+CONFIG_PPC=y
+CONFIG_PPC32=y
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+CONFIG_8xx=y
+CONFIG_SERIAL_CONSOLE=y
+CONFIG_NOT_COHERENT_CACHE=y
+# CONFIG_RPXLITE is not set
+# CONFIG_RPXCLASSIC is not set
+# CONFIG_BSEIP is not set
+# CONFIG_FADS is not set
+# CONFIG_DBOX2 is not set
+# CONFIG_TQM823L is not set
+# CONFIG_TQM850L is not set
+# CONFIG_TQM855L is not set
+# CONFIG_TQM860L is not set
+# CONFIG_FPS850L is not set
+# CONFIG_TQM860 is not set
+# CONFIG_SPD823TS is not set
+# CONFIG_IVMS8 is not set
+# CONFIG_IVML24 is not set
+# CONFIG_SM850 is not set
+# CONFIG_MBX is not set
+# CONFIG_WINCEPT is not set
+CONFIG_OBS50=y
+# CONFIG_SMP is not set
+CONFIG_MATH_EMULATION=y
+CONFIG_EMBEDDEDBOOT=y
+CONFIG_SERIAL_CONSOLE_BAUD=9600
+
+#
+# General setup
+#
+# CONFIG_HIGHMEM is not set
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+# CONFIG_ISA is not set
+# CONFIG_EISA is not set
+# CONFIG_SBUS is not set
+# CONFIG_MCA is not set
+# CONFIG_PCI_QSPAN is not set
+# CONFIG_PCI is not set
+CONFIG_NET=y
+CONFIG_SYSCTL=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_KCORE_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_KERNEL_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_OOM_KILLER is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_PPC_RTC is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=6144
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+# CONFIG_CIPHERS is not set
+# CONFIG_DIGESTS is not set
+# CONFIG_CRYPTODEV is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+# CONFIG_NET_NEIGH_DEBUG is not set
+# CONFIG_NET_RESTRICTED_REUSE is not set
+CONFIG_UNIX=y
+CONFIG_INET=y
+# CONFIG_IPSEC is not set
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPIP_IPV6=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_IPV4_IPSEC_TUNNEL=y
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_FTP=m
+# CONFIG_IP_NF_AMANDA is not set
+# CONFIG_IP_NF_TFTP is not set
+CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_MAC=m
+# CONFIG_IP_NF_MATCH_PKTTYPE is not set
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+# CONFIG_IP_NF_MATCH_RECENT is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_DSCP is not set
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+# CONFIG_IP_NF_MATCH_HELPER is not set
+CONFIG_IP_NF_MATCH_STATE=m
+# CONFIG_IP_NF_MATCH_CONNTRACK is not set
+CONFIG_IP_NF_MATCH_UNCLEAN=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_MIRROR=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+# CONFIG_IP_NF_NAT_LOCAL is not set
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+# CONFIG_IP_NF_ARP_MANGLE is not set
+CONFIG_IP_NF_COMPAT_IPCHAINS=m
+CONFIG_IP_NF_NAT_NEEDED=y
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+
+#
+#   IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_DEBUG is not set
+CONFIG_IPV6_DROP_FAKE_V4MAPPED=y
+CONFIG_IPV6_RESTRICTED_DOUBLE_BIND=y
+# CONFIG_IPV6_6TO4_NEXTHOP is not set
+# CONFIG_IPV6_PRIVACY is not set
+CONFIG_IPV6_ANYCAST=y
+CONFIG_IPV6_ANYCAST_GROUP=y
+# CONFIG_IPV6_ISATAP is not set
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_MLD6_ALL_DONE is not set
+# CONFIG_IPV6_NODEINFO is not set
+
+#
+#   IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+CONFIG_IPV6_IPSEC_TUNNEL=y
+# CONFIG_IPV6_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MOBILITY is not set
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_DELKIN is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+CONFIG_BLK_DEV_MPC8xx_IDE=y
+# CONFIG_IDE_8xx_PCCARD is not set
+# CONFIG_IDE_8xx_DIRECT is not set
+CONFIG_IDE_EXT_DIRECT=y
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
+# CONFIG_BLK_DEV_ATARAID_SII is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MACE is not set
+# CONFIG_BMAC is not set
+# CONFIG_GMAC is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Console drivers
+#
+
+#
+# Frame-buffer support
+#
+# CONFIG_FB is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_UINPUT is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+
+#
+# Input core support is needed for gameports
+#
+
+#
+# Input core support is needed for joysticks
+#
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200 is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_OBS50_PUSHSW=y
+CONFIG_OBS50_SLED=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_TRACE is not set
+# CONFIG_XFS_DEBUG is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_ROOT_NFS is not set
+CONFIG_NFSD=y
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# MPC8xx Options
+#
+
+#
+# Generic MPC8xx Options
+#
+CONFIG_8xx_COPYBACK=y
+# CONFIG_8xx_CPU6 is not set
+# CONFIG_UCODE_PATCH is not set
+
+#
+# MPC8xx CPM Options
+#
+CONFIG_SCC_ENET=y
+# CONFIG_SCC1_ENET is not set
+CONFIG_SCC2_ENET=y
+# CONFIG_SCC3_ENET is not set
+CONFIG_FEC_ENET=y
+CONFIG_USE_MDIO=y
+# CONFIG_FEC_ENET_BEFORE_SCC_ENET is not set
+CONFIG_ENET_BIG_BUFFERS=y
+CONFIG_8xx_SCC1=y
+# CONFIG_8xx_SCC2 is not set
+# CONFIG_8xx_SCC3 is not set
+# CONFIG_8xx_SCC4 is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=0
diff -Naru linux-2.4.28.orig/arch/ppc/kernel/m8xx_setup.c linux-2.4.28/arch/ppc/kernel/m8xx_setup.c
--- linux-2.4.28.orig/arch/ppc/kernel/m8xx_setup.c	2004-02-18 22:36:30.000000000 +0900
+++ linux-2.4.28/arch/ppc/kernel/m8xx_setup.c	2005-01-31 11:52:56.000000000 +0900
@@ -6,6 +6,9 @@
  *  Modified by Cort Dougan (cort@cs.nmt.edu)
  *  Modified for MBX using prep/chrp/pmac functions by Dan (dmalek@jlc.net)
  *  Further modified for generic 8xx by Dan.
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added for OpenBlockS 50
  */
 
 /*
@@ -60,6 +63,11 @@
 extern void m8xx_cpm_reset(uint);
 extern void m8xx_wdt_handler_install(bd_t *bp);
 
+#ifdef CONFIG_OBS50
+extern void obs_init(unsigned long r3, unsigned long r4, unsigned long r5,
+		unsigned long r6, unsigned long r7);
+#endif
+
 void __init
 m8xx_setup_arch(void)
 {
@@ -254,8 +262,8 @@
 
 	bp = (bd_t *)__res;
 
-	seq_printf(m, "clock\t\t: %dMHz\n"
-		   "bus clock\t: %dMHz\n",
+	seq_printf(m, "clock\t\t: %luMHz\n"
+		   "bus clock\t: %luMHz\n",
 		   bp->bi_intfreq / 1000000,
 		   bp->bi_busfreq / 1000000);
 
@@ -413,4 +421,7 @@
 #if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
 	m8xx_ide_init();
 #endif
+#if CONFIG_OBS50
+	obs_init(r3, r4, r5, r6, r7);
+#endif
 }
diff -Naru linux-2.4.28.orig/arch/ppc/kernel/ppc4xx_pic.c linux-2.4.28/arch/ppc/kernel/ppc4xx_pic.c
--- linux-2.4.28.orig/arch/ppc/kernel/ppc4xx_pic.c	2003-08-25 20:44:40.000000000 +0900
+++ linux-2.4.28/arch/ppc/kernel/ppc4xx_pic.c	2005-01-31 11:52:56.000000000 +0900
@@ -6,6 +6,9 @@
  *
  *    Description:
  *      Interrupt controller driver for PowerPC 4xx-based processors.
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added for OpenBlockSS 266
  */
 
 /*
@@ -155,6 +158,15 @@
 #ifdef UIC_DEBUG
 	printk("ppc405_uic_enable - irq %d word %d bit 0x%x\n", irq, word, bit);
 #endif
+
+#ifdef CONFIG_OBS266
+#define PUSHSW_INT 26
+	if (irq == PUSHSW_INT) {
+		/* printk(__FUNCTION__ ": TR=0x%08x\n", mfdcr(DCRN_UIC_TR(UIC0))); */
+		mtdcr(DCRN_UIC_TR(UIC0), 1 << (31 - PUSHSW_INT));
+		mtdcr(DCRN_UIC_SR(UIC0), 1 << (31 - PUSHSW_INT));
+	}
+#endif
 	ppc_cached_irq_mask[word] |= 1 << (31 - bit);
 	switch (word) {
 	case 0:
diff -Naru linux-2.4.28.orig/arch/ppc/kernel/ppc4xx_setup.c linux-2.4.28/arch/ppc/kernel/ppc4xx_setup.c
--- linux-2.4.28.orig/arch/ppc/kernel/ppc4xx_setup.c	2003-08-25 20:44:40.000000000 +0900
+++ linux-2.4.28/arch/ppc/kernel/ppc4xx_setup.c	2005-01-31 11:52:56.000000000 +0900
@@ -27,6 +27,10 @@
  *	History: 04/18/02 - Armin
  *	added ash to setting CETE bit in calibrate()
  *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added for OpenBlockS 266
+ *		- Added UPS control for OpenBlockS 266
+ *
  */
 
 #include <linux/config.h>
@@ -89,6 +93,16 @@
 extern void board_setup_irq(void);
 extern void board_init(void);
 
+#include <linux/delay.h>
+#define BLINK_MSEC (1000)
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+extern int obsled_out(int);
+#endif
+#if defined(CONFIG_OBS200)
+#include <asm/segled_obs200.h>
+static volatile unsigned char * OPNT;
+#endif
+
 /* Global Variables */
 unsigned char __res[sizeof (bd_t)];
 
@@ -207,7 +221,25 @@
 {
 	printk("System Halted\n");
 	__cli();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	UPS_poff();
+	while (1) {
+		obsled_out(7);
+		mdelay(BLINK_MSEC);
+		obsled_out(0);
+		mdelay(BLINK_MSEC);
+	}
+#elif defined(CONFIG_OBS200)
+	OPNT = ioremap(0x40000000, 4096);
+	while (1) {
+		*OPNT = (unsigned char)~(SL_V8);
+		mdelay(BLINK_MSEC);
+		*OPNT = (unsigned char)~(SL_DP);
+		mdelay(BLINK_MSEC);
+	}
+#else
 	while (1) ;
+#endif
 }
 
 static void __init
@@ -236,7 +268,8 @@
 	bd_t *bip = (bd_t *) __res;
 
 #if defined(CONFIG_WALNUT) || defined(CONFIG_CEDER) 	\
-	|| defined(CONFIG_ASH) || defined(CONFIG_SYCAMORE)
+	|| defined(CONFIG_ASH) || defined(CONFIG_SYCAMORE) \
+	|| defined(CONFIG_EBK405GPR) || defined(CONFIG_OBS266)
 	/* Openbios sets cpu  timers to CPU clk
 	 * we want to use the external clk
 	 * DCR CHCR1 (aka CPC0_CR1) bit CETE to 1 */
diff -Naru linux-2.4.28.orig/arch/ppc/kernel/todc_time.c linux-2.4.28/arch/ppc/kernel/todc_time.c
--- linux-2.4.28.orig/arch/ppc/kernel/todc_time.c	2003-08-25 20:44:40.000000000 +0900
+++ linux-2.4.28/arch/ppc/kernel/todc_time.c	2005-01-31 11:52:56.000000000 +0900
@@ -11,6 +11,9 @@
  * the terms of the GNU General Public License version 2.  This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
+ *
+ * 	PlatHome <openlab.plathome.co.jp>
+ *		- Modified for OpenBlockS 266
  */
 #include <linux/errno.h>
 #include <linux/init.h>
@@ -192,14 +195,28 @@
 todc_time_init(void)
 {
 	static u_char	not_initialized = 1;
+#ifdef CONFIG_OBS266
+	static char tmpbuf[10];
+	ppc_md.progress("todc_time_init:start\n", 0x332);
+	if(todc_info) {
+		sprintf(tmpbuf, "%x\n", (u32)todc_info->nvram_data);
+		ppc_md.progress(tmpbuf , 0x332);
+	}
+#endif
 
 	/* Make sure clocks are running */
 	if (not_initialized) {
 		u_char	cntl_b;
 
 		cntl_b = todc_read_val(todc_info->control_b);
+#ifdef CONFIG_OBS266
+		ppc_md.progress("todc_time_init:read_val\n", 0x332);
+#endif
 
 		if (todc_info->rtc_type == TODC_TYPE_MC146818) {
+#ifdef CONFIG_OBS266
+			ppc_md.progress("todc_time_init:MC146818\n", 0x332);
+#endif
 			if ((cntl_b & 0x70) != 0x20) {
 				printk(KERN_INFO "TODC %s %s\n",
 					"real-time-clock was stopped.",
@@ -213,6 +230,9 @@
 		else if (todc_info->rtc_type == TODC_TYPE_DS1501) {
 			u_char	month;
 
+#ifdef CONFIG_OBS266
+			ppc_md.progress("todc_time_init:DS1501\n", 0x332);
+#endif
 			todc_info->enable_read = TODC_DS1501_CNTL_B_TE;
 			todc_info->enable_write = TODC_DS1501_CNTL_B_TE;
 
@@ -232,6 +252,9 @@
 		else { /* must be a m48txx type */
 			u_char	cntl_a;
 
+#ifdef CONFIG_OBS266
+			ppc_md.progress("todc_time_init:M48TXX\n", 0x332);
+#endif
 			todc_info->enable_read = TODC_MK48TXX_CNTL_A_R;
 			todc_info->enable_write = TODC_MK48TXX_CNTL_A_W;
 
@@ -259,6 +282,9 @@
 		not_initialized = 0;
 	}
 
+#ifdef CONFIG_OBS266
+	ppc_md.progress("todc_time_init:end\n", 0x332);
+#endif
 
 	return 0;
 }
diff -Naru linux-2.4.28.orig/arch/ppc/kernel/traps.c linux-2.4.28/arch/ppc/kernel/traps.c
--- linux-2.4.28.orig/arch/ppc/kernel/traps.c	2004-04-14 22:05:27.000000000 +0900
+++ linux-2.4.28/arch/ppc/kernel/traps.c	2005-01-31 11:52:56.000000000 +0900
@@ -10,6 +10,9 @@
  *
  *  Modified by Cort Dougan (cort@cs.nmt.edu)
  *  and Paul Mackerras (paulus@cs.anu.edu.au)
+ *
+ * 	PlatHome <openlab.plathome.co.jp>
+ *		- Added dump_stack() as dummy.
  */
 
 /*
@@ -567,3 +570,9 @@
 void __init trap_init(void)
 {
 }
+
+void dump_stack(void)
+{
+	printk(KERN_NOTICE
+		"This architecture does not implement dump_stack()\n");
+}
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/Makefile linux-2.4.28/arch/ppc/platforms/Makefile
--- linux-2.4.28.orig/arch/ppc/platforms/Makefile	2004-08-08 08:26:04.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/Makefile	2005-01-31 11:52:56.000000000 +0900
@@ -6,6 +6,11 @@
 # unless it's something special (ie not a .c file).
 #
 # Note 2! The CFLAGS definitions are now in the main makefile...
+#
+#	PlatHome <openlab.plathome.co.jp>
+#		- Added CONFIG_OBS50
+#		- Added CONFIG_OBS200
+#		- Added CONFIG_OBS266
 
 USE_STANDARD_AS_RULE	:= true
 
@@ -39,7 +44,9 @@
 obj-$(CONFIG_EBONY)		+= ebony.o
 obj-$(CONFIG_OCOTEA)		+= ocotea.o
 obj-$(CONFIG_WALNUT)		+= walnut.o
-
+obj-$(CONFIG_OBS50)		+= obs50_i2clib.o obs50_setup.o obs50_time.o
+obj-$(CONFIG_OBS200)		+= obs200.o ibm405gp.o
+obj-$(CONFIG_OBS266)		+= obs266.o ibm405gp.o
 obj-$(CONFIG_APUS)		+= apus_setup.o
 ifeq ($(CONFIG_APUS),y)
 obj-$(CONFIG_PCI)		+= apus_pci.o
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/ebk405gpr.c linux-2.4.28/arch/ppc/platforms/ebk405gpr.c
--- linux-2.4.28.orig/arch/ppc/platforms/ebk405gpr.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/ebk405gpr.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,258 @@
+/*
+ *
+ *    Copyright (c) 2003 AXE,Inc.
+ *    ebk405gpr.c: Based on walnut.c
+ *
+ *    Copyrigh t(c) 1999-2000 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000-2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: walnut.c
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      IBM PowerPC 4xx based boards. Adapted from original
+ *      code by Gary Thomas, Cort Dougan <cort@fsmlabs.com>, and Dan Malek
+ *      <dan@net4x.com>.
+ *
+ *      History: 11/09/2001 - armin
+ *      added board_init to add in additional instuctions needed during platfrom_init
+ *
+ *      01/22/2002 - Armin
+ *      converted pci to ocp
+ *
+ *
+ * Please read the COPYING file for all license details.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/pci.h>
+#include <linux/rtc.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/todc.h>
+#include <platforms/ibm_ocp.h>
+
+#define DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+void *kb_cs;
+void *kb_data;
+void *ebk405gpr_rtc_base;
+
+/* Some IRQs unique to EBK405GPr.
+ * Used by the generic 405 PCI setup functions in ppc4xx_pci.c
+ */
+int __init
+ppc405_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	    /*
+	     *      PCI IDSEL/INTPIN->INTLINE
+	     *      A       B       C       D
+	     */
+	{
+		{28, 28, 28, 28},	/* IDSEL 1 - PCI slot 1 */
+		{29, 29, 29, 29},	/* IDSEL 2 - PCI slot 2 */
+		{30, 30, 30, 30},	/* IDSEL 3 - PCI slot 3 */
+		{31, 31, 31, 31},	/* IDSEL 4 - PCI slot 4 */
+	};
+
+	const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+
+void __init
+board_setup_arch(void)
+{
+#define EBK405GPR_PS2_BASE		0xF0100000
+#define EBK405GPR_FPGA_BASE	0xF0300000
+
+	void *fpga_brdc;
+	unsigned char fpga_brdc_data;
+	void *fpga_enable;
+	void *fpga_polarity;
+	void *fpga_status;
+	void *fpga_trigger;
+	
+	kb_data = ioremap(EBK405GPR_PS2_BASE, 8);
+	if (!kb_data) {
+		printk(KERN_CRIT
+		       "ebk405gpr_setup_arch() kb_data ioremap failed\n");
+		return;
+	}
+
+	kb_cs = kb_data + 1;
+
+	fpga_status = ioremap(EBK405GPR_FPGA_BASE, 8);
+	if (!fpga_status) {
+		printk(KERN_CRIT
+		       "ebk405gpr_setup_arch() fpga_status ioremap failed\n");
+		return;
+	}
+
+
+	fpga_enable = fpga_status + 1;
+	fpga_polarity = fpga_status + 2;
+	fpga_trigger = fpga_status + 3;
+	fpga_brdc = fpga_status + 4;
+
+	/* split the keyboard and mouse interrupts */
+	fpga_brdc_data = readb(fpga_brdc);
+	fpga_brdc_data |= 0x80;
+	writeb(fpga_brdc_data, fpga_brdc);
+	writeb(0x3, fpga_enable);
+
+	writeb(0x3, fpga_polarity);
+
+	writeb(0x3, fpga_trigger);
+
+	/* RTC step for the EBK405GPr */
+	ebk405gpr_rtc_base = (void *) EBK405GPR_RTC_VADDR;
+	TODC_INIT(TODC_TYPE_DS1743, ebk405gpr_rtc_base, ebk405gpr_rtc_base,
+		  ebk405gpr_rtc_base, 8);
+
+	/* Identify the system */
+	printk("IBM EBK405GPr port\n");
+	/* printk("IBM Walnut port (C) 2000-2002 MontaVista Software, Inc. (source@mvista.com)\n"); */
+}
+
+void __init
+bios_fixup(struct pci_controller *hose, struct pcil0_regs *pcip)
+{
+
+	unsigned int bar_response, bar;
+	/*
+	 * Expected PCI mapping:
+	 *
+	 *  PLB addr             PCI memory addr
+	 *  ---------------------       ---------------------
+	 *  0000'0000 - 7fff'ffff <---  0000'0000 - 7fff'ffff
+	 *  8000'0000 - Bfff'ffff --->  8000'0000 - Bfff'ffff
+	 *
+	 *  PLB addr             PCI io addr
+	 *  ---------------------       ---------------------
+	 *  e800'0000 - e800'ffff --->  0000'0000 - 0001'0000
+	 *
+	 * The following code is simplified by assuming that the bootrom
+	 * has been well behaved in following this mapping.
+	 */
+
+#ifdef DEBUG
+	int i;
+
+	printk("ioremap PCLIO_BASE = 0x%x\n", pcip);
+	printk("PCI bridge regs before fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+
+	/* added for IBM boot rom version 1.15 bios bar changes  -AK */
+
+	/* Disable region first */
+	out_le32((void *) &(pcip->pmm[0].ma), 0x00000000);
+	/* PLB starting addr, PCI: 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].la), 0x80000000);
+	/* PCI start addr, 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].pcila), PPC405_PCI_MEM_BASE);
+	/* 512MB range of PLB to PCI */
+	out_le32((void *) &(pcip->pmm[0].pciha), 0x00000000);
+	/* Enable no pre-fetch, enable region */
+	out_le32((void *) &(pcip->pmm[0].ma), ((0xffffffff -
+						(PPC405_PCI_UPPER_MEM -
+						 PPC405_PCI_MEM_BASE)) | 0x01));
+
+	/* Disable region one */
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm1ms), 0x00000000);
+
+	/* Disable region two */
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm2ms), 0x00000000);
+
+	/* Zero config bars */
+	for (bar = PCI_BASE_ADDRESS_1; bar <= PCI_BASE_ADDRESS_2; bar += 4) {
+		early_write_config_dword(hose, hose->first_busno,
+					 PCI_FUNC(hose->first_busno), bar,
+					 0x00000000);
+		early_read_config_dword(hose, hose->first_busno,
+					PCI_FUNC(hose->first_busno), bar,
+					&bar_response);
+		DBG("BUS %d, device %d, Function %d bar 0x%8.8x is 0x%8.8x\n",
+		    hose->first_busno, PCI_SLOT(hose->first_busno),
+		    PCI_FUNC(hose->first_busno), bar, bar_response);
+	}
+	/* end work arround */
+
+#ifdef DEBUG
+	printk("PCI bridge regs after fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+}
+
+void __init
+board_io_mapping(void)
+{
+	io_block_mapping(EBK405GPR_RTC_VADDR,
+			 EBK405GPR_RTC_PADDR, EBK405GPR_RTC_SIZE, _PAGE_IO);
+}
+
+void __init
+board_setup_irq(void)
+{
+}
+
+void __init
+board_init(void)
+{
+	ppc_md.time_init = todc_time_init;
+	ppc_md.set_rtc_time = todc_set_rtc_time;
+	ppc_md.get_rtc_time = todc_get_rtc_time;
+	ppc_md.nvram_read_val = todc_direct_read_val;
+	ppc_md.nvram_write_val = todc_direct_write_val;
+}
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/ebk405gpr.h linux-2.4.28/arch/ppc/platforms/ebk405gpr.h
--- linux-2.4.28.orig/arch/ppc/platforms/ebk405gpr.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/ebk405gpr.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,92 @@
+/*
+ *
+ *    Copyright (c) 2003 AXE,Inc.
+ *    ebk405gpr.h: Based on walnut.h
+ *
+ *    Copyright (c) 1999 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000 MontaVista Software Inc.
+ *	PPC405 modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	frank_rowand@mvista.com or source@mvista.com
+ * 	   	debbie_chu@mvista.com
+ *
+ *    Module name: ppc405.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      based boards.
+ *
+ *      This includes:
+ *
+ *         405GP "Walnut" evaluation board
+ *
+ * Please read the COPYING file for all license details.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_EBK405GPR_H__
+#define __ASM_EBK405GPR_H__
+
+/* We have a 405GPr core */
+#include <platforms/ibm405gp.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * Data structure defining board information maintained by the boot
+ * ROM on IBM's "EBK405GPr" evaluation board. An effort has been made to
+ * keep the field names consistent with the 8xx 'bd_t' board info
+ * structures.
+ */
+
+typedef struct board_info {
+	unsigned char	 bi_s_version[4];	/* Version of this structure */
+	unsigned char	 bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	 bi_memsize;		/* DRAM installed, in bytes */
+	unsigned char	 bi_enetaddr[6];	/* Local Ethernet MAC address */
+	unsigned char	 bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
+	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+} bd_t;
+
+/* Some 4xx parts use a different timebase frequency from the internal clock.
+*/
+#define bi_tbfreq bi_intfreq
+
+
+/* Memory map for the IBM "EBK405GPr" 405GPr evaluation board.
+ * Generic 4xx plus RTC.
+ */
+
+extern void *ebk405gpr_rtc_base;
+#define EBK405GPR_RTC_PADDR	((uint)0xf0000000)
+#define EBK405GPR_RTC_VADDR	EBK405GPR_RTC_PADDR
+#define EBK405GPR_RTC_SIZE	((uint)8*1024)
+
+/* ps2 keyboard and mouse */
+#define KEYBOARD_IRQ		25
+#define AUX_IRQ			26
+
+#ifdef CONFIG_PPC405GP_INTERNAL_CLOCK
+#define BASE_BAUD		201600
+#else
+#define BASE_BAUD		691200
+#endif
+
+#define EBK405GPR_PS2_BASE	0xF0100000
+#define EBK405GPR_FPGA_BASE	0xF0300000
+
+
+extern void *kb_cs;
+extern void *kb_data;
+#define kbd_read_input()	readb(kb_data)
+#define kbd_read_status()	readb(kb_cs)
+#define kbd_write_output(val)	writeb(val, kb_data)
+#define kbd_write_command(val)	writeb(val, kb_cs)
+
+#define PPC4xx_MACHINE_NAME	"IBM EBK405GPr"
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_EBK405GPR_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/ibm405gp.h linux-2.4.28/arch/ppc/platforms/ibm405gp.h
--- linux-2.4.28.orig/arch/ppc/platforms/ibm405gp.h	2004-02-18 22:36:30.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/ibm405gp.h	2005-01-31 11:52:56.000000000 +0900
@@ -78,7 +78,9 @@
 #define EBIU_BASE_START	0xF0100000
 
 /* serial port defines */
-#define RS_TABLE_SIZE	2
+/*     #define RS_TABLE_SIZE   2  */
+/* Add 2 more Table for pcmcia 2003/06/26 todoroki@platc2.co.jp */
+#define RS_TABLE_SIZE  4
 
 #define UART0_INT	0
 #define UART1_INT	1
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs200.c linux-2.4.28/arch/ppc/platforms/obs200.c
--- linux-2.4.28.orig/arch/ppc/platforms/obs200.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs200.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,570 @@
+/*
+ *
+ *    Copyright (c) 2002 OZAWA Takahiro <obss@ozawa.cc>
+ *      derived from walnut.c and ppc4xx_setup.c
+ *
+ *    Copyrigh t(c) 1999-2000 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000-2001 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: obs200.c
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      IBM PowerPC 4xx based boards. Adapted from original
+ *      code by Gary Thomas, Cort Dougan <cort@fsmlabs.com>, and Dan Malek
+ *      <dan@net4x.com>.
+ *
+ *      History: 11/09/2001 - armin
+ *      added board_init to add in additional instuctions needed during platfrom_init
+ *
+ *      01/22/2002 - Armin
+ *      converted pci to ocp
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Alter the IRQ mapping to suit Century's board
+ *		- EEPROM support
+ *		- RTC support
+ *		- Century's IDE support
+ *      2002-03-21 - ozawa
+ *	      split OpenBlockSS's logic from walnut.c and ppc4xx_setup.c
+ *      2002-06-17 - ozawa
+ *		brush up rtc
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- rename openblokss.c to obs200.c
+ *
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/pci.h>
+#include <linux/rtc.h>
+#include <linux/ide.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <platforms/ibm_ocp.h>
+
+#define IIC0_MDBUF	((volatile unsigned char *)(IIC0_BASE + 0x00))
+#define IIC0_SDBUF	((volatile unsigned char *)(IIC0_BASE + 0x02))
+#define IIC0_LMADR	((volatile unsigned char *)(IIC0_BASE + 0x04))
+#define IIC0_HMADR	((volatile unsigned char *)(IIC0_BASE + 0x05))
+#define IIC0_CNTL	((volatile unsigned char *)(IIC0_BASE + 0x06))
+#define IIC0_MDCNTL	((volatile unsigned char *)(IIC0_BASE + 0x07))
+#define IIC0_STS	((volatile unsigned char *)(IIC0_BASE + 0x08))
+#define IIC0_EXTSTS	((volatile unsigned char *)(IIC0_BASE + 0x09))
+#define IIC0_LSADR	((volatile unsigned char *)(IIC0_BASE + 0x0a))
+#define IIC0_HSADR	((volatile unsigned char *)(IIC0_BASE + 0x0b))
+#define IIC0_CLKDIV	((volatile unsigned char *)(IIC0_BASE + 0x0c))
+#define IIC0_INTRMSK	((volatile unsigned char *)(IIC0_BASE + 0x0d))
+#define IIC0_XFRCNT	((volatile unsigned char *)(IIC0_BASE + 0x0e))
+#define IIC0_XTCNTLSS	((volatile unsigned char *)(IIC0_BASE + 0x0f))
+#define IIC0_DIRECTCNTL	((volatile unsigned char *)(IIC0_BASE + 0x10))
+
+#define EEPROMTimeOut 16
+#define EEPROMDeviceCode 0xa0
+#define RTCDeviceCode 0xd0
+
+static void EEPROMInit (void);
+static int EEPROMDone(void);
+static int EEPROMWriteByte(unsigned char DeviceCode, unsigned short address, unsigned char data);
+static int EEPROMReadByte(unsigned char DeviceCode, unsigned short address, unsigned char *data);
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+/* Some IRQs unique to OpenBlockSS.
+ * Used by the generic 405 PCI setup functions in ppc4xx_pci.c
+ */
+int __init
+ppc405_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	/*
+	 *      PCI IDSEL/INTPIN->INTLINE
+	 *      A       B       C       D
+	 */
+	{
+                {28, 28, 28, 28},       /* IDSEL 7 - PCI slot 1 */
+                {26, 26, 26, 26},       /* IDSEL 8 - PCI slot 2 */
+                {27, 27, 27, 27},       /* IDSEL 9 - PCI slot 3 */
+        };
+	const long min_idsel = 7, max_idsel = 9, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+
+/* note that board_setup_arch is called from init's start_kernel
+   via ppc4xx_setup_arch */
+void __init
+board_setup_arch(void)
+{
+#ifdef CONFIG_IDE
+#define IDE_INIT_TIMEOUT 100
+        volatile unsigned short *cmdsts = (volatile unsigned short *)OBSS_ATACTRL_ADDR;
+        volatile unsigned short *base = (volatile unsigned short *)OBSS_ATAREG_ADDR;
+        int i;
+        unsigned short stat;
+
+        /* RESET IDE i/f pAsic */
+        printk("[board_setup_arch] Initializing IDE I/F\n");
+        mtdcr(DCRN_CHCR1, (mfdcr(DCRN_CHCR1) | 0x00004000));
+        mdelay(5);
+        *cmdsts = 0x0001;
+        mdelay(5);
+        *cmdsts = 0x0002;
+        mdelay(5);
+        *cmdsts = 0x4000;
+        DBG("[board_setup_arch] Byte swap %x\n", *cmdsts);
+
+        /* map IDE regs & wait  */
+        DBG("[board_setup_arch] Waiting for IDE devices\n");
+        for(i=0; i<IDE_INIT_TIMEOUT; i++)
+        {
+                mdelay(5);
+                mdelay(5);
+                stat = *(base + (IDE_STATUS_OFFSET-IDE_DATA_OFFSET));
+                if( (stat & 0x8000) == 0) break;    /* reset complete */
+        }
+        if(i>= IDE_INIT_TIMEOUT)
+                printk("[board_setup_arch] IDE devices TIMEOUT\n");
+#endif  /* CONFIG_IDE */
+}
+
+
+void __init
+bios_fixup(struct pci_controller *hose, void *pcil0_base)
+{
+
+	unsigned int bar_response, bar;
+	struct pcil0_regs *pcip;
+	/*
+	 * Expected PCI mapping:
+	 *
+	 *  PLB addr             PCI memory addr
+	 *  ---------------------       ---------------------
+	 *  0000'0000 - 7fff'ffff <---  0000'0000 - 7fff'ffff
+	 *  8000'0000 - Bfff'ffff --->  8000'0000 - Bfff'ffff
+	 *
+	 *  PLB addr             PCI io addr
+	 *  ---------------------       ---------------------
+	 *  e800'0000 - e800'ffff --->  0000'0000 - 0001'0000
+	 *
+	 * The following code is simplified by assuming that the bootrom
+	 * has been well behaved in following this mapping.
+	 */
+
+#ifdef DEBUG
+	int i;
+	pcip = (struct pcil0_regs *) pcil0_base;
+
+	printk("ioremap PCLIO_BASE = 0x%x\n", pcip);
+	printk("PCI bridge regs before fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#else
+	pcip = (struct pcil0_regs *) pcil0_base;
+#endif
+
+	/* added for IBM boot rom version 1.15 bios bar changes  -AK */
+
+	/* Disable region first */
+	out_le32((void *) &(pcip->pmm[0].ma), 0x00000000);
+	/* PLB starting addr, PCI: 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].la), 0x80000000);
+	/* PCI start addr, 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].pcila), PPC405_PCI_MEM_BASE);
+	/* 512MB range of PLB to PCI */
+	out_le32((void *) &(pcip->pmm[0].pciha), 0x00000000);
+	/* Enable no pre-fetch, enable region */
+	out_le32((void *) &(pcip->pmm[0].ma), ((0xffffffff -
+						(PPC405_PCI_UPPER_MEM -
+						 PPC405_PCI_MEM_BASE)) | 0x01));
+
+	/* Disable region one */
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm1ms), 0x00000000);
+
+	/* Disable region two */
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm2ms), 0x00000000);
+
+	/* Zero config bars */
+	for (bar = PCI_BASE_ADDRESS_1; bar <= PCI_BASE_ADDRESS_2; bar += 4) {
+		early_write_config_dword(hose, hose->first_busno,
+					 PCI_FUNC(hose->first_busno), bar,
+					 0x00000000);
+		early_read_config_dword(hose, hose->first_busno,
+					PCI_FUNC(hose->first_busno), bar,
+					&bar_response);
+		DBG("BUS %d, device %d, Function %d bar 0x%8.8x is 0x%8.8x\n",
+		    hose->first_busno, PCI_SLOT(hose->first_busno),
+		    PCI_FUNC(hose->first_busno), bar, bar_response);
+	}
+	/* end work arround */
+
+#ifdef DEBUG
+	printk("PCI bridge regs after fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+}
+
+/* note that board_io_mapping is called from MMU_init of mm/init.c
+   via m4xx_map_io */
+void __init
+board_io_mapping(void)
+{
+	DBG("[board_io_mapping] Mapping seg-LED, ATA\n");
+	io_block_mapping(OBSS_SEGLED_ADDR, OBSS_SEGLED_ADDR,
+	  OBSS_SEGLED_SIZE, _PAGE_IO);
+	io_block_mapping(OBSS_ATAREG_ADDR, OBSS_ATAREG_ADDR,
+	  OBSS_ATAREG_SIZE, _PAGE_IO);
+	io_block_mapping(OBSS_ATACTRL_ADDR, OBSS_ATACTRL_ADDR,
+	  OBSS_ATACTRL_SIZE, _PAGE_IO);
+}
+
+#define IRQ25AND31     ((1<<(31-25))|(1<<(31-31)))
+void __init
+board_setup_irq(void)
+{
+        DBG("[board_setup_irq] set irq 25 and 31 are level-sensitive\n");
+        /* irq31(405eth re-link) and irq25(push sw) are leve-sensitive */
+        mtdcr(DCRN_UIC_TR(UIC0), mfdcr(DCRN_UIC_TR(UIC0)) | IRQ25AND31);
+        /* if level-sensitive interrupt, then clear bit in the status register */
+        DBG("[board_setup_irq] clear status register for level-sensitive irqs\n");
+        mtdcr(DCRN_UIC_SR(UIC0), ~(mfdcr(DCRN_UIC_TR(UIC0))));
+}
+
+static void
+EEPROMInit ()
+{
+	writeb(0x00, IIC0_LMADR);	/* clear low master addr */
+	writeb(0x00, IIC0_HMADR);	/* clear high master addr */
+	writeb(0x00, IIC0_LSADR);	/* clear low slave addr */
+	writeb(0x00, IIC0_HSADR);	/* clear high slave addr */
+	writeb(0x0A, IIC0_STS);		/* clear status */
+	writeb(0x8F, IIC0_EXTSTS);	/* clear extended status */
+	writeb(0x04, IIC0_CLKDIV);	/* set clock division */
+	writeb(0x00, IIC0_INTRMSK);	/* disable interrupt */
+	writeb(0x00, IIC0_XFRCNT);	/* clear transfer count */
+	writeb(0xF0, IIC0_EXTSTS);	/* clear extended control and status */
+	writeb(0x43, IIC0_MDCNTL);	/* set mode control */
+	writeb(0x00, IIC0_CNTL);	/* clear control */
+}
+
+static int
+EEPROMWriteByte(unsigned char DeviceCode, unsigned short address, unsigned char data)
+{
+	writeb(0x0A, IIC0_STS);		/* clear status */
+
+	writeb(readb(IIC0_MDCNTL)|0x40, IIC0_MDCNTL);	/* flush master data buffer */
+	writeb(DeviceCode, IIC0_LMADR);		/* transmit device code */
+	writeb(address, IIC0_MDBUF);		/* transmit address */
+	writeb(data, IIC0_MDBUF);			/* transmit datum */
+	writeb(0x11, IIC0_CNTL);	/* start transmission */
+	if (EEPROMDone() != 0) return -1;
+	return 0;
+}
+
+static int
+EEPROMReadByte(unsigned char DeviceCode, unsigned short address, unsigned char *data)
+{
+	writeb(0x0A, IIC0_STS);		/* clear status */
+
+	writeb(readb(IIC0_MDCNTL)|0x40, IIC0_MDCNTL);	/* flush master data buffer */
+	writeb(DeviceCode, IIC0_LMADR);		/* transmit device code */
+	writeb(address, IIC0_MDBUF);		/* transmit address */
+	writeb(0x01, IIC0_CNTL);	/* start transmission */
+	if (EEPROMDone() != 0) return -1;
+
+	writeb(readb(IIC0_MDCNTL)|0x40, IIC0_MDCNTL);	/* flush master data buffer */
+	writeb(DeviceCode|0x01, IIC0_LMADR);	/* transmit device code */
+	writeb(0x03, IIC0_CNTL);	/* start transmission */
+	if (EEPROMDone() != 0) return -1;
+
+	*data = readb(IIC0_MDBUF);
+	return 0;
+}
+
+static int
+EEPROMDone()
+{
+	int i;
+	unsigned char status;
+
+	for (i = EEPROMTimeOut; i > 0; i--)
+	{
+		status = readb(IIC0_STS);
+		if ((status & 0x01) == 0x00)
+		{
+			writeb(0x0A, IIC0_STS);		/* clear status */
+			if (status & 0x04) return -2;	/* error */
+			return(0);
+		}
+		udelay(100);
+	}
+	return(-1);
+}
+
+
+static long
+obss_time_init(void)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~IBM_CPM_IIC0);
+	EEPROMInit();
+	return 0;
+}
+
+
+static int
+obss_set_rtc_time(unsigned long nowtime)
+{
+	struct rtc_time   tm;
+	unsigned char     tmp;
+	unsigned short	  address = 0x0000;
+	int 		  r_code;
+
+	to_tm(nowtime, &tm);
+
+	tmp = tm.tm_sec ;  tm.tm_sec  = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_min ;  tm.tm_min  = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_hour;  tm.tm_hour = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_wday;  tm.tm_wday = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_mday;  tm.tm_mday = ((tmp / 10) << 4) + (tmp % 10);
+	tmp = tm.tm_mon ;  tm.tm_mon  = ((tmp / 10) << 4) + (tmp % 10);
+	tm.tm_year -= 2000;
+	tmp = tm.tm_year;  tm.tm_year = ((tmp / 10) << 4) + (tmp % 10);
+
+	DBG("[obss_set_rtc_time] Seconds %d %d\n", tm.tm_sec, (tm.tm_sec & 0x7f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_sec & 0x7f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Minutes %d %d\n", tm.tm_min, (tm.tm_min & 0x7f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_min & 0x7f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Hours %d %d\n", tm.tm_hour, (tm.tm_hour & 0x7f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_hour & 0x3f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Wday %d %d\n", tm.tm_wday, (tm.tm_wday & 0x1f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_wday & 0x1f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Mday %d %d\n", tm.tm_mday, (tm.tm_mday & 0x3f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_mday & 0x3f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Month %d %d\n", tm.tm_mon, (tm.tm_mon & 0x1f));
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_mon & 0x1f));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	address++;
+
+	DBG("[obss_set_rtc_time] Year %d %d\n", tm.tm_year, tm.tm_year);
+	r_code = EEPROMWriteByte(RTCDeviceCode, address, (tm.tm_year));
+	if (r_code != 0)
+	{
+		printk("[obss_set_rtc_time] Error writing RTC %d\n", address);
+		return (r_code);
+	}
+	return 0;
+}
+
+static unsigned long
+obss_get_rtc_time(void)
+{
+	unsigned char tmp;
+	unsigned int year, mon, mday, day, hour, min, sec;
+	unsigned short address = 0x0000;
+	int r_code;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	sec = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	min = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	hour = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	day = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	mday = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	mon = tmp;
+	address++;
+
+	r_code = EEPROMReadByte(RTCDeviceCode, address, &tmp);
+	if (r_code != 0)
+	{
+		printk("[obss_get_rtc_time] Error reading RTC %d\n", address);
+		return (r_code);
+	}
+	year = tmp;
+	sec     = sec & 0x7f;
+	min     = min & 0x7f;
+	hour    = hour & 0x3f;
+	mon     = mon & 0x1f;
+	mday    = mday & 0x3f;
+
+	tmp = sec    ;  sec     = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = min    ;  min     = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = hour   ;  hour    = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = mday   ;  mday    = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = mon    ;  mon     = (tmp &0xf) + ((tmp >> 4) * 10);
+	tmp = year   ;  year    = (tmp &0xf) + ((tmp >> 4) * 10);
+	year += 2000;
+
+	DBG("[obss_get_rtc_time] Year %d Month %d Day %d Hour %d Min %d Sec %d %u\n", year, mon, mday, hour, min, sec, mktime(year, mon, mday, hour, min, sec));
+	return mktime(year, mon, mday, hour, min, sec);
+}
+
+static void
+obss_ide_init_hwif_ports(hw_regs_t *hw, ide_ioreg_t data_port, ide_ioreg_t ctrl_port, int *irq)
+{
+        int i;
+        ide_ioreg_t reg, base;
+
+        if (data_port != 0) return;     /* ignore it if the default attribute is defined */
+
+        base = (ide_ioreg_t)ioremap(OBSS_ATAREG_ADDR, OBSS_ATAREG_SIZE);
+        if (base == 0) panic("[obss_ide_init_hwif_ports] ioremap failed\n");
+
+        for (i=IDE_DATA_OFFSET, reg=base; i<=IDE_STATUS_OFFSET; i++, reg+=2)
+        {
+                hw->io_ports[i] = reg;
+                DBG("[obss_ide_init_hwif_ports] FROM DATA OFFSET %d %x\n",
+			i, hw->io_ports[i]);
+        }
+
+        hw->io_ports[IDE_CONTROL_OFFSET] = base + 0x1c;
+        DBG("[obss_ide_init_hwif_ports] IDE CONTROL %x\n", hw->io_ports[IDE_CONTROL_OFFSET]);
+
+        if (irq) *irq = OBSS_ATA0_IRQ;
+}
+
+/* note that board_init is called before the mmu is initialized */
+void __init
+board_init(void)
+{
+#ifdef CONFIG_PPC_RTC
+        ppc_md.time_init = obss_time_init;
+        ppc_md.set_rtc_time = obss_set_rtc_time;
+        ppc_md.get_rtc_time = obss_get_rtc_time;
+#endif  /* CONFIG_PPC_RTC */
+#ifdef CONFIG_IDE
+        ppc_ide_md.ide_init_hwif = obss_ide_init_hwif_ports;
+#endif  /* CONFIG_IDE */
+
+}
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs200.h linux-2.4.28/arch/ppc/platforms/obs200.h
--- linux-2.4.28.orig/arch/ppc/platforms/obs200.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs200.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,122 @@
+/*
+ *
+ *    Copyright (c) 2002 OZAWA Takahiro <obss@ozawa.cc>
+ *      derived from walnut.h
+ *
+ *    Copyright (c) 1999 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000 MontaVista Software Inc.
+ *	PPC405 modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	frank_rowand@mvista.com or source@mvista.com
+ * 	   	debbie_chu@mvista.com
+ *
+ *    Module name: obs200.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      based boards.
+ *
+ *      This includes:
+ *
+ *         Plat'Home "OpenBlockS 200" micro server
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added bi_s_version[],bi_r_version[] in 'typedef struct board_info'
+ *		- rename openblokss.h to obs200.h
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_OBSS_H__
+#define __ASM_OBSS_H__
+
+/* We have a 405GP core */
+#include <platforms/ibm405gp.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * Data structure defining board information maintained by the
+ * embed_config() for OpenBlockSS while booting.
+ * ROM on IBM's "Walnut" evaluation board. An effort has been made to
+ * keep the field names consistent with the 8xx 'bd_t' board info
+ * structures.
+ */
+
+typedef struct board_info {
+	unsigned char	 bi_s_version[4];	/* Version of this structure */
+	unsigned char	 bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned char	 bi_enetaddr[6];	/* Local Ethernet MAC address */
+	unsigned char	 bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
+	unsigned int	 bi_mem;		/* DRAM installed, in mega bytes */
+	unsigned int	 bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	 bi_mode;		/* 0: Ramdisk, 1: Harddisk */
+	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+} bd_t;
+
+/* Some 4xx parts use a different timebase frequency from the internal clock.
+*/
+#define bi_tbfreq bi_intfreq
+
+/* OpenBlockSS specific definitions. */
+
+/* irq */
+#define OBSS_PSH_IRQ		25
+#define OBSS_ATA0_IRQ		29
+#define OBSS_PDOWN_IRQ		30
+#define OBSS_ETH_RELINK_IRQ	31
+
+/* ata register manipulation */
+#define HAVE_ARCH_OUT_BYTE
+#define OUT_BYTE(dat,port)	(out_le16((volatile unsigned short *)port, dat & 0xFF))
+#define OUT_WORD(dat,port)	(out_be16((volatile unsigned short *)port, dat & 0xFFFF))
+
+#define HAVE_ARCH_IN_BYTE
+#define IN_BYTE(port)		(in_le16((volatile unsigned short *)port) & 0xFF)
+#define IN_WORD(port)		in_be16((volatile unsigned short *)port)
+
+/* i/o map */
+
+#define _IO_BASE	0
+#define _ISA_MEM_BASE	0
+#define PCI_DRAM_OFFSET	0
+
+/* 0x00100000 (6-byte): 405GP internal ethernet mac address */
+#define OBSS_ENET_MACADDR	((unsigned char *)(0x00100000))
+/* 0x00100006 (8-bit):  Boot mode: 0=ramdisk, 1=hdd, other=recovery(ramdisk) */
+#define OBSS_BOOT_MODE		((unsigned char *)0x00100006)
+/* 0x00100007 (8-bit):  RAM size: 4, 8, 16, 32, 64, 128=nn MB, other=unknown */
+#define OBSS_RAM_SIZE		((unsigned char *)0x00100007)
+/* 0x40000000 (8-bit):  7-segment LED (see segled.h) */
+#define OBSS_SEGLED_ADDR	((uint)0x40000000)
+#define OBSS_SEGLED_SIZE	((uint)4*1024)
+/* 0x60000000 (+0x00..0x0F: ATA registers(even byte aligned), +0x1C: ATA control register) */
+#define OBSS_ATAREG_ADDR	((uint)0x60000000)
+#define OBSS_ATAREG_SIZE	((uint)4*1024)
+/* 0x70000000 (2-byte?: ATA host controller register) */
+#define OBSS_ATACTRL_ADDR	((uint)0x70000000)
+#define OBSS_ATACTRL_SIZE	((uint)4*1024)
+
+/* overwrite default in include/asm-ppc/ide.h */
+#ifdef MAX_HWIFS
+#undef MAX_HWIFS
+#endif
+#define	MAX_HWIFS	1
+
+#define BASE_BAUD		460800
+#define PPC4xx_MACHINE_NAME	"Plat'Home OpenBlockSS"
+
+/* overwrite PM sleeper in arch/ppc/platforms/ibm405gp.h */
+#undef DFLT_IBM4xx_PM
+#define DFLT_IBM4xx_PM		~(IBM_CPM_PCI | IBM_CPM_CPU | IBM_CPM_DMA \
+					| IBM_CPM_OPB | IBM_CPM_EBC \
+					| IBM_CPM_SDRAM0 | IBM_CPM_PLB \
+					| IBM_CPM_UIC | IBM_CPM_TMRCLK \
+					| IBM_CPM_IIC0 | IBM_CPM_UART0 | IBM_CPM_UART1 \
+					| IBM_CPM_EMAC0 | 0x00010000 | 0x00008000) /* enet rm, tm unit */
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_OBSS_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs266.c linux-2.4.28/arch/ppc/platforms/obs266.c
--- linux-2.4.28.orig/arch/ppc/platforms/obs266.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs266.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,345 @@
+/*
+ *
+ *    Copyright (c) 2003 AXE,Inc.
+ *    obs266.c: Based on walnut.c
+ *
+ *    Copyrigh t(c) 1999-2000 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000-2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: obs266.c
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      IBM PowerPC 4xx based boards. Adapted from original
+ *      code by Gary Thomas, Cort Dougan <cort@fsmlabs.com>, and Dan Malek
+ *      <dan@net4x.com>.
+ *
+ *      History: 11/09/2001 - armin
+ *      added board_init to add in additional instuctions needed during platfrom_init
+ *
+ *      01/22/2002 - Armin
+ *      converted pci to ocp
+ *
+ *
+ * Please read the COPYING file for all license details.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/pci.h>
+#include <linux/rtc.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/todc.h>
+#include <platforms/ibm_ocp.h>
+#include <asm/delay.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+void *kb_cs;
+void *kb_data;
+void *openblocks266_rtc_base;
+
+/* Some IRQs unique to OpenBlockS266.
+ * Used by the generic 405 PCI setup functions in ppc4xx_pci.c
+ */
+int __init
+ppc405_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	    /*
+	     *      PCI IDSEL/INTPIN->INTLINE
+	     *      A       B       C       D
+	     */
+	{
+		{28, 28, 28, 28},	/* IDSEL 1 - PCI slot 1 */
+		{29, 29, 29, 29},	/* IDSEL 2 - PCI slot 2 */
+		{30, 30, 30, 30},	/* IDSEL 3 - PCI slot 3 */
+		{31, 31, 31, 31},	/* IDSEL 4 - PCI slot 4 */
+	};
+
+	const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+
+void __init
+board_setup_arch(void)
+{
+#define OBS266_PS2_BASE		0xF0100000
+#define OBS266_FPGA_BASE	0xF0300000
+
+	void *fpga_brdc;
+	void *fpga_enable;
+	void *fpga_polarity;
+	void *fpga_status;
+	void *fpga_trigger;
+	
+	kb_data = ioremap(OBS266_PS2_BASE, 8);
+	if (!kb_data) {
+		printk(KERN_CRIT
+		       "openblocks266_setup_arch() kb_data ioremap failed\n");
+		return;
+	}
+
+	kb_cs = kb_data + 1;
+
+	fpga_status = ioremap(OBS266_FPGA_BASE, 8);
+	if (!fpga_status) {
+		printk(KERN_CRIT
+		       "openblocks266_setup_arch() fpga_status ioremap failed\n");
+		return;
+	}
+
+
+	fpga_enable = fpga_status + 1;
+	fpga_polarity = fpga_status + 2;
+	fpga_trigger = fpga_status + 3;
+	fpga_brdc = fpga_status + 4;
+
+	/* Identify the system */
+	printk("OpenBlockS port\n");
+	/* printk("IBM Walnut port (C) 2000-2002 MontaVista Software, Inc. (source@mvista.com)\n"); */
+}
+
+#ifdef NEVER
+static void obs_dump_pci_conf(struct pci_controller *hose, int bus, int devfn)
+{
+	u8 addr;
+	u32 buf;
+	printk("OpenBlockS: PCI configuration register dump (bus:%d,dev:%d,fn:%d)\n", bus, PCI_SLOT(devfn), PCI_FUNC(devfn));
+	for( addr=0; addr<0x80; addr+=4 ){
+		if( early_read_config_dword(hose, bus, devfn, addr, &buf) ){
+			printk("OpenBlockS: read error PCI:(bus:%d,dev:%d,fn:%d,addr:0x%02x)\n", bus, PCI_SLOT(devfn), PCI_FUNC(devfn), addr);
+		}
+		if( addr % 16 == 0 )
+			printk("%02x:", addr);
+		printk(" %08x", buf);
+		if( addr % 16 == 12 )
+			printk("\n");
+	}
+}
+#endif
+
+static void obs_reset_pci_bus(struct pci_controller *hose)
+{
+	u16 brdgopt2;
+
+	/* obs_dump_pci_conf(hose, 0, PCI_DEVFN(0,0)); */
+	if( early_read_config_word(hose, 0, PCI_DEVFN(0,0), 0x60, &brdgopt2) ){
+		printk("OpenBlockS: read error PCI:(bus:%d,dev:%d,fn:%d,addr:%02x)\n", 0,0,0, 0x60);
+		return;
+	}
+	if( early_write_config_word(hose, 0, PCI_DEVFN(0,0), 0x60, brdgopt2 | 0x1000) ){
+		printk("OpenBlockS: read error PCI:(bus:%d,dev:%d,fn:%d,addr:%02x)\n", 0,0,0, 0x60);
+		return;
+	}
+
+	udelay(1000); udelay(1000); udelay(1000); udelay(1000);
+
+	if( early_write_config_word(hose, 0, PCI_DEVFN(0,0), 0x60, (brdgopt2 & ~0x1000) & 0xffff) ){
+		printk("OpenBlockS: read error PCI:(bus:%d,dev:%d,fn:%d,addr:%02x)\n", 0,0,0, 0x60);
+
+	}
+}
+
+#ifdef NEVER
+static void obs_hpt371_dump_pci_conf(struct pci_controller *hose)
+{
+	obs_dump_pci_conf(hose, 0, PCI_DEVFN(3,0));
+}
+
+static void obs_hpt371_load_vender_id(struct pci_controller *hose)
+{
+	u32 ids;
+	u8 reg7bh;
+
+	if( early_read_config_dword(hose, 0, PCI_DEVFN(3,0), PCI_VENDOR_ID, &ids) ){
+		printk("OpenBlockS: HPT371: read error 1\n");
+		return;
+	}
+	if( ids == 0xffffffff || ids == 0x00000000 || ids == 0x0000ffff || ids == 0xffff0000 ){
+		printk("OpenBlockS: HPT371: not found device\n");
+		return;
+	}
+	if( ids == 0x00071103 ){
+#ifdef DEBUG
+		printk("OpenBlockS: HPT371: no need loading Vender ID\n");
+#endif
+		return;
+	}
+
+	if( early_read_config_byte(hose, 0, PCI_DEVFN(3,0), 0x7b, &reg7bh) ){
+		printk("OpenBlockS: HPT371: read error\n");
+		return;
+	}
+	printk("OpenBlockS: HPT371: try to change Vender ID %08x --> %08x\n", ids, 0x00071103);
+	if( early_write_config_byte(hose, 0, PCI_DEVFN(3,0), 0x7b, reg7bh | 0x40) ){
+		printk("OpenBlockS: HPT371: write error\n");
+		return;
+	}
+	if( early_write_config_dword(hose, 0, PCI_DEVFN(3,0), PCI_VENDOR_ID, 0x00071103) ){
+		printk("OpenBlockS: HPT371: write error\n");
+		return;
+	}
+	if( early_write_config_byte(hose, 0, PCI_DEVFN(3,0), 0x7b, reg7bh & ~0x40) ){
+		printk("OpenBlockS: HPT371: read error\n");
+		return;
+	}
+	if( early_read_config_dword(hose, 0, PCI_DEVFN(3,0), 0x00, &ids) ){
+		printk("OpenBlockS: HPT371: read error\n");
+		return;
+	}
+	if( ids != 0x00071103 ){
+		printk("OpenBlockS: HPT371: fail to set Vender ID (%08x)\n", ids);
+		return;
+	}
+}
+#endif /* NEVER */
+
+void __init
+bios_fixup(struct pci_controller *hose, struct pcil0_regs *pcip)
+{
+	/* Aviod a HPT371 vender ID broken problem in restart machine */
+	obs_reset_pci_bus(hose);
+
+	/* obs_hpt371_dump_pci_conf(hose); */
+	/* obs_hpt371_load_vender_id(hose);*/ /* Don't work... */
+
+#ifdef NEVER	/* OpenBlockS bios fixup is done at 405GPr ROM Monitor */
+	unsigned int bar_response, bar;
+	/*
+	 * Expected PCI mapping:
+	 *
+	 *  PLB addr             PCI memory addr
+	 *  ---------------------       ---------------------
+	 *  0000'0000 - 7fff'ffff <---  0000'0000 - 7fff'ffff
+	 *  8000'0000 - Bfff'ffff --->  8000'0000 - Bfff'ffff
+	 *
+	 *  PLB addr             PCI io addr
+	 *  ---------------------       ---------------------
+	 *  e800'0000 - e800'ffff --->  0000'0000 - 0001'0000
+	 *
+	 * The following code is simplified by assuming that the bootrom
+	 * has been well behaved in following this mapping.
+	 */
+
+#ifdef DEBUG
+	int i;
+
+	printk("ioremap PCLIO_BASE = 0x%x\n", pcip);
+	printk("PCI bridge regs before fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+
+	/* added for IBM boot rom version 1.15 bios bar changes  -AK */
+
+	/* Disable region first */
+	out_le32((void *) &(pcip->pmm[0].ma), 0x00000000);
+	/* PLB starting addr, PCI: 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].la), 0x80000000);
+	/* PCI start addr, 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].pcila), PPC405_PCI_MEM_BASE);
+	/* 512MB range of PLB to PCI */
+	out_le32((void *) &(pcip->pmm[0].pciha), 0x00000000);
+	/* Enable no pre-fetch, enable region */
+	out_le32((void *) &(pcip->pmm[0].ma), ((0xffffffff -
+						(PPC405_PCI_UPPER_MEM -
+						 PPC405_PCI_MEM_BASE)) | 0x01));
+
+	/* Disable region one */
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm1ms), 0x00000000);
+
+	/* Disable region two */
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm2ms), 0x00000000);
+
+	/* Zero config bars */
+	for (bar = PCI_BASE_ADDRESS_1; bar <= PCI_BASE_ADDRESS_2; bar += 4) {
+		early_write_config_dword(hose, hose->first_busno,
+					 PCI_FUNC(hose->first_busno), bar,
+					 0x00000000);
+		early_read_config_dword(hose, hose->first_busno,
+					PCI_FUNC(hose->first_busno), bar,
+					&bar_response);
+		DBG("BUS %d, device %d, Function %d bar 0x%8.8x is 0x%8.8x\n",
+		    hose->first_busno, PCI_SLOT(hose->first_busno),
+		    PCI_FUNC(hose->first_busno), bar, bar_response);
+	}
+	/* end work arround */
+
+#ifdef DEBUG
+	printk("PCI bridge regs after fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+#endif /* NEVER */
+}
+
+void __init
+board_io_mapping(void)
+{
+	io_block_mapping(OBS266_RTC_VADDR,
+			 OBS266_RTC_PADDR, OBS266_RTC_SIZE, _PAGE_IO);
+}
+
+void __init
+board_setup_irq(void)
+{
+}
+
+void __init
+board_init(void)
+{
+	ppc_md.time_init = NULL;
+	ppc_md.set_rtc_time = NULL;
+	ppc_md.get_rtc_time = NULL;
+	ppc_md.nvram_read_val = NULL;
+	ppc_md.nvram_write_val = NULL;
+}
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs266.h linux-2.4.28/arch/ppc/platforms/obs266.h
--- linux-2.4.28.orig/arch/ppc/platforms/obs266.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs266.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,94 @@
+/*
+ *
+ *    Copyright (c) 2003 AXE,Inc.
+ *    obs266.h: Based on walnut.h
+ *
+ *    Copyright (c) 1999 Grant Erickson <grant@lcse.umn.edu>
+ *
+ *    Copyright 2000 MontaVista Software Inc.
+ *	PPC405 modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	frank_rowand@mvista.com or source@mvista.com
+ * 	   	debbie_chu@mvista.com
+ *
+ *    Module name: obs266.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      based boards.
+ *
+ *      This includes:
+ *
+ *         405GP "Walnut" evaluation board
+ *
+ * Please read the COPYING file for all license details.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_OBS266_H__
+#define __ASM_OBS266_H__
+
+/* We have a 405GPr core */
+#include <platforms/ibm405gp.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * Data structure defining board information maintained by the boot
+ * ROM on IBM's "Walnut" evaluation board. An effort has been made to
+ * keep the field names consistent with the 8xx 'bd_t' board info
+ * structures.
+ */
+
+typedef struct board_info {
+	unsigned char	 bi_s_version[4];	/* Version of this structure */
+	unsigned char	 bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	 bi_memsize;		/* DRAM installed, in bytes */
+	unsigned char	 bi_enetaddr[6];	/* Local Ethernet MAC address */
+	unsigned char	 bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
+	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+	unsigned int	 bi_opb_busfreq;	/* OPB Bus speed, in HZ */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
+} bd_t;
+
+/* Some 4xx parts use a different timebase frequency from the internal clock.
+*/
+#define bi_tbfreq bi_intfreq
+
+
+/* Memory map for the OpenBlockS266.
+ * Generic 4xx plus RTC.
+ */
+
+extern void *openblocks266_rtc_base;
+#define OBS266_RTC_PADDR	((uint)0xf0000000)
+#define OBS266_RTC_VADDR	OBS266_RTC_PADDR
+#define OBS266_RTC_SIZE	((uint)8*1024)
+
+/* ps2 keyboard and mouse */
+#define KEYBOARD_IRQ		25
+#define AUX_IRQ			26
+
+#ifdef CONFIG_PPC405GP_INTERNAL_CLOCK
+#define BASE_BAUD		201600
+#else
+#define BASE_BAUD               (7372800/16)
+#endif
+
+#define OBS266_PS2_BASE	0xF0100000
+#define OBS266_FPGA_BASE	0xF0300000
+
+
+extern void *kb_cs;
+extern void *kb_data;
+#define kbd_read_input()	readb(kb_data)
+#define kbd_read_status()	readb(kb_cs)
+#define kbd_write_output(val)	writeb(val, kb_data)
+#define kbd_write_command(val)	writeb(val, kb_cs)
+
+#define PPC4xx_MACHINE_NAME	"OpenBlockS266"
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_OBS266_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs50.h linux-2.4.28/arch/ppc/platforms/obs50.h
--- linux-2.4.28.orig/arch/ppc/platforms/obs50.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs50.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,63 @@
+/*
+ * for OpenBlockS 50
+ * Copyright (c) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ */
+
+/*
+ * A collection of structures, addresses, and values associated with
+ * the Plat'Home OpenBlockS. Copied from the IVMS stuff.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_OBS50_H__
+#define __ASM_OBS50_H__
+
+#include <linux/config.h>
+
+#include <asm/ppcboot.h>
+
+/* Memory map
+ */
+#define	CFG_ATA_BASE_ADDR	((unsigned)0x80000000)
+#define	CFG_ATA_SIZE		((uint)4000)
+#define	CFG_ATA_SUB_BASE_ADDR	((unsigned)0x80200000)
+#define	CFG_ATA_SUB_SIZE	((uint)4000)
+#define	IMAP_ADDR		((uint)0xFF000000)
+#define IMAP_SIZE		((uint)(64 * 1024))
+
+/* Interrupt assignments.
+ */
+#define FEC_INTERRUPT	3		/* = SIU_LEVEL1 */
+#define CPM_INTERRUPT	5		/* = SIU_LEVEL2 */
+#define IDE0_INTERRUPT	8		/* = SIU_IRQ4 */
+#define PHY_INTERRUPT	10		/* = SIU_IRQ5 */
+
+/* override the default number of IDE hardware interfaces */
+#define	MAX_HWIFS	1
+
+/*
+ * Definitions for IDE0 Interface
+ */
+/* main area */
+#define IDE0_BASE_OFFSET		0	/* Base offset (dummy) */
+#define IDE0_DATA_REG_OFFSET		0x00000010
+#define IDE0_ERROR_REG_OFFSET		0x00000012
+#define IDE0_NSECTOR_REG_OFFSET		0x00000014
+#define IDE0_SECTOR_REG_OFFSET		0x00000016
+#define IDE0_LCYL_REG_OFFSET		0x00000018
+#define IDE0_HCYL_REG_OFFSET		0x0000001A
+#define IDE0_SELECT_REG_OFFSET		0x0000001C
+#define IDE0_STATUS_REG_OFFSET		0x0000001E
+/* sub area */
+#define IDE0_CONTROL_REG_OFFSET		0x0000000C
+#define IDE0_IRQ_REG_OFFSET		0x0000000E	/* not used */
+
+/* We don't use the 8259. */
+#define NR_8259_INTS	0
+
+/* ata register manipulation */
+#define OUT_WORD(w,p)	outw_p((w),(p))
+#define IN_WORD(p)	(short)inw_p(p)
+
+#endif /* __ASM_OBS50_H__ */
+#endif /* __KERNEL__ */
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs50_i2clib.c linux-2.4.28/arch/ppc/platforms/obs50_i2clib.c
--- linux-2.4.28.orig/arch/ppc/platforms/obs50_i2clib.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs50_i2clib.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,296 @@
+/* @@ES TANIA */
+/*
+ *	I2C utilities.
+ *
+ *	Written for Century Systems, Inc. Embedded Server
+ *		for EEPROM/RTC access.
+ *	2000.6.5
+ *	T. Oka
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *  Modified by Century Systems Inc.(http://www.centurysys.co.jp/)
+ *
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/8xx_immap.h>
+
+#define DBGON(x)	x
+#define DBGOFF(x)
+
+
+#define I2C_ACK_WT		(2000L)
+#define I2C_INIT_WT		(200L)
+
+/* Pointer to the Communications Processor (GLOBAL within this module). */
+static volatile cpm8xx_t	*cp;
+
+/*-----------------------------------------------------------------------------
+ *	Local prototypes.
+ *----------------------------------------------------------------------------*/
+static void i2c_wait(unsigned long wt);
+static void i2c_start(unsigned long wt);
+static void i2c_stop(unsigned long wt);
+static int i2c_put(unsigned char *buf, unsigned int len, unsigned long wt);
+static unsigned char i2c_get(unsigned long wt);
+
+
+/*-----------------------------------------------------------------------------
+ *	Initializes parallel port B register for SCL and SDA control.
+ *----------------------------------------------------------------------------*/
+void __init i2c_init(void)
+{
+	unsigned long	flags;
+	unsigned long	i;
+
+	/* Get pointer to Communication Processor */
+	cp = (cpm8xx_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);
+
+	save_flags(flags);
+	cli();
+
+	cp->cp_pbpar &= ~(0x0030);	/* SCL and SDA general purpose I/O */
+	cp->cp_pbodr |= 0x0030;		/* SCL, SDA open drain */
+	cp->cp_pbdir |= 0x0030;		/* SCL (and SDA for now) output */
+	cp->cp_pbdat |= 0x0030;		/* SCL (and SDA) high */
+
+	restore_flags(flags);
+
+	for (i = 0; i <= I2C_INIT_WT; i++) {}
+}	/* i2c_init() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static void i2c_wait(unsigned long wt)
+{
+	unsigned long	i;
+
+#ifdef TODO
+ - should do this with jiffies instead to work when cpu changes?
+ - also should let other tasks run during this?
+ - in this case must be careful that interrupts are not disabled when this routine is called otherwise jiffies won't be changed and other tasks won't run
+ - this assumes no other tasks manipulating SCL and SDA though - s/b ok - once basically working with interrupts disabled, make a copy then fix
+- what about udelay()? nanosleep()?
+#endif
+	for (i = 0; i <= wt; i++) {}
+}	/* i2c_wait() */
+
+/*-----------------------------------------------------------------------------
+ *	Performs start condition.
+ *	Expects SCL and SDA high, SDA output.
+ *	Leaves SCL low in preparation for data transfer.
+ *----------------------------------------------------------------------------*/
+static void i2c_start(unsigned long wt)
+{
+	i2c_wait(wt);
+	cp->cp_pbdat &= ~(0x0010);	/* SDA -> low */
+	i2c_wait(wt);
+	cp->cp_pbdat &= ~(0x0020);	/* SCL -> low */
+	i2c_wait(wt);
+}	/* i2c_start() */
+
+/*-----------------------------------------------------------------------------
+ *	Performs stop condition.
+ *	Expects SDA output and high.
+ *	Leaves SCL and SDA high to indicate bus not busy.
+ *----------------------------------------------------------------------------*/
+static void i2c_stop(unsigned long wt)
+{
+	i2c_wait(wt);
+	cp->cp_pbdat &= ~(0x0010);	/* SDA -> low */
+	cp->cp_pbdat |= 0x0020;		/* SCL -> high */
+	i2c_wait(wt);
+	cp->cp_pbdat |= 0x0010;		/* SDA -> high */
+	i2c_wait(wt);
+}	/* i2c_stop() */
+
+/*-----------------------------------------------------------------------------
+ *	Expects SCL low and SDA output.
+ *	Leaves SCL low.
+ *----------------------------------------------------------------------------*/
+static int i2c_put(unsigned char *buf, unsigned int len, unsigned long wt)
+{
+	unsigned int	j;
+	unsigned char	mask, ack;
+
+	for (j = 0; j < len; j++) {
+		for (mask = 0x80; mask > 0x00; mask >>= 1) {
+			/* SCL is expected to be low here for data transfer */
+
+			if (buf[j] & mask) {
+				cp->cp_pbdat |= 0x0010;		/* SDA high */
+			}
+			else {
+				cp->cp_pbdat &= ~(0x0010);	/* SDA low */
+			}
+
+			i2c_wait(wt);	/* tSU:DAT at least 250 ns */
+			cp->cp_pbdat |= 0x0020;		/* SCL -> high */
+			i2c_wait(wt);	/* hold SDA stable with clock high */
+
+			/* SCL low for next data transfer */
+			cp->cp_pbdat &= ~(0x0020);
+			i2c_wait(wt);
+		}	/* for each bit */
+
+		/* setup SDA as input to receive ACK */
+		cp->cp_pbdir &= ~(0x0010);
+
+		/* generate clock pulse for ack */
+		cp->cp_pbdat |= 0x0020;		/* SCL -> high */
+		i2c_wait(wt);
+		i2c_wait(wt);	/* sample ACK near end of clock period */
+
+		ack = cp->cp_pbdat;	/* sample ACK */
+
+		/* SCL low for next data transfer */
+		cp->cp_pbdat &= ~(0x0020);
+		i2c_wait(wt);
+
+		/* reverse SDA direction back to output */
+		cp->cp_pbdir |= 0x0010;
+		i2c_wait(wt);
+
+		/* leave SDA high */	/* added 2000.6.20 */
+		cp->cp_pbdat |= 0x0010;
+		i2c_wait(wt);
+
+		if (ack & 0x0010) {	/* ACK not returned */
+			return (-1);
+		}
+	}	/* for len bytes */
+
+	return (0);
+}	/* i2c_put() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static unsigned char i2c_get(unsigned long wt)
+{
+	unsigned char	mask, rv = 0x00;
+
+	/* setup SDA as input to receive data */
+	cp->cp_pbdir &= ~(0x0010);
+	i2c_wait(wt);
+
+	for (mask = 0x80; mask > 0x00; mask >>= 1) {
+		DBGOFF(printk(" Ch ");)
+		cp->cp_pbdat |= 0x0020;		/* SCL high */
+		i2c_wait(wt);
+
+		/* sample data */
+		if (cp->cp_pbdat & 0x0010) {
+			DBGOFF(printk(" D1 ");)
+			rv |= mask;		/* SDA is high */
+		}
+		/* else bit remains 0 */
+		DBGOFF(else printk(" D0 ");)
+
+		DBGOFF(printk(" Cl ");)
+		cp->cp_pbdat &= ~(0x0020);	/* SCL -> low */
+		i2c_wait(wt);
+	}	/* for each bit */
+
+	/* reverse SDA direction back to output */
+	DBGOFF(printk(" SDA output ");)
+	cp->cp_pbdir |= 0x0010;
+	i2c_wait(wt);
+
+	/* leave SDA high */	/* added 2000.6.20 */
+	DBGOFF(printk(" Dh ");)
+	cp->cp_pbdat |= 0x0010;
+	i2c_wait(wt);
+
+	DBGOFF(printk(" endg\n");)
+
+	DBGOFF(printk(" [got %02x] ", rv);)
+	return (rv);
+}	/* i2c_get() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+unsigned char i2c_rd(unsigned char dev_id, unsigned int offset, unsigned long wt)
+{
+	unsigned char	buf[2];
+	int		rv;
+
+	DBGOFF(printk("r");)
+	DBGOFF(printk("[i2c_rd] offset %u\n", offset);)
+
+	DBGOFF({
+	printk("\n");
+	printk("PBPAR 0x%x\t", cp->cp_pbpar);
+	printk("PBDIR 0x%x\t", cp->cp_pbdir);
+	printk("PBODR 0x%x\t", cp->cp_pbodr);
+	printk("PBDAT 0x%x\t", cp->cp_pbdat);
+	printk("\n");
+	})
+
+	buf[0] = dev_id;
+	buf[1] = (unsigned char) offset;
+	DBGOFF(printk(" write %02x%02x ", buf[0], buf[1]);)
+
+	i2c_start(wt);
+	rv = i2c_put(buf, 2, wt);
+	i2c_stop(wt);
+
+	if (rv) {
+		DBGOFF(printk("[i2c_rd] 1\n");)
+		return (0x00);
+	}
+
+	buf[0] |= 0x01;		/* R/W bit ==> read */
+	i2c_start(wt);
+	rv = i2c_put(buf, 1, wt);
+
+	if (rv) {
+		i2c_stop(wt);
+		DBGOFF(printk("[i2c_rd] 2\n");)
+		return (0x00);
+	}
+
+	buf[0] = i2c_get(wt);
+	i2c_stop(wt);
+
+	return (buf[0]);
+}	/* i2c_rd() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+void i2c_wr(unsigned char dev_id, unsigned int offset, unsigned char val, unsigned long wt)
+{
+	unsigned char	buf[3];
+	int		rv;
+	unsigned long	ackwait;
+
+	buf[0] = dev_id;
+	buf[1] = (unsigned char) offset;
+	buf[2] = val;
+	DBGOFF(printk(" w%02x%02x%02x ", buf[0], buf[1], buf[2]);)
+
+	i2c_start(wt);
+	rv = i2c_put(buf, 3, wt);
+	i2c_stop(wt);
+
+	if (!rv) {
+		ackwait = 0L;
+		do {
+			i2c_start(wt);
+			rv = i2c_put(buf, 1, wt);
+			i2c_stop(wt);
+			if (rv == 0) {
+				DBGOFF(printk("[i2c_wr] got ack\n");)
+				break;
+			}
+		} while (++ackwait < I2C_ACK_WT);
+		DBGON(if (ackwait >= I2C_ACK_WT) printk("[i2c_wr] no ack!");)
+	}
+	DBGOFF(else printk("[i2c_wr] 1\n");)
+}	/* i2c_wr() */
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs50_setup.c linux-2.4.28/arch/ppc/platforms/obs50_setup.c
--- linux-2.4.28.orig/arch/ppc/platforms/obs50_setup.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs50_setup.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,227 @@
+/*
+ * arch/ppc/platforms/obs50_setup.c
+ *
+ * Setup routines for OpenBlockS. Essentially, this file is extracted from the
+ * modified version of drivers/ide/ide-m8xx.c by katsunori.murase@nifty.ne.jp.
+ *
+ * S.Adachi (adachi@aa.ap.titech.ac.jp, 2003/07/21)
+ *
+ * Copyright 2003 Satoshi Adachi
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/tty.h>
+#include <linux/major.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/init.h>
+#include <linux/blk.h>
+#include <linux/ioport.h>
+#include <linux/ide.h>
+#include <linux/bootmem.h>
+#include <linux/delay.h>
+
+#include <asm/mpc8xx.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/residual.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/ide.h>
+#include <asm/8xx_immap.h>
+#include <asm/machdep.h>
+#include <asm/irq.h>
+
+#include <platforms/obs50_time.h>
+
+static
+void obs_ide_init_hwif_ports (hw_regs_t *hw, ide_ioreg_t data_port,
+			      ide_ioreg_t ctrl_port, int *irq);
+
+#undef DEBUG
+/* #define DEBUG */
+
+/* ------------------------------------------------------------------------- */
+
+static int
+obs_show_cpuinfo(struct seq_file *m)
+{
+  seq_printf(m, "machine\t\t: OpenBlockS 50\n");
+  return 0;
+}
+
+static void
+obs_power_off(void)
+{
+  for (;;);
+}
+
+static void
+obs_halt(void)
+{
+  for (;;);
+}
+
+void __init
+obs_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	 unsigned long r6, unsigned long r7)
+{
+  ppc_md.show_cpuinfo	= obs_show_cpuinfo;
+  ppc_md.power_off	= obs_power_off;
+  ppc_md.halt		= obs_halt;
+
+  ppc_md.time_init	= obs_time_init;
+  ppc_md.set_rtc_time	= obs_set_rtc_time;
+  ppc_md.get_rtc_time	= obs_get_rtc_time;
+
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+  ppc_ide_md.ide_init_hwif	= obs_ide_init_hwif_ports;
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+extern void ide_interrupt_ack (void *dev);
+extern void m8xx_ide_tuneproc(ide_drive_t *drive, u8 pio);
+
+typedef	struct ide_ioport_desc {
+  unsigned long	base_off;		/* Offset to PCMCIA memory	*/
+  ide_ioreg_t reg_off[IDE_NR_PORTS];	/* controller register offsets	*/
+  int irq;				/* IRQ				*/
+} ide_ioport_desc_t;
+
+/* In the next line, do not use "extern ide_ioport_t *ioport_dsc;".
+   It leads to "ioport_dsc == 0"!!!. */
+extern ide_ioport_desc_t ioport_dsc[];
+
+#define OBSIDE_VERSION_INFO "IDE driver for OBS Version 1.2.0"
+#define	OBS_IDE_RESET	(0x0008)	/* in Port C bit3 */
+
+static
+void obs_ide_init_hwif_ports (hw_regs_t *hw, ide_ioreg_t data_port,
+			      ide_ioreg_t ctrl_port, int *irq)
+{
+  ide_ioreg_t *p = hw->io_ports;
+  int i;
+  static unsigned long ide_base = 0;
+  static unsigned long ide_sub_base = 0;
+  unsigned long base;
+
+  *p = 0;
+  if (irq)
+    *irq = 0;
+
+  printk(KERN_INFO OBSIDE_VERSION_INFO "\n");
+
+  if (!ide_base) {
+ 
+    /* reset-pin setup */
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcpar &= ~OBS_IDE_RESET;
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdir |=  OBS_IDE_RESET;
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcso  &= ~OBS_IDE_RESET;
+
+    /* IDE RESET off, on, wait, off */
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat |=  OBS_IDE_RESET;
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat &= ~OBS_IDE_RESET;
+    udelay(100);
+    ((immap_t *)IMAP_ADDR)->im_ioport.iop_pcdat |=  OBS_IDE_RESET;
+    udelay(10);
+
+    /* IDE wake up */
+    for (i = 0; i < 1000; i++) {
+      /* FIXME: WDT clear in here */
+      udelay(100);
+    }
+
+    /* io area mapping */
+    ide_base = (unsigned long)
+      ioremap(CFG_ATA_BASE_ADDR, CFG_ATA_SIZE);
+    ide_sub_base = (unsigned long)
+      ioremap(CFG_ATA_SUB_BASE_ADDR, CFG_ATA_SUB_SIZE);
+  }
+
+  if (data_port >= MAX_HWIFS)
+    return;
+
+  base = ide_base;
+  
+  for (i = 0; i < IDE_NR_PORTS - 1; ++i) {
+    if (i == IDE_CONTROL_OFFSET) {
+      base = ide_sub_base;
+    }
+#ifdef DEBUG
+    printk ("IDE port[%d]: %08lx + %08lx = %08lx\n",
+	    i,
+	    base,
+	    ioport_dsc[data_port].reg_off[i],
+	    base + ioport_dsc[data_port].reg_off[i]);
+#endif
+    *p++ = base + ioport_dsc[data_port].reg_off[i];
+  }
+
+  /* 0x1e:status[BSY] check */
+  for (i = 0; i < 10000; i++) { 
+    udelay(400);
+    if ((*((volatile ushort *)hw->io_ports[IDE_STATUS_OFFSET])
+	 & BUSY_STAT) == 0) {
+      break;
+    }
+  }
+
+  printk ("IDE init %s\n", (i >= 10000) ? "timeout" : "done");
+
+  if (irq) {
+    /* direct connected IDE drive, i.e. external IRQ */
+    *irq = ioport_dsc[data_port].irq;
+  }
+
+  /* register routine to tune PIO mode */
+  ide_hwifs[data_port].tuneproc = m8xx_ide_tuneproc;
+
+  hw->ack_intr = (ide_ack_intr_t *) ide_interrupt_ack;
+  /* Enable Harddisk Interrupt,
+   * and make it edge sensitive
+   */
+  /* (11-18) Set edge detect for irq, no wakeup from low power mode */
+  ((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel |=
+    (0x80000000 >> ioport_dsc[data_port].irq);
+}
+
+/* ------------------------------------------------------------------------- */
+
+ /* special function for IDE interface */
+void OUT_BYTE(unsigned char dat, ide_ioreg_t port)
+{
+  unsigned short sdat;
+
+  sdat = dat;
+  _outsw_ns((u16 *)port, &sdat, 1);
+}
+
+unsigned char IN_BYTE(ide_ioreg_t port)
+{
+  unsigned short s;
+
+  _insw_ns((u16 *)port, &s, 1);
+  return s; 
+}
+
+/* ------------------------------------------------------------------------- */
+/*   *END*                                                                   */
+/* ------------------------------------------------------------------------- */
+
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs50_time.c linux-2.4.28/arch/ppc/platforms/obs50_time.c
--- linux-2.4.28.orig/arch/ppc/platforms/obs50_time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs50_time.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,392 @@
+/* @@ES TANIA */
+/*=============================================================================
+ *	Routines to get and set the system time from/to a Dallas DS1307/8
+ *	Real Time Clock chip.  Useful for MPC860-compatible boards which
+ *	do not supply "keep-alive" power to the CPU RTC registers.
+ *
+ *	Written for Century Systems' Embedded Server
+ *	2000.6.5
+ *	T. Oka
+ *	Century Systems, Inc.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * Modified by Century Systems Inc.(http://www.centurysys.co.jp/)
+ *
+ *============================================================================*/
+
+/*-----------------------------------------------------------------------------
+ *	RTC_REBOOT_NOTIFY (2000.6.16):
+ *	Kept for possible future use, but currently does not work
+ *	as intended.  It was designed to provide a method of saving
+ *	the current Linux time at shutdown, but for reasons as
+ *	yet unknown, the notification function is not consistently
+ *	called (seems to depend on the method used to shut down).
+ *----------------------------------------------------------------------------*/
+#undef RTC_REBOOT_NOTIFY
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/spinlock.h>
+#include <linux/mc146818rtc.h>
+#ifdef RTC_REBOOT_NOTIFY
+# include <linux/notifier.h>
+# include <linux/reboot.h>
+#endif
+#include <platforms/obs50_time.h>
+
+#include <asm/time.h> /* For to_tm() */
+#include <asm/errno.h>
+
+#ifndef BCD_TO_BIN
+# define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+# define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+/*-----------------------------------------------------------------------------
+ *	Define RTC_EPOCH_1970 to interpret the RTC 00..99 year as 1970..2069.
+ *	If undefined, the RTC year will be treated as an offset from a
+ *	configurable epoch.
+ *----------------------------------------------------------------------------*/
+#define RTC_EPOCH_1970
+
+#define RTC_DEFAULT_EPOCH	(2000)
+
+#define RTC_HW_WAIT		(200L)
+
+/* Identifies the DS1307/8 device on the bus. */
+#define RTC_DEV_ID		(0xd0)
+
+#define RTC_HW_INIT()		i2c_init()
+#define RTC_HW_RD(offset)	i2c_rd(RTC_DEV_ID, (offset), RTC_HW_WAIT)
+#define RTC_HW_WR(offset, val)	i2c_wr(RTC_DEV_ID, (offset), (val), RTC_HW_WAIT)
+
+/*-----------------------------------------------------------------------------
+ *	Offsets of RTC registers.
+ *	NOTE:  day of week register (offset 3) not used
+ *----------------------------------------------------------------------------*/
+#define RTC_REG_SEC	(0x00)
+#define RTC_REG_MIN	(0x01)
+#define RTC_REG_HOUR	(0x02)
+#define RTC_REG_DATE	(0x04)
+#define RTC_REG_MON	(0x05)
+#define RTC_REG_YEAR	(0x06)
+#define RTC_REG_CTRL	(0x07)
+
+extern void i2c_init(void);
+extern unsigned char i2c_rd(unsigned char, unsigned int, unsigned long);
+extern void i2c_wr(unsigned char, unsigned int, unsigned char, unsigned long);
+
+unsigned long obs_get_rtc_time(void);
+int obs_set_rtc_time(unsigned long);
+long obs_time_init(void);
+
+/*-----------------------------------------------------------------------------
+ *	Local prototypes.
+ *----------------------------------------------------------------------------*/
+
+#ifndef RTC_EPOCH_1970
+static int obs_is_valid_epoch(unsigned int epoch);
+static unsigned int obsk_get_epoch(void);
+static void obs_set_epoch(unsigned int epoch);
+#endif
+
+#ifdef RTC_REBOOT_NOTIFY
+int obs_on_shutdown(struct notifier_block *this, unsigned long code, void *unused);
+#else /* RTC_REBOOT_NOTIFY */
+void obs_on_shutdown(void);
+#endif /* RTC_REBOOT_NOTIFY */
+
+#ifdef RTC_REBOOT_NOTIFY
+/*-----------------------------------------------------------------------------
+ *	Structure used for shutdown/reboot notification.
+ *----------------------------------------------------------------------------*/
+static struct notifier_block rtcbak_notifier = {obs_on_shutdown, NULL, 0};
+#endif
+
+/*-----------------------------------------------------------------------------
+ *	Returns the date/time read from the RTC chip, converted to
+ *	seconds since 1970-01-01 00:00:00.
+ *
+ *	CAUTION:
+ *	Uses mktime() to perform the conversion, and thus is subject
+ *	to any overflow problems that function has.
+ *----------------------------------------------------------------------------*/
+unsigned long obs_get_rtc_time(void)
+{
+	unsigned int	yr, mo, dt, hr, mn, sc;
+	unsigned int	tmp;	/* used in converting hours to 24-hour clock */
+	unsigned long	flags;
+
+	save_flags(flags);
+	cli();
+	yr = (unsigned int) RTC_HW_RD(RTC_REG_YEAR);
+	mo = (unsigned int) RTC_HW_RD(RTC_REG_MON);
+	dt = (unsigned int) RTC_HW_RD(RTC_REG_DATE);
+	hr = (unsigned int) RTC_HW_RD(RTC_REG_HOUR);
+	mn = (unsigned int) RTC_HW_RD(RTC_REG_MIN);
+	sc = (unsigned int) RTC_HW_RD(RTC_REG_SEC);
+	restore_flags(flags);
+
+	/* mask out unused or other-purpose bits */
+	mo &= 0x0000001f;
+	dt &= 0x0000003f;
+	if ((hr & 0x00000060) == 0x00000060) {
+		/* 12-hour mode, P.M. - convert to 24-hour format */
+		tmp = hr & 0x0000001f;
+		BCD_TO_BIN(tmp);
+		tmp += 12;
+		BIN_TO_BCD(tmp);	/* reverse back to BCD for below */
+		hr = tmp;
+	}
+	else {
+		/* 24-hour clock or
+			12-hour A.M. (A.M. bit is 0 so can use same mask) */
+		if ((hr & 0x00000070) == 0x00000030) {
+			/* this probably should not happen, but it does... */
+			hr &= 0x0000001f;
+		}
+		hr &= 0x0000003f;
+	}
+	mn &= 0x0000007f;
+	sc &= 0x0000007f;	/* mask out CH bit */
+
+	BCD_TO_BIN(yr);
+	BCD_TO_BIN(mo);
+	BCD_TO_BIN(dt);
+	BCD_TO_BIN(hr);
+	BCD_TO_BIN(mn);
+	BCD_TO_BIN(sc);
+
+	/* do not use bad values from the RTC */
+	if ((yr > 99) || (mo < 1 || mo > 12) || (dt < 1 || dt > 31) ||
+					(hr > 23) || (mn > 59) || (sc > 59)) {
+		/* illegal value */
+		return (mktime(1970, 1, 1, 0, 0, 0));	/* EARLY RETURN */
+	}
+
+#ifdef RTC_EPOCH_1970
+	/*
+	 *	The 00..99 year range supported by the chip is used
+	 *	as an offset from 1970.
+	 */
+	yr += ((yr <= 69) ? 2000 : 1900);
+#else
+	/*
+	 *	The 00..99 year range supported by the chip is used
+	 *	as an offset from the current epoch.
+	 */
+	yr += obs_get_epoch();
+#endif
+
+	return (mktime(yr, mo, dt, hr, mn, sc));
+}	/* obs_set_rtc_time() */
+
+/*-----------------------------------------------------------------------------
+ *	Sets the given date/time to the RTC chip.
+ *
+ *	tv_sec is interpreted as the number of seconds since
+ *	1970-0101 00:00:00 UTC.
+ *
+ *	CAUTION:
+ *	Uses to_tm() to perform the conversion, and thus is subject
+ *	to any overflow problems that function has.
+ *----------------------------------------------------------------------------*/
+int obs_set_rtc_time(unsigned long tv_sec)
+{
+	struct rtc_time	rtc;
+	unsigned long	flags;
+	unsigned char	yr, mo, dt, hr, mn, sc;
+	unsigned int	year;
+#ifndef RTC_EPOCH_1970
+	unsigned int	new_epoch;
+#endif
+
+	/* convert to a Gregorian date (includes leap year adjustments, etc.) */
+	to_tm(tv_sec, &rtc);
+
+#ifdef RTC_EPOCH_1970
+	if ((rtc.tm_year < 1970) || (rtc.tm_year > 2069)) {
+		/* year out of range 1970..2069 */
+		return (-EINVAL);	/* EARLY RETURN */
+	}
+	else {
+		year = rtc.tm_year;
+		year -= ((year < 2000) ? 1900 : 2000);
+	}
+#else
+	year = (unsigned int) rtc.tm_year;
+	new_epoch = year - (year % 100);
+
+	if (obs_get_epoch() == new_epoch) {
+		year -= new_epoch;
+	}
+	else {
+		if (obs_is_valid_epoch(new_epoch)) {
+			obs_set_epoch(new_epoch);
+			year -= new_epoch;
+		}
+		else {
+			/* illegal epoch! */
+			/* old epoch value will be used */
+			year %= 100;
+		}
+	}	/* epoch has changed */
+#endif
+	/* year is now a 00..99 offset from the (possibly new) epoch */
+
+	yr = year;
+	mo = rtc.tm_mon;
+	dt = rtc.tm_mday;
+	hr = rtc.tm_hour;
+	mn = rtc.tm_min;
+	sc = rtc.tm_sec;
+
+	/* do not set bad values to the RTC */
+	if ((yr > 99) || (mo < 1 || mo > 12) || (dt < 1 || dt > 31) ||
+					(hr > 23) || (mn > 59) || (sc > 59)) {
+		/* illegal value ignored */
+		return (-EINVAL);	/* EARLY RETURN */
+	}
+
+	/* convert to Binary-Coded Decimal format used by RTC chip */
+	BIN_TO_BCD(yr);
+	BIN_TO_BCD(mo);
+	BIN_TO_BCD(dt);
+	BIN_TO_BCD(hr);
+	BIN_TO_BCD(mn);
+	BIN_TO_BCD(sc);
+
+	hr &= ~(0x40);		/* need 24-hour clock */
+	sc &= ~0x80;		/* make sure oscillator enabled (CH) */
+
+	/* write it to the RTC chip */
+	save_flags(flags);
+	cli();
+	RTC_HW_WR(RTC_REG_YEAR, yr);
+	RTC_HW_WR(RTC_REG_MON, mo);
+	RTC_HW_WR(RTC_REG_DATE, dt);
+	RTC_HW_WR(RTC_REG_HOUR, hr);
+	RTC_HW_WR(RTC_REG_MIN, mn);
+	RTC_HW_WR(RTC_REG_SEC, sc);
+	restore_flags(flags);
+
+	return (0);
+}	/* obs_set_rtc_time() */
+
+#ifndef RTC_EPOCH_1970
+/*-----------------------------------------------------------------------------
+ *	Determines if value is acceptable as an epoch (not out of range
+ *	for conversion functions).
+ *----------------------------------------------------------------------------*/
+int obs_is_valid_epoch(unsigned int epoch)
+{
+	if (epoch > 1900) {
+		return (1);
+	}
+	return (0);
+}	/* obs_is_valid_epoch() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+unsigned int obs_get_epoch(void)
+{
+	unsigned int	epoch;
+	int		fd;
+
+#ifdef TODO
+	epoch = read from file or get from parameter?;
+#else
+	epoch = RTC_DEFAULT_EPOCH;
+#endif
+	if (!obs_is_valid_epoch(epoch)) {
+		epoch = RTC_DEFAULT_EPOCH;
+	}
+
+	return (epoch);
+}	/* obs_get_epoch() */
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+void obs_set_epoch(unsigned int epoch)
+{
+	/* TODO write epoch to file or parameter */
+}	/* obs_set_epoch() */
+#endif
+
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+long __init obs_time_init(void)
+{
+	unsigned long	flags;
+	unsigned char	tmp;	/* temporarily holds register value */
+	struct timeval	tv;
+
+	printk(KERN_INFO "RTC Backup utility\n");
+
+	save_flags(flags);
+	cli();
+
+	RTC_HW_INIT();	/* initialize hardware */
+
+	/* make sure oscillator is enabled */
+	tmp = RTC_HW_RD(RTC_REG_SEC);
+	if (tmp & 0x80) {
+		tmp &= ~(0x80);		/* clear CH bit */
+		RTC_HW_WR(RTC_REG_SEC, tmp);
+	}
+
+	/* initialize control register */
+	RTC_HW_WR(RTC_REG_CTRL, 0x00);	/* OUT low, SQW disabled, freq 1 Hz */
+
+	restore_flags(flags);
+
+	tv.tv_usec = 0;
+	tv.tv_sec = obs_get_rtc_time();
+	do_settimeofday(&tv);
+
+#ifdef RTC_REBOOT_NOTIFY
+	/*
+	 *	Arrange to be notified at shutdown so that we can update the
+	 *	Dallas RTC with the current system time.
+ 	 *
+	 *	One of the reasons for doing it this way is so that the saved
+	 *	value is consistent with the automatic adjustments Linux makes
+	 *	to keep the time accurate.  Another is epoch wraps.
+	 */
+	register_reboot_notifier(&obs_notifier);
+#endif
+	return (0);
+}	/* obs_time_init() */
+
+#ifdef RTC_REBOOT_NOTIFY
+/*-----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+int obs_on_shutdown(struct notifier_block *this, unsigned long code, void *unused)
+{
+	struct timeval	xtv;
+
+	/* get current system time value */
+	do_gettimeofday(&xtv);
+
+	/* write it to the RTC chip */
+	obs_set_time(xtv.tv_sec);
+
+	return (NOTIFY_DONE);
+}	/* rtcbak_on_shutdown() */
+#endif
+
+#ifndef RTC_REBOOT_NOTIFY
+void obs_on_shutdown(void) {}
+#endif /* RTC_REBOOT_NOTIFY */
+
+/* module_init(rtcbak_init); */
+/* module_exit(rtcbak_on_shutdown); */
diff -Naru linux-2.4.28.orig/arch/ppc/platforms/obs50_time.h linux-2.4.28/arch/ppc/platforms/obs50_time.h
--- linux-2.4.28.orig/arch/ppc/platforms/obs50_time.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/arch/ppc/platforms/obs50_time.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,34 @@
+/*
+ * arch/ppc/platforms/obs50_time.h
+ *
+ * This header file is extracted from the corresponding C source file
+ * obs_time.c, which is written by
+ *
+ *    T. Oka
+ *    Century Systems, Inc.
+ *    
+ * Copyright 2003 S.Adachi
+ *    
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version. 
+ */ 
+
+#ifndef __PLATFORMS_OBS50_TIME_H__
+#define __PLATFORMS_OBS50_TIME_H__
+
+extern unsigned long obs_get_rtc_time(void);
+extern int obs_set_rtc_time(unsigned long tv_sec);
+extern int obs_is_valid_epoch(unsigned int epoch);
+extern unsigned int obs_get_epoch(void);
+extern void obs_set_epoch(unsigned int epoch);
+extern long __init obs_time_init(void);
+
+#ifdef RTC_REBOOT_NOTIFY
+extern int obs_on_shutdown(struct notifier_block *this, unsigned long code, void *unused);
+#else /* RTC_REBOOT_NOTIFY */
+extern void obs_on_shutdown(void);
+#endif /* RTC_REBOOT_NOTIFY */
+
+#endif /* __PLATFORMS_OBS50_TIME_H__ */
diff -Naru linux-2.4.28.orig/drivers/char/Config.in linux-2.4.28/drivers/char/Config.in
--- linux-2.4.28.orig/drivers/char/Config.in	2004-08-08 08:26:04.000000000 +0900
+++ linux-2.4.28/drivers/char/Config.in	2005-01-31 11:52:56.000000000 +0900
@@ -307,6 +307,22 @@
 dep_tristate 'AMD 76x native power management (Experimental)' CONFIG_AMD_PM768 $CONFIG_PCI
 tristate '/dev/nvram support' CONFIG_NVRAM
 tristate 'Enhanced Real Time Clock Support' CONFIG_RTC
+if [ "$CONFIG_I2C" = "y" ]; then
+   tristate 'X1226 RTC support' CONFIG_X1226_RTC
+   tristate 'I2C EEPROM support' CONFIG_I2C_EEPROM
+fi
+if [ "$CONFIG_OBS50" = "y" ]; then
+   tristate 'OpenBlockS Push button' CONFIG_OBS50_PUSHSW
+   tristate 'OpenBlockS Segment LED' CONFIG_OBS50_SLED
+fi
+if [ "$CONFIG_OBS200" = "y" ]; then
+   tristate 'OpenBlockS Push button' CONFIG_OBS200_PUSHSW
+   tristate 'OpenBlockS Segment LED' CONFIG_OBS200_SLED
+fi
+if [ "$CONFIG_OBS266" = "y" ]; then
+   tristate 'OpenBlockS Push button' CONFIG_OBS266_PUSHSW
+   tristate 'OpenBlockS LED' CONFIG_OBS266_LED
+fi
 if [ "$CONFIG_IA64" = "y" ]; then
    bool 'EFI Real Time Clock Services' CONFIG_EFI_RTC
 fi
diff -Naru linux-2.4.28.orig/drivers/char/Makefile linux-2.4.28/drivers/char/Makefile
--- linux-2.4.28.orig/drivers/char/Makefile	2004-08-08 08:26:04.000000000 +0900
+++ linux-2.4.28/drivers/char/Makefile	2005-01-31 11:52:56.000000000 +0900
@@ -257,6 +257,14 @@
 ifeq ($(CONFIG_PPC),)
   obj-$(CONFIG_NVRAM) += nvram.o
 endif
+obj-$(CONFIG_X1226_RTC) += x1226-rtc.o
+obj-$(CONFIG_I2C_EEPROM) += eepromi2c.o
+obj-$(CONFIG_OBS50_PUSHSW) += pushsw_obs50.o
+obj-$(CONFIG_OBS50_SLED) += segled_obs50.o
+obj-$(CONFIG_OBS200_PUSHSW) += pushsw_obs200.o
+obj-$(CONFIG_OBS200_SLED) += segled_obs200.o
+obj-$(CONFIG_OBS266_PUSHSW) += pushsw_obs266.o
+obj-$(CONFIG_OBS266_LED) += led_obs266.o
 obj-$(CONFIG_TOSHIBA) += toshiba.o
 obj-$(CONFIG_I8K) += i8k.o
 obj-$(CONFIG_DS1620) += ds1620.o
diff -Naru linux-2.4.28.orig/drivers/char/eepromi2c.c linux-2.4.28/drivers/char/eepromi2c.c
--- linux-2.4.28.orig/drivers/char/eepromi2c.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/char/eepromi2c.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,444 @@
+/*
+ *  linux/drivers/char/eepromi2c.c
+ *
+ *
+ *  Copyright 
+ *  Author: 2002 AXE Inc.  
+ *     	takawata@axe-inc.co.jp
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  TODO:
+ *    - implement alarm and periodic IRQ support.
+ *
+ */
+/*
+ *  Based On 
+ *  linux/drivers/char/x1226-rtc.c
+ *
+ *  I2C Real Time Clock Client Driver for Xicor X1226 RTC/Calendar
+ *
+ *  Copyright 2002 MontaVista Software Inc.
+ *  Author: MontaVista Software, Inc.
+ *     	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  TODO:
+ *    - implement alarm and periodic IRQ support.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/rtc.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/time.h>
+#include <linux/devfs_fs_kernel.h>
+
+#define EEPROM_MAJOR 240
+struct eepromi2c_private
+{
+	u8 ei2_addr;
+	int ei2_size;
+	int ei2_maxpage;
+	int use_count;
+	unsigned char *tmpbuf;
+	struct i2c_client *ei2_i2c;
+	devfs_handle_t ei2_dfsh;
+};
+static spinlock_t eeprom_state_lock = SPIN_LOCK_UNLOCKED;
+
+
+struct eepromi2c_private eepromi2c_conf[]=
+{
+	{0x57, 0x200, 64, 0, NULL, NULL, NULL},
+	{0x51, 0x2000, 32, 0, NULL, NULL, NULL}
+};
+
+#define MAXEEPROMDEVS (sizeof(eepromi2c_conf)/ sizeof(struct eepromi2c_private))
+#ifndef I2C_DRIVER_ID_LARGEEEPROM
+#define I2C_DRIVERID_LARGEEEPROM I2C_DRIVERID_EXP1
+#endif
+#ifndef I2C_M_WR
+#define I2C_M_WR 0x0
+#endif
+
+#ifdef DEBUG_I2CEEPROM
+#define	dbg(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define	dbg(fmt, args...)
+#endif
+
+#define I2CEEPROM_MODULE_NAME "LARGEEEPROM"
+#define PFX I2CEEPROM_MODULE_NAME
+
+#define err(format, arg...) printk(KERN_ERR PFX ": " format , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format , ## arg)
+#define emerg(format, arg...) printk(KERN_EMERG PFX ": " format , ## arg)
+
+static struct i2c_driver i2ceeprom_driver;
+
+static int i2ceeprom_read(struct i2c_client *client,
+			  u16 reg_offset, u8 *buf, int len)
+{
+	int ret;
+	u8 regbuf[2] = { reg_offset>>8, reg_offset };
+	struct i2c_msg random_addr_read[2] = {
+		{
+			/* "Set Current Address" */
+			client->addr,
+			client->flags | I2C_M_WR,
+			sizeof(regbuf),
+			regbuf
+		},
+		{
+			/* "Sequential Read" if len>1,
+			   "Current Address Read" if len=1 */
+			client->addr ,
+			client->flags| I2C_M_RD ,
+			len,
+			buf
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, random_addr_read, 2)) != 2) {
+		ret = -ENXIO;
+		dbg("i2c_transfer failed\n");
+	}
+
+	return ret;
+}
+
+static int i2ceeprom_write(struct i2c_client *client,
+			   u16 reg_offset, u8 *buf, int len)
+{
+	int ret;
+	u8* local_buf;
+	u8 regbuf[2] = { reg_offset>>8, reg_offset };
+	struct i2c_msg page_write = {
+		client->addr,
+		client->flags ,
+		len + sizeof(regbuf),
+		NULL
+	};
+
+	if ((local_buf = (u8*)kmalloc(len + sizeof(regbuf),
+				      GFP_KERNEL)) == NULL) {
+		err("buffer alloc failed\n");
+		return -ENOMEM;
+	}
+
+	memcpy(local_buf, regbuf, sizeof(regbuf));
+	memcpy(local_buf + sizeof(regbuf), buf, len);
+	page_write.buf = local_buf;
+	
+	if ((ret = i2c_transfer(client->adapter, &page_write, 1)) != 1) {
+		ret = -ENXIO;
+		dbg("i2c_transfer failed\n");
+	}
+
+	kfree(local_buf);
+	return ret;
+}
+
+static long long eepromi2c_llseek(struct file *file, loff_t offset, int origin)
+{
+	int minor;
+	struct inode *minode = file->f_dentry->d_inode;
+	struct eepromi2c_private *pri;
+
+	if ((minor = MINOR(minode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	pri = &eepromi2c_conf[minor];
+	switch (origin) {
+	case 0:
+		file->f_pos = offset;
+		return file->f_pos;
+	case 1:
+		file->f_pos += offset;
+		return file->f_pos;
+	case 2:
+		file->f_pos = pri->ei2_size - offset;
+		return file->f_pos;
+	default:
+		return -EINVAL;
+	}
+}
+
+static ssize_t eepromi2c_read(struct file *file, char *buf, size_t count,
+			      loff_t *ppos)
+{
+	int minor;
+	struct i2c_client *client;
+	struct eepromi2c_private *pri;
+	int offset, remaining, copysize;
+	struct inode *minode = file->f_dentry->d_inode;
+	if ((minor = MINOR(minode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	pri = &eepromi2c_conf[minor];
+	if (!(client = pri->ei2_i2c))
+		return -ENXIO;
+	offset = *ppos;
+	if ((offset + count) > pri->ei2_size)
+		count = pri->ei2_size - offset;
+	if (count <= 0) {
+		return 0;
+	}
+	remaining = count;
+	do {
+		copysize = (remaining > pri->ei2_maxpage)
+				? pri->ei2_maxpage : remaining;
+		dbg("; copysize=%d\n", copysize);	
+		i2ceeprom_read(client, offset, pri->tmpbuf, copysize);
+		if (copy_to_user(buf, pri->tmpbuf, copysize))
+			return -EFAULT;
+		*ppos += copysize;
+		offset += copysize;
+		buf += copysize;
+		remaining -= copysize;
+	} while (remaining > 0);
+	return count;
+}
+
+static ssize_t eepromi2c_write(struct file *file, const char *buf, size_t count,
+			       loff_t *ppos)
+{
+	int minor;
+	struct i2c_client *client;
+	struct eepromi2c_private *pri;
+	int offset, remaining, copysize;
+	struct inode *minode = file->f_dentry->d_inode;
+	if ((minor = MINOR(minode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	pri = &eepromi2c_conf[minor];
+	if (!(client = pri->ei2_i2c))
+		return -ENXIO;
+	offset = *ppos;
+	if ((offset + count) > pri->ei2_size)
+		count = pri->ei2_size - offset;
+	if (count <= 0) {
+		return 0;
+	}
+	/*Write regeon should be aligned */
+	copysize = (count > pri->ei2_maxpage) ? pri->ei2_maxpage : count;
+	if ((offset / pri->ei2_maxpage) !=
+	    ((offset + copysize) / pri->ei2_maxpage))
+		copysize = pri->ei2_maxpage - (offset % pri->ei2_maxpage);
+	dbg("; offset=%d\n", offset);
+	remaining = count;
+	do {
+		dbg("; copysize=%d\n", copysize);
+		if (copy_from_user(pri->tmpbuf, buf, copysize)) {
+			return -EFAULT;
+		}
+
+		i2ceeprom_write(client, offset, pri->tmpbuf, copysize);
+		*ppos += copysize;
+		offset += copysize;
+		buf += copysize;
+		remaining -= copysize;
+		copysize = (remaining > pri->ei2_maxpage)
+				? pri->ei2_maxpage : remaining;
+	} while (remaining > 0);
+	return count;
+}
+
+int eepromi2c_open(struct inode *minode, struct file *mfile)
+{
+	int minor;
+	spin_lock(&eeprom_state_lock);
+	if ((minor = MINOR(minode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	if (!eepromi2c_conf[minor].ei2_i2c)
+		return -ENXIO;
+
+	if (eepromi2c_conf[minor].use_count)
+		return -EBUSY;
+	eepromi2c_conf[minor].use_count++;
+	spin_unlock(&eeprom_state_lock);
+	return 0;
+}
+
+static int eepromi2c_ioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	return -ENOTTY;
+}
+
+static int eepromi2c_release(struct inode *inode, struct file *file)
+{
+	int minor;
+	spin_lock(&eeprom_state_lock);
+	if ((minor = MINOR(inode->i_rdev)) >= MAXEEPROMDEVS)
+		return -ENXIO;
+	eepromi2c_conf[minor].use_count--;
+	spin_unlock(&eeprom_state_lock);
+	return 0;
+}
+
+static struct file_operations eepromi2c_fops = {
+	owner:		THIS_MODULE,
+	llseek:		eepromi2c_llseek,
+	read:		eepromi2c_read,
+	write:		eepromi2c_write,
+	ioctl:		eepromi2c_ioctl,
+	open:		eepromi2c_open,
+	release:	eepromi2c_release,
+};
+
+
+
+
+static int i2ceeprom_probe(struct i2c_adapter *adap)
+{
+	int ret, res, i;
+#if 0
+	char nbuffer[15];
+#endif
+	unsigned char stat;
+	struct i2c_client *this_client;
+
+	res = -ENXIO;
+	devfs_register_chrdev(EEPROM_MAJOR, "eepromi2c", &eepromi2c_fops);
+
+	this_client = kmalloc(sizeof(*this_client), GFP_KERNEL);
+
+	for (i = 0; i < MAXEEPROMDEVS; i++) {
+		if (this_client == NULL) {
+			break;
+		}
+		strcpy(this_client->name, I2CEEPROM_MODULE_NAME);
+		this_client->id = i2ceeprom_driver.id;
+		this_client->flags = 0;
+		this_client->addr = eepromi2c_conf[i].ei2_addr;
+		this_client->adapter = adap;
+		this_client->driver = &i2ceeprom_driver;
+
+		if ((res = i2ceeprom_read(this_client, 0, &stat, 1)) < 0) {
+			printk("Probe read %d\n", res);
+			continue;
+		}
+
+		if ((eepromi2c_conf[i].tmpbuf =
+		     kmalloc(eepromi2c_conf[i].ei2_size, GFP_KERNEL)) == NULL) {
+			continue;
+		}
+
+		printk("Serial EEPROM FOUND at %x\n", this_client->addr);
+		if (i2c_attach_client(this_client)) {
+			continue;
+		}
+#if 0
+		/*DEVFS NOT SUPPORTED YET */
+		sprintf(buffer, "eepromi2c%d", i);
+		eepromi2c_conf[i].ei2_dfsh =
+			devfs_register(NULL, nbuffer, DEVFS_FL_DEFAULT,
+				       EEPROM_MAJOR, 2, S_IFCHR,
+				       &eepromi2c_fops, NULL);
+#endif
+		this_client->data = &eepromi2c_conf[i];
+		eepromi2c_conf[i].ei2_i2c = this_client;
+		ret = 0;	/*At least 1 dev found */
+		this_client = kmalloc(sizeof(*this_client), GFP_KERNEL);
+	}
+	kfree(this_client);
+	return ret;
+}
+
+static int i2ceeprom_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+
+	kfree(client);
+
+	return 0;
+}
+
+static int i2ceeprom_command(struct i2c_client *client, unsigned int cmd,
+			     void *arg)
+{
+
+	return -EINVAL;
+}
+
+
+static struct i2c_driver i2ceeprom_driver = {
+	name:		I2CEEPROM_MODULE_NAME,
+	id:		I2C_DRIVERID_LARGEEEPROM,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	i2ceeprom_probe,
+	detach_client:	i2ceeprom_detach,
+	command:	i2ceeprom_command
+};
+
+
+static __init int i2ceeprom_init(void)
+{
+	int ret;
+	
+	info("I2C based EEPROM driver.\n");
+	ret = i2c_add_driver(&i2ceeprom_driver);
+	if (ret) {
+		err("Register I2C driver failed, errno is %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit i2ceeprom_exit(void)
+{
+	i2c_del_driver(&i2ceeprom_driver);
+}
+
+module_init(i2ceeprom_init);
+module_exit(i2ceeprom_exit);
diff -Naru linux-2.4.28.orig/drivers/char/led_obs266.c linux-2.4.28/drivers/char/led_obs266.c
--- linux-2.4.28.orig/drivers/char/led_obs266.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/char/led_obs266.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,215 @@
+/*
+ * FILE NAME ibm_ocp_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  API for IBM PowerPC 4xx GPIO device.
+ *  Driver for IBM PowerPC 4xx GPIO device.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *          Debbie Chu   <debbie_chu@mvista.com>
+ *
+ * Copyright 2000,2001,2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define OBSLED_VER	"0.01"
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/pm.h>
+#include <asm/ibm_ocp_gpio.h>
+#include <asm/ocp.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+
+#define OBSLED_MINOR	SEGLED_MINOR
+
+
+#define GPIO_BIT(n)	(1 << (31 - (n)))
+#define PAT_1	GPIO_BIT(12)
+#define PAT_2	GPIO_BIT(13)
+#define PAT_4	GPIO_BIT(14)
+
+static struct gpio_regs *gpiop;
+static int is_open = 0;
+
+static int
+obsled_open(struct inode *inode, struct file *file)
+{
+	if (is_open) return -EALREADY;
+	is_open = 1;
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static int
+obsled_release(struct inode *inode, struct file *file)
+{
+	is_open = 0;
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+
+static int
+obsled_out_reg(int led, u32 *or, u32 *tcr)
+{
+	__u32 data;
+	__u32 mask = PAT_1 | PAT_2 | PAT_4;
+	data = 0;
+	if (led & 1) data |= PAT_1;
+	if (led & 2) data |= PAT_2;
+	if (led & 4) data |= PAT_4;
+
+	*or = (*or & ~mask) | ((~data) & mask);
+	eieio();
+	*tcr = *tcr | mask;
+	eieio();
+	return 0;
+}
+
+int
+obsled_out_pat(int led)
+{
+	return obsled_out_reg(led, &gpiop->or, &gpiop->tcr);
+}
+
+static ssize_t obsled_write(struct file *file, const char *buf, size_t count,
+			    loff_t *ppos)
+{
+	int err, i, led;
+
+	if (count <= 0) {
+		return 0;
+	}
+
+	for (i = 0; i < count; i++) {
+		err = get_user(led, buf + i);
+		if (err) {
+			return err;
+		}
+		if (led < '0' || '7' < led) {
+			/* skip */
+			continue;
+		}
+		err = obsled_out_pat(led);
+		if (err) {
+			return err;
+		}
+	}
+
+	return count;
+}
+
+static struct file_operations obsled_fops = {
+	.owner		= THIS_MODULE,
+	.write		= obsled_write,
+	.open		= obsled_open,
+	.release	= obsled_release,
+};
+
+struct miscdevice obsled_miscdev = {
+	.minor		= OBSLED_MINOR,
+	.name		= "OBS266 LED",
+	.fops		= &obsled_fops,
+};
+
+static int __devinit obsled_probe(struct ocp_device *pdev)
+{
+	printk("OBS_LED driver version %s\n", OBSLED_VER);
+
+	misc_register(&obsled_miscdev);	/*obsled_miscdev); */
+
+	pdev->def->vaddr = ioremap(pdev->def->paddr, sizeof (struct gpio_regs));
+	gpiop = (struct gpio_regs *)pdev->def->vaddr;
+	printk("GPIO at 0x%lx\n", (unsigned long) gpiop);
+
+	ocp_force_power_on(pdev);
+	return 1;
+}
+
+static void __devexit obsled_remove_one (struct ocp_device *pdev)
+{
+	ocp_force_power_off(pdev);
+	misc_deregister(&obsled_miscdev);
+}
+
+static struct ocp_device_id obsled_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_GPIO},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,obsled_id_tbl );
+
+static struct ocp_driver obsled_driver = {
+	.name		= "obs_led",
+	.id_table	= obsled_id_tbl,
+	.probe		= obsled_probe,
+	.remove		= __devexit_p(obsled_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_generic_suspend,
+	.resume		= ocp_generic_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init
+obsled_init(void)
+{
+	printk("OBS_LED driver version %s\n", OBSLED_VER);
+	return ocp_module_init(&obsled_driver);
+}
+
+void __exit
+obsled_fini(void)
+{
+	ocp_unregister_driver(&obsled_driver);
+}
+
+module_init(obsled_init);
+module_exit(obsled_fini);
+
+MODULE_LICENSE("GPL");
+
+#define GPIO_OR		((u32 *)0xef600700)
+#define GPIO_TCR	((u32 *)0xef600704)
+int
+obsled_out(int led)
+{
+	return obsled_out_reg(led, GPIO_OR, GPIO_TCR);
+}
+
diff -Naru linux-2.4.28.orig/drivers/char/pushsw_obs200.c linux-2.4.28/drivers/char/pushsw_obs200.c
--- linux-2.4.28.orig/drivers/char/pushsw_obs200.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/char/pushsw_obs200.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,202 @@
+/*
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Century's push button driver
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <asm/irq.h>
+/* #include <asm/ppc4xx.h> */
+#include <asm/pushsw_obs2xx.h>
+
+#define DBGON(x)        x
+#define DBGOFF(x)
+
+
+#define PSW_VER		"0.01"
+#define PSW_IRQ		25      /* AIC_INT25 */
+#define PD_IRQ		30      /* AIC_INT30 */
+
+/*----------------------------------------------------------------------------
+ *	Prototypes.
+ *----------------------------------------------------------------------------*/
+/* int psw_init(void); */
+static
+void psw_isr(int irq, void *dev_id, struct pt_regs *regs);
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int psw_open(struct inode *inode, struct file *file);
+static int psw_release(struct inode *inode, struct file *file);
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static struct file_operations	psw_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		psw_ioctl,
+	open:		psw_open,
+	release:	psw_release,
+};
+static struct miscdevice	psw_miscdev =
+	{ PUSHSW_MINOR, "pushsw", &psw_fops };
+static DECLARE_WAIT_QUEUE_HEAD(psw_wait);
+
+/* used to allow only one process at a time to "own" the push switch */
+static pid_t			psw_wait_pid = 0;
+static unsigned long 		PowerFail = 0;
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int __init psw_init(void)
+{
+	printk("Push switch driver v%s\n", PSW_VER);
+
+	/* Install the push switch interrupt handler */
+	if (request_irq(PSW_IRQ, psw_isr, SA_INTERRUPT, "push switch", NULL)) {
+		printk("[psw_open] interrupt %u not free\n", PSW_IRQ);
+		return (-EIO);
+	}
+	/* Install the power down interrupt handler */
+	if (request_irq(PD_IRQ, psw_isr, SA_INTERRUPT, "power down", NULL)) {
+		printk("[psw_open] interrupt %u not free\n", PD_IRQ);
+		return (-EIO);
+	}
+	DBGOFF(printk("[psw_init] Push switch installed on interrupt %u\n", PSW_IRQ);)
+	DBGOFF(printk("[psw_init] Power down installed on interrupt %u\n", PD_IRQ);)
+	misc_register(&psw_miscdev);
+	return (0);
+}	/* psw_init() */
+
+static void __exit psw_exit (void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq (PSW_IRQ, NULL);
+	free_irq (PD_IRQ, NULL);
+}
+
+module_init(psw_init);
+module_exit(psw_exit);
+EXPORT_NO_SYMBOLS;
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static
+void psw_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	DBGOFF(printk(KERN_CRIT "p");)
+	wake_up_interruptible(&psw_wait);
+	if (irq == PD_IRQ)
+	{
+		PowerFail = 1;
+		/* free_irq(PD_IRQ, NULL); */
+		mtdcr(DCRN_UIC_TR(UIC0), (mfdcr(DCRN_UIC_TR(UIC0)) | 0x00000002));
+	}
+}	/* psw_isr() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned long	flags;
+
+	if (MINOR(inode->i_rdev) != PUSHSW_MINOR) {
+		return (-ENODEV);
+	}
+
+	switch (cmd) {
+		case PSWIOC_GETWAITPID:
+			return (put_user(psw_wait_pid, (int *) arg));
+		case PSWIOC_WAITPUSH:
+			/* protect psw_wait_pid */
+			save_flags(flags);
+			cli();
+			if (psw_wait_pid == 0) {
+				psw_wait_pid = current->pid;
+				restore_flags(flags);
+				DBGOFF(printk("[psw_ioctl] PSWIOC_WAITPUSH pid %u\n", psw_wait_pid);)
+				/* block until switch pushed */
+				if (!PowerFail)
+					interruptible_sleep_on(&psw_wait);
+				save_flags(flags);
+				cli();
+				psw_wait_pid = 0;
+				restore_flags(flags);
+
+				DBGOFF(printk("[psw_ioctl] unblocked\n");)
+				if (signal_pending(current)) {
+					DBGOFF(printk("[psw_ioctl] sig\n");)
+					return (-ERESTARTSYS);
+				}
+				return (0);
+			}
+			else {
+				restore_flags(flags);
+				return (-EBUSY);
+			}
+		default:
+			break;
+	}
+	return (-ENOIOCTLCMD);
+}	/* psw_ioctl() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_open(struct inode *inode, struct file *file)
+{
+	switch (MINOR(inode->i_rdev)) {
+		case PUSHSW_MINOR:
+			MOD_INC_USE_COUNT;
+			return (0);
+		default:
+			return (-ENODEV);
+	}
+}	/* psw_open() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_release(struct inode *inode, struct file *file)
+{
+	unsigned long	flags;
+
+	DBGOFF(printk("[psw_release] ");)
+	if (MINOR(inode->i_rdev) == PUSHSW_MINOR) {
+		DBGOFF(printk("by pid %u\n", current->pid);)
+		save_flags(flags);
+		cli();
+		if (psw_wait_pid && (psw_wait_pid == current->pid)) {
+			psw_wait_pid = 0;
+			restore_flags(flags);
+			DBGOFF(printk("cleared\n");)
+		}
+		else {
+			restore_flags(flags);
+			DBGOFF(if (psw_wait_pid) printk("psw_wait_pid %u, current->pid %u\n", psw_wait_pid, current->pid);)
+		}
+		MOD_DEC_USE_COUNT;
+	}
+	return (0);
+}	/* psw_release() */
+
+
+#ifdef MODULE
+
+#define psw_init init_module
+
+void cleanup_module(void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq(PSW_IRQ, NULL);
+	free_irq(PD_IRQ, NULL);
+}	/* cleanup_module() */
+
+#endif
diff -Naru linux-2.4.28.orig/drivers/char/pushsw_obs266.c linux-2.4.28/drivers/char/pushsw_obs266.c
--- linux-2.4.28.orig/drivers/char/pushsw_obs266.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/char/pushsw_obs266.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,172 @@
+/*
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Century's push button driver
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <asm/irq.h>
+#include <asm/pushsw_obs2xx.h>
+
+#define DBGON(x)	
+#define DBGOFF(x)	x
+
+
+#define PSW_VER		"0.01"
+#define PSW_IRQ		26 /* AIC_INT1 */
+
+/*----------------------------------------------------------------------------
+ *	Prototypes.
+ *----------------------------------------------------------------------------*/
+int psw_init(void);
+void psw_isr(int irq, void *dev_id, struct pt_regs *regs);
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int psw_open(struct inode *inode, struct file *file);
+static int psw_release(struct inode *inode, struct file *file);
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static struct file_operations	psw_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		psw_ioctl,
+	open:		psw_open,
+	release:	psw_release,
+};
+static struct miscdevice	psw_miscdev =
+	{ PUSHSW_MINOR, "pushsw", &psw_fops };
+static DECLARE_WAIT_QUEUE_HEAD(psw_wait);
+
+/* used to allow only one process at a time to "own" the push switch */
+static pid_t			psw_wait_pid = 0;
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+int
+psw_init(void)
+{
+	printk("Push switch driver v%s\n", PSW_VER);
+
+	/* Install the push switch interrupt handler */
+	if (request_irq(PSW_IRQ, psw_isr, SA_INTERRUPT, "push switch", NULL)) {
+		printk("[psw_open] interrupt %u not free\n", PSW_IRQ);
+		return (-EIO);
+	}
+	DBGOFF(printk("[psw_init] Push switch installed on interrupt %u\n", PSW_IRQ);)
+	misc_register(&psw_miscdev);
+	return (0);
+}	/* psw_init() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+void
+psw_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* DBGOFF(printk(KERN_CRIT "p");) */
+	wake_up_interruptible(&psw_wait);
+}	/* psw_isr() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int
+psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	unsigned long arg)
+{
+	unsigned long	flags;
+
+	if (MINOR(inode->i_rdev) != PUSHSW_MINOR) {
+		return (-ENODEV);
+	}
+
+	switch (cmd) {
+	case PSWIOC_GETWAITPID:
+		return (put_user(psw_wait_pid, (int *) arg));
+	case PSWIOC_WAITPUSH:
+		/* protect psw_wait_pid */
+		save_flags(flags);
+		cli();
+		if (psw_wait_pid == 0) {
+			psw_wait_pid = current->pid;
+			restore_flags(flags);
+			DBGOFF(printk("[psw_ioctl] PSWIOC_WAITPUSH pid %u\n", psw_wait_pid);)
+			/* block until switch pushed */
+			interruptible_sleep_on(&psw_wait);
+			save_flags(flags);
+			cli();
+			psw_wait_pid = 0;
+			restore_flags(flags);
+
+			DBGOFF(printk("[psw_ioctl] unblocked\n");)
+			if (signal_pending(current)) {
+				DBGOFF(printk("[psw_ioctl] sig\n");)
+				return (-ERESTARTSYS);
+			}
+			return (0);
+		} else {
+			restore_flags(flags);
+			return (-EBUSY);
+		}
+	default:
+		break;
+	}
+	return (-ENOIOCTLCMD);
+}	/* psw_ioctl() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int
+psw_open(struct inode *inode, struct file *file)
+{
+	switch (MINOR(inode->i_rdev)) {
+	case PUSHSW_MINOR:
+		MOD_INC_USE_COUNT;
+		return (0);
+	default:
+		return (-ENODEV);
+	}
+}	/* psw_open() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int
+psw_release(struct inode *inode, struct file *file)
+{
+	unsigned long	flags;
+
+	DBGOFF(printk("[psw_release] ");)
+	if (MINOR(inode->i_rdev) == PUSHSW_MINOR) {
+		DBGOFF(printk("by pid %u\n", current->pid);)
+		save_flags(flags);
+		cli();
+		if (psw_wait_pid && (psw_wait_pid == current->pid)) {
+			psw_wait_pid = 0;
+			restore_flags(flags);
+			DBGOFF(printk("cleared\n");)
+		} else {
+			restore_flags(flags);
+			DBGOFF(if (psw_wait_pid) printk("psw_wait_pid %u, current->pid %u\n", psw_wait_pid, current->pid);)
+		}
+		MOD_DEC_USE_COUNT;
+	}
+	return (0);
+}	/* psw_release() */
+
+static void
+psw_exit(void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq(PSW_IRQ, NULL);
+}	/* cleanup_module() */
+module_init(psw_init);
+module_exit(psw_exit);
diff -Naru linux-2.4.28.orig/drivers/char/pushsw_obs50.c linux-2.4.28/drivers/char/pushsw_obs50.c
--- linux-2.4.28.orig/drivers/char/pushsw_obs50.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/char/pushsw_obs50.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,277 @@
+/*
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Century's push button driver
+ *
+ * Support for OpenBlockS 50.
+ * Copyright (C) 2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- replaced from arch/ppc/kernel and rename to pushsw_obs50.c
+ *		- removed PUSHSW_MINOR, it defined linux/miscdevice.h 
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <asm/irq.h>
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+#include <asm/pushsw_obs2xx.h>
+
+#define DBGON(x)	x
+#define DBGOFF(x)
+
+#define PSW_VER		"0.01"
+#define PSW_IRQ		(SIU_IRQ2)
+
+/* bit mask for PSW_IRQ in SIMASK, etc. */
+#define SIU_IRQ		(0x08000000)
+#define SIU_WM		(SIU_IRQ >> 1)
+
+/*----------------------------------------------------------------------------
+ *	Prototypes.
+ *----------------------------------------------------------------------------*/
+static void psw_isr(int irq, void *dev_id, struct pt_regs *regs);
+static int psw_status(void);
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static void psw_hw_init(void);
+static int psw_open(struct inode *inode, struct file *file);
+static int psw_release(struct inode *inode, struct file *file);
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static struct file_operations	psw_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		psw_ioctl,
+	open:		psw_open,
+	release:	psw_release,
+};
+static struct miscdevice	psw_miscdev =
+	{ PUSHSW_MINOR, "pushswitch", &psw_fops };
+static DECLARE_WAIT_QUEUE_HEAD(psw_wait);
+
+/* used to allow only one process at a time to "own" the push switch */
+static pid_t			psw_wait_pid = 0;
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int __init psw_init(void)
+{
+	printk("Push switch driver v%s\n", PSW_VER);
+
+	psw_hw_init();
+
+	/* install the interrupt handler */
+	if (request_8xxirq(PSW_IRQ, psw_isr, SA_INTERRUPT, "pushswitch", NULL)) {
+		printk("[psw_open] interrupt %u not free\n", PSW_IRQ);
+		return (-EIO);
+	}
+	DBGOFF(printk("[psw_init] installed on interrupt %u\n", PSW_IRQ);)
+
+	misc_register(&psw_miscdev);
+	return (0);
+}	/* psw_init() */
+
+
+static void __exit psw_exit(void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq(PSW_IRQ, NULL);
+}
+
+module_init(psw_init);
+module_exit(psw_exit);
+EXPORT_NO_SYMBOLS;
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static void psw_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	DBGOFF(printk(KERN_CRIT "p");)
+	wake_up_interruptible(&psw_wait);
+}	/* psw_isr() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_status(void)
+{
+	if (((immap_t *) IMAP_ADDR)->im_ioport.iop_padat & 0x0020) {
+		DBGOFF(printk("[psw_status] notpushed\n");)
+		return (PSWIOF_NOTPUSHED);
+	}
+	else {
+		DBGOFF(printk("[psw_status] pushed\n");)
+		return (PSWIOF_PUSHED);
+	}
+}	/* psw_status() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned long	flags;
+
+	if (MINOR(inode->i_rdev) != PUSHSW_MINOR) {
+		return (-ENODEV);
+	}
+
+	switch (cmd) {
+		case PSWIOC_GETWAITPID:
+			return (put_user(psw_wait_pid, (int *) arg));
+		case PSWIOC_GETSTATUS:
+			return (put_user(psw_status(), (int *) arg));
+		case PSWIOC_WAITPUSH:
+			/* protect psw_wait_pid */
+			save_flags(flags);
+			cli();
+			if (psw_wait_pid == 0) {
+				psw_wait_pid = current->pid;
+				restore_flags(flags);
+				DBGOFF(printk("[psw_ioctl] PSWIOC_WAITPUSH pid %u\n", psw_wait_pid);)
+				/* block until switch pushed */
+				interruptible_sleep_on(&psw_wait);
+
+				save_flags(flags);
+				cli();
+				psw_wait_pid = 0;
+				restore_flags(flags);
+
+				DBGOFF(printk("[psw_ioctl] unblocked\n");)
+				if (signal_pending(current)) {
+					DBGOFF(printk("[psw_ioctl] sig\n");)
+					return (-ERESTARTSYS);
+				}
+				DBGOFF(if (psw_status() == PSWIOF_NOTPUSHED)
+						printk("not pushed?\n");)
+				return (0);
+			}
+			else {
+				restore_flags(flags);
+				return (-EBUSY);
+			}
+		default:
+			break;
+	}
+	return (-ENOIOCTLCMD);
+}	/* psw_ioctl() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static void psw_hw_init(void)
+{
+	unsigned long	i;
+	unsigned long	flags;
+
+	save_flags(flags);
+	cli();
+
+	DBGOFF({
+		printk("IMAP_ADDR: 0x%08x\n", IMAP_ADDR);
+		printk("&sc_siel: 0x%08x\n",
+			(&((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel));
+		printk("sc_sipend: 0x%08x\n",
+				((immap_t *) IMAP_ADDR)->im_siu_conf.sc_sipend);
+		printk("sc_simask: 0x%08x\n",
+				((immap_t *) IMAP_ADDR)->im_siu_conf.sc_simask);
+		printk("sc_siel: 0x%08x\n\n",
+				((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel);
+	})
+
+	/* PA10 push switch general purpose input */
+	((immap_t *) IMAP_ADDR)->im_ioport.iop_papar &= ~0x0020;
+	((immap_t *) IMAP_ADDR)->im_ioport.iop_padir &= ~0x0020;
+	((immap_t *) IMAP_ADDR)->im_ioport.iop_paodr &= ~0x0020;
+
+	/* initial hardware setup for push switch interrupt */
+
+	/* disable IRQ */
+	((immap_t *) IMAP_ADDR)->im_siu_conf.sc_simask &= ~SIU_IRQ;
+
+	/* we want an interrupt at notpushed==>pushed edge */
+	((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel |= (SIU_IRQ | SIU_WM);
+
+	/* clear IRQ pending */
+	((immap_t *) IMAP_ADDR)->im_siu_conf.sc_sipend |= SIU_IRQ;
+
+	for (i = 0L; i < 10000UL; i++) {}
+
+	/* enable IRQ */
+	((immap_t *) IMAP_ADDR)->im_siu_conf.sc_simask |= SIU_IRQ;
+
+	restore_flags(flags);
+
+	DBGOFF({
+		printk("pa:par:dir:odr 0x%08x 0x%08x 0x%08x \n",
+		       ((immap_t *) IMAP_ADDR)->im_ioport.iop_papar,
+		       ((immap_t *) IMAP_ADDR)->im_ioport.iop_padir,
+		       ((immap_t *) IMAP_ADDR)->im_ioport.iop_paodr);
+		printk("sc_sipend: 0x%08x\n",
+		       ((immap_t *) IMAP_ADDR)->im_siu_conf.sc_sipend);
+		printk("sc_simask: 0x%08x\n",
+		       ((immap_t *) IMAP_ADDR)->im_siu_conf.sc_simask);
+		printk("sc_siel: 0x%08x\n",
+		       ((immap_t *) IMAP_ADDR)->im_siu_conf.sc_siel);
+	})
+}	/* psw_hw_init() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_open(struct inode *inode, struct file *file)
+{
+	switch (MINOR(inode->i_rdev)) {
+		case PUSHSW_MINOR:
+			MOD_INC_USE_COUNT;
+			return (0);
+		default:
+			return (-ENODEV);
+	}
+}	/* psw_open() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int psw_release(struct inode *inode, struct file *file)
+{
+	unsigned long	flags;
+
+	DBGOFF(printk("[psw_release] ");)
+	if (MINOR(inode->i_rdev) == PUSHSW_MINOR) {
+		DBGOFF(printk("by pid %u\n", current->pid);)
+		save_flags(flags);
+		cli();
+		if (psw_wait_pid && (psw_wait_pid == current->pid)) {
+			psw_wait_pid = 0;
+			restore_flags(flags);
+			DBGOFF(printk("cleared\n");)
+		}
+		else {
+			restore_flags(flags);
+			DBGOFF(if (psw_wait_pid) printk("psw_wait_pid %u, current->pid %u\n", psw_wait_pid, current->pid);)
+		}
+		MOD_DEC_USE_COUNT;
+	}
+	return (0);
+}	/* psw_release() */
+
+
+#ifdef MODULE
+
+#define psw_init init_module
+
+void cleanup_module(void)
+{
+	misc_deregister(&psw_miscdev);
+	free_irq(PSW_IRQ, NULL);
+}	/* cleanup_module() */
+
+#endif
diff -Naru linux-2.4.28.orig/drivers/char/segled_obs200.c linux-2.4.28/drivers/char/segled_obs200.c
--- linux-2.4.28.orig/drivers/char/segled_obs200.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/char/segled_obs200.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,453 @@
+/*
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Century's 7 segment LED driver
+ *      2002-01-06 ozawa CONFIG_OBSS
+ *              - remove '+' shutdown procedure...
+ * 	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#ifdef CONFIG_4xx
+/* #include <asm/ppc4xx.h> */
+#include <asm/ibm4xx.h>
+#endif
+#ifdef CONFIG_8xx
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+#endif
+
+#include <asm/io.h>     /* for ioremap() */
+#include <asm/segled_obs200.h>
+
+#define DBGON(x)	x
+#define DBGOFF(x)
+
+
+#define SL_VER		"0.01"
+
+#define SL_MAX_TEST	(3)
+#define SL_TEST_DELAY	(0x00C00000UL)
+#define SL_DELAY(n)	for (delay = 0L; delay < (n); delay++) {}
+#define SL_OPEN_MAX	(0xffffffff)
+
+/*
+#define OPNT ((volatile unsigned char *)(0x40000000))
+*/
+static volatile unsigned char * OPNT;
+
+#if !defined(CONFIG_OBS200)
+#define GPIO0_OR ((volatile unsigned long *)(0xef600700))
+#define GPIO0_TCR ((volatile unsigned long *)(0xef600704))
+#define GPIO0_ODR ((volatile unsigned long *)(0xef600718))
+#define GPIO0_IR ((volatile unsigned long *)(0xef60071c))
+#endif  /* !CONFIG_OBS200 */
+/*----------------------------------------------------------------------------
+ *	Prototypes.
+ *----------------------------------------------------------------------------*/
+/* int sl_init(void); */
+static ssize_t sl_write(struct file *file, const char *buf, size_t count, loff_t *ppos);
+static int sl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+static int sl_open(struct inode *inode, struct file *file);
+static int sl_release(struct inode *inode, struct file *file);
+static unsigned long sl_v2p(unsigned int v);
+static void sl_hw_test(void);
+static void sl_set(unsigned long val);
+static void sl_set_dp(int dp);
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static struct file_operations	sl_fops = {
+	owner:		THIS_MODULE,
+	ioctl:		sl_ioctl,
+	open:		sl_open,
+	release:	sl_release,
+	write:		sl_write,
+};
+
+static struct miscdevice	sl_miscdev =
+	{ SEGLED_MINOR, "segled", &sl_fops };
+
+static unsigned long	sl_open_count = 0L;
+static pid_t		sl_owner_pid = 0;
+
+#if !defined(CONFIG_OBS200)
+static unsigned long	firsttime = 1;
+#endif
+
+static unsigned long		sl_v2p_table[16] = {
+	SL_V0, SL_V1, SL_V2, SL_V3, SL_V4, SL_V5, SL_V6, SL_V7,
+	SL_V8, SL_V9, SL_VA, SL_VB, SL_VC, SL_VD, SL_VE, SL_VF
+};
+
+/*----------------------------------------------------------------------------
+ *	Driver registration.
+ *----------------------------------------------------------------------------*/
+static int __init sl_init(void)
+{
+	printk("7-segment LED driver v%s\n", SL_VER);
+	OPNT = ioremap(0x40000000, 4096);
+	misc_register(&sl_miscdev);
+
+	return (0);
+}	/* sl_init() */
+
+static void __exit sl_exit (void)
+{
+	misc_deregister(&sl_miscdev);
+}
+
+module_init(sl_init);
+module_exit(sl_exit);
+EXPORT_NO_SYMBOLS;
+
+/*----------------------------------------------------------------------------
+ *	Return the segment pattern value corresponding to the given value.
+ *
+ *	Parameters:
+ *		v:	Value between 0 and 15.
+ *
+ *	Returns:
+ *		0:	Range error.
+ *		else:	The segment pattern to use to represent the value.
+ *			Can be used as the argument to sl_set().
+ *----------------------------------------------------------------------------*/
+static unsigned long sl_v2p(unsigned int v)
+{
+	if (v > 15L) {
+		return (0L);
+	}
+	else {
+		return (sl_v2p_table[v]);
+	}
+}	/* sl_v2p() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static ssize_t sl_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	size_t		i;
+	unsigned int	digit;
+
+	if (sl_owner_pid && (sl_owner_pid != current->pid)) {
+		return (-EPERM);
+	}
+
+	DBGOFF(printk("[sl_write] count %d\n", count);)
+	DBGOFF({
+		for (i = 0L; i < count; i++) {
+			printk(" 0x%02x", buf[i]);
+		}
+	})
+
+	/* no seeks allowed on this device */
+	if (ppos != &file->f_pos) {
+		DBGOFF(printk("[sl_write] seek\n");)
+		return (-ESPIPE);
+	}
+
+	for (i = 0; i < count; i++) {
+		digit = 16;
+		if ((buf[i] >= 0x30) && (buf[i] <= 0x39)) {
+			digit = (unsigned int) (buf[i] - 0x30);
+		}
+		else {
+			switch (buf[i]) {
+			case 0x41:
+			case 0x61:
+				digit = 10;
+				break;
+			case 0x42:
+			case 0x62:
+				digit = 11;
+				break;
+			case 0x43:
+			case 0x63:
+				digit = 12;
+				break;
+			case 0x44:
+			case 0x64:
+				digit = 13;
+				break;
+			case 0x45:
+			case 0x65:
+				digit = 14;
+				break;
+			case 0x46:
+			case 0x66:
+				digit = 15;
+				break;
+			case ' ':	/* space => all off */
+				sl_set(SL_NONE);
+				break;
+			case '+':	/* '+' => DP on  */
+				sl_set_dp(1);
+#ifndef CONFIG_OBS200
+				if (firsttime)
+				{
+					printk("EXECUTING POWER SHUTDOWN\n");
+					*GPIO0_ODR &= ~(0x00200000);
+					*GPIO0_OR |= 0x00200000;
+					*GPIO0_TCR |= 0x00200000;
+					mtdcr(DCRN_CHCR0, (mfdcr(DCRN_CHCR0) | 0x04000000));
+					*GPIO0_OR &= ~(0x00200000);
+					firsttime = 0;
+				}
+#endif  /* !CONFIG_OBS200 */
+				break;
+			case '-':	/* '-' => DP off  */
+				sl_set_dp(0);
+				break;
+#if 0
+// TODO - for watchdog debug only - REMOVE!!
+case 'w':
+	printk("disabling interrupts for watchdog test - REMOVE!!!\n");
+	cli();
+	while (1) {}
+#endif
+			default:
+				break;
+			}
+		}	/* A..F, a..f, etc. */
+
+		if (digit < 16) {
+			sl_set(sl_v2p(digit));
+			DBGOFF(printk("[sl_write] ok\n");)
+		}
+	}
+
+	return (count);
+}	/* sl_write() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int sl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	extern void sys_405dc(unsigned long);
+#if 0
+	unsigned long pn, *tmp, size;
+	int i;
+#endif  /* 0 */
+
+	unsigned long	ptn;
+
+	DBGOFF(printk("!");)
+
+	if (MINOR(inode->i_rdev) != SEGLED_MINOR) {
+		return (-ENODEV);
+	}
+
+	//printk(" (cmd %x,%x) ", cmd, SLIOC_TEST405);
+	DBGOFF(printk(" cmd %u ", cmd);)
+
+	switch (cmd) {
+	case SLIOC_GET_OWNER_PID:
+		DBGOFF(printk(" SLIOC_GET_OWNER_PID ");)
+		return (put_user(sl_owner_pid, (int *) arg));
+	case SLIOC_RESERVE:
+		DBGOFF(printk(" SLIOC_RESERVE ");)
+		if (!sl_owner_pid || (sl_owner_pid == current->pid)) {
+			sl_owner_pid = current->pid;
+			DBGOFF(printk("led reserved by pid %d\n", sl_owner_pid);)
+			return (0);
+		}
+		return (-EPERM);
+	default:
+		/*
+		 *	Other commands require LED access.
+		 *	Disallow if LED has been reserved
+		 *	by another process.
+		 */
+		if (sl_owner_pid && (sl_owner_pid != current->pid)) {
+			DBGOFF(printk("disallowed (sl_owner_pid %d, current->pid %d)\n", sl_owner_pid, current->pid);)
+			return (-EPERM);
+		}
+		break;
+	}	/* switch on cmd */
+
+	DBGOFF(printk(" cmd check 2 ");)
+
+	switch (cmd) {
+		case SLIOC_SETVAL:
+			DBGOFF(printk(" SLIOC_SETVAL ");)
+			ptn = sl_v2p((unsigned int) arg);
+			if (ptn) {
+				DBGOFF(printk(" led%u ", (unsigned)arg);)
+				sl_set(ptn);
+				return (0);
+			}
+			DBGOFF(else printk(" SLIOC_SETVAL arg 0x%x ignored ",
+							(unsigned)arg);)
+			break;
+		case SLIOC_SETSEG:
+			DBGOFF(printk(" SLIOC_SETSEG ");)
+			DBGOFF(printk("!");)
+			sl_set(arg);
+			return (0);
+		case SLIOC_TEST:
+			DBGOFF(printk(" SLIOC_TEST ");)
+			sl_hw_test();
+			return (0);
+		default:
+			DBGOFF(printk(" unknown cmd %d ", cmd);)
+			break;
+	}
+	return (-ENOIOCTLCMD);
+}	/* sl_ioctl() */
+
+/*----------------------------------------------------------------------------
+ *	Set the given value to the 7-segment LED.
+ *
+ *	Parameters:
+ *		val:	Value indicating which segments should be on.
+ *			Can be built with the macros in segled.h.
+ *----------------------------------------------------------------------------*/
+static
+void sl_set(unsigned long val)
+{
+	*OPNT = 0xFF; 				/* turn off all segments */
+	*OPNT = ~(val);				/* turn on specified segments */
+}	/* sl_set() */
+
+/*----------------------------------------------------------------------------
+ *	Set the DP (dot) segment of the 7-segment LED as specified.
+ *
+ *	Parameters:
+ *		dp:	State of segment DP (dot).
+ *				0:	off
+ *				else:	on
+ *----------------------------------------------------------------------------*/
+static
+void sl_set_dp(int dp)
+{
+	if (dp) {
+		*OPNT = ~SL_DP;	/* turn DP segment on */
+	}
+	else {
+		*OPNT = SL_DP;	/* turn DP segment off */
+	}
+}	/* sl_set_dp() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int sl_open(struct inode *inode, struct file *file)
+{
+#if 1
+	switch (MINOR(inode->i_rdev)) {
+		case SEGLED_MINOR:
+			if (sl_open_count >= SL_OPEN_MAX) {
+				return (-EBUSY);
+			}
+			sl_open_count++;
+			return (0);
+		default:
+			return (-ENODEV);
+	}
+#else
+	//printk("o");
+	switch (MINOR(inode->i_rdev)) {
+		case SEGLED_MINOR:
+			sl_open_count++;
+			//printk("k");
+			return (0);
+		default:
+			printk("No");
+			return (-ENODEV);
+	}
+//	extern void PPC4xx_tlb_flush_all(void);
+//	PPC4xx_tlb_flush_all();
+//	//return (0);
+//	return (-ENODEV);
+#endif
+}	/* sl_open() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static int sl_release(struct inode *inode, struct file *file)
+{
+	if (MINOR(inode->i_rdev) == SEGLED_MINOR) {
+		if (sl_owner_pid == current->pid) {
+			DBGOFF(printk("pid %d led reserve released\n",
+								sl_owner_pid);)
+			sl_owner_pid = 0;
+		}
+		if (sl_open_count >= 1L) {
+			DBGOFF(printk("[sl_release]\n");)
+			sl_open_count--;
+		}
+		else printk("[sl_release] not open!\n");
+	}
+	return (0);
+}	/* sl_release() */
+
+/*----------------------------------------------------------------------------
+ *----------------------------------------------------------------------------*/
+static void sl_hw_test(void)
+{
+	unsigned long	delay;
+	unsigned int	test, ptn;
+
+	for (test = 0; test < SL_MAX_TEST; test++) {
+		/* all off */
+		DBGOFF(printk("all off ");)
+		sl_set(SL_NONE);
+		sl_set_dp(0);
+		SL_DELAY(SL_TEST_DELAY)
+
+		/* display 0..F in sequence */
+		for (ptn = 0; ptn <= 15; ptn++) {
+			DBGOFF(printk(" %x ", ptn);)
+			sl_set(sl_v2p_table[ptn]);
+			SL_DELAY(SL_TEST_DELAY)
+		}
+
+		/* all on */
+		DBGOFF(printk("all on ");)
+		sl_set(SL_ALL);
+		SL_DELAY(SL_TEST_DELAY)
+
+		sl_set_dp(0);	/* turn off DP */
+
+		/* turn on each segment individually */
+		DBGOFF(printk(" sA ");)
+		sl_set(SL_A);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sB ");)
+		sl_set(SL_B);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sC ");)
+		sl_set(SL_C);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sD ");)
+		sl_set(SL_D);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sE ");)
+		sl_set(SL_E);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sF ");)
+		sl_set(SL_F);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sG ");)
+		sl_set(SL_G);
+		SL_DELAY(SL_TEST_DELAY)
+		DBGOFF(printk(" sDP ");)
+		sl_set(SL_DP);
+		SL_DELAY(SL_TEST_DELAY)
+
+		DBGOFF(printk("\n");)
+	}	/* for number of times to repeat test */
+}	/* sl_hw_test() */
diff -Naru linux-2.4.28.orig/drivers/char/segled_obs50.c linux-2.4.28/drivers/char/segled_obs50.c
--- linux-2.4.28.orig/drivers/char/segled_obs50.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/char/segled_obs50.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,219 @@
+/*
+ * LED driver for OpenBlockS 50.
+ *
+ * --- Copyright (C) 2001  Masaki WAKABAYASHI <masaki@quox.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- replaced from arch/ppc/kernel and rename to segled_obs50.c
+ *		- defined OBSLED_MINOR SEGLED_MINOR 
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+
+/* version information */
+#define OBSLED_VERSION_INFO "LED driver version 1.0.0"
+
+/* character special file id */
+#define OBSLED_MAJOR MISC_MAJOR
+#define OBSLED_MINOR SEGLED_MINOR
+
+/* pointer to device */
+#define DEV ((volatile cpm8xx_t*)(&(((volatile immap_t*)IMAP_ADDR)->im_cpm)))
+
+/* ioctl command id */
+#define	OBSLED_IOCTL_BASE          'S'
+#define	OBSLED_IOCTL_SETSEG        _IOR(OBSLED_IOCTL_BASE, 2, int)
+#define OBSLED_IOCTL_GET_OWNER_PID _IOR(OBSLED_IOCTL_BASE, 3, int)
+#define OBSLED_IOCTL_RESERVE       _IOR(OBSLED_IOCTL_BASE, 4, int)
+
+/* LED digit pattern table */
+#define LEDPATTERN_0      (0x0003c003UL)
+#define LEDPATTERN_1      (0x00028000UL)
+#define LEDPATTERN_2      (0x0000c00bUL)
+#define LEDPATTERN_3      (0x0002c009UL)
+#define LEDPATTERN_4      (0x00038008UL)
+#define LEDPATTERN_5      (0x00034009UL)
+#define LEDPATTERN_6      (0x0003400bUL)
+#define LEDPATTERN_7      (0x0003c000UL)
+#define LEDPATTERN_8      (0x0003c00bUL)
+#define LEDPATTERN_9      (0x0003c009UL)
+#define LEDPATTERN_A      (0x0003c00aUL)
+#define LEDPATTERN_B      (0x0003000bUL)
+#define LEDPATTERN_C      (0x00014003UL)
+#define LEDPATTERN_D      (0x0002800bUL)
+#define LEDPATTERN_E      (0x0001400bUL)
+#define LEDPATTERN_F      (0x0001400aUL)
+#define LEDPATTERN_DOT    (0x00000004UL)
+#define LEDPATTERN_ALLBAR (LEDPATTERN_8)
+#define LEDPATTERN_NONE   (0x00000000UL)
+#define LEDPATTERN_ALL    (LEDPATTERN_ALLBAR | LEDPATTERN_DOT)
+
+/* function prototypes */
+static void obsled_set_pattern(unsigned long, unsigned long);
+static int obsled_init(void);
+static void obsled_exit(void);
+static int obsled_open(struct inode*, struct file*);
+static int obsled_release(struct inode*, struct file*);
+static ssize_t obsled_write(struct file*, const char*, size_t, loff_t*);
+static int obsled_ioctl(struct inode*, struct file*, unsigned int, unsigned long);
+
+/* stuructures for kernel module */
+static struct file_operations obsled_fops = {
+	owner:   "segled",
+	write:   obsled_write,
+	ioctl:   obsled_ioctl,
+	open:    obsled_open,
+	release: obsled_release
+};
+static struct miscdevice obsled_miscdev = {
+	OBSLED_MINOR,
+	"obsled",
+	&obsled_fops
+};
+
+/* misc variables */
+static unsigned int obsled_open_count = 0;
+static pid_t obsled_owner_pid = 0;
+
+/* set pattern to LED */
+void obsled_set_pattern(unsigned long pattern, unsigned long mask)
+{
+	unsigned long flags;
+	save_flags(flags); cli();
+	DEV->cp_pbdat = (((DEV->cp_pbdat) | ~mask) & ~pattern);
+	restore_flags(flags);
+}
+
+/* import module */
+int __init obsled_init(void)
+{
+	printk(KERN_INFO OBSLED_VERSION_INFO "\n");
+	obsled_set_pattern(LEDPATTERN_DOT, ~LEDPATTERN_ALL);
+	misc_register(&obsled_miscdev);
+	return 0;
+}
+
+/* release module */
+void obsled_exit(void)
+{
+	obsled_set_pattern(LEDPATTERN_DOT, ~LEDPATTERN_ALL);
+	misc_deregister(&obsled_miscdev);
+}
+
+/* open device */
+int obsled_open(struct inode* inode, struct file* file)
+{
+	if (MINOR(inode->i_rdev) != OBSLED_MINOR) return -ENODEV;
+	if (obsled_open_count == UINT_MAX) return -EBUSY;
+	obsled_open_count++;
+	return 0;
+}
+
+/* release device */
+int obsled_release(struct inode* inode, struct file* file)
+{
+	if (MINOR(inode->i_rdev) != OBSLED_MINOR) return 0;
+	if (obsled_owner_pid == current->pid) obsled_owner_pid = 0;
+	if (obsled_open_count > 0) obsled_open_count--;
+	return 0;
+}
+
+/* write to device */
+ssize_t obsled_write(struct file* file, const char* buf, size_t size,
+					 loff_t* ppos)
+{
+	size_t i;
+	/* owner check */
+	if (obsled_owner_pid != 0 && obsled_owner_pid != current->pid) {
+		return -EPERM;
+	}
+	/* no seeks allowed on this device */
+	if (ppos != &file->f_pos) return -ESPIPE;
+	/* show patterns */
+	for (i = 0; i < size; i++) {
+		switch (buf[i]) {
+		case '0':
+			obsled_set_pattern(LEDPATTERN_0, ~LEDPATTERN_ALLBAR); break;
+		case '1':
+			obsled_set_pattern(LEDPATTERN_1, ~LEDPATTERN_ALLBAR); break;
+		case '2':
+			obsled_set_pattern(LEDPATTERN_2, ~LEDPATTERN_ALLBAR); break;
+		case '3':
+			obsled_set_pattern(LEDPATTERN_3, ~LEDPATTERN_ALLBAR); break;
+		case '4':
+			obsled_set_pattern(LEDPATTERN_4, ~LEDPATTERN_ALLBAR); break;
+		case '5':
+			obsled_set_pattern(LEDPATTERN_5, ~LEDPATTERN_ALLBAR); break;
+		case '6':
+			obsled_set_pattern(LEDPATTERN_6, ~LEDPATTERN_ALLBAR); break;
+		case '7':
+			obsled_set_pattern(LEDPATTERN_7, ~LEDPATTERN_ALLBAR); break;
+		case '8':
+			obsled_set_pattern(LEDPATTERN_8, ~LEDPATTERN_ALLBAR); break;
+		case '9':
+			obsled_set_pattern(LEDPATTERN_9, ~LEDPATTERN_ALLBAR); break;
+		case 'A': case 'a':
+			obsled_set_pattern(LEDPATTERN_A, ~LEDPATTERN_ALLBAR); break;
+		case 'B': case 'b':
+			obsled_set_pattern(LEDPATTERN_B, ~LEDPATTERN_ALLBAR); break;
+		case 'C': case 'c':
+			obsled_set_pattern(LEDPATTERN_C, ~LEDPATTERN_ALLBAR); break;
+		case 'D': case 'd':
+			obsled_set_pattern(LEDPATTERN_D, ~LEDPATTERN_ALLBAR); break;
+		case 'E': case 'e':
+			obsled_set_pattern(LEDPATTERN_E, ~LEDPATTERN_ALLBAR); break;
+		case 'F': case 'f':
+			obsled_set_pattern(LEDPATTERN_F, ~LEDPATTERN_ALLBAR); break;
+		case ' ':
+			obsled_set_pattern(LEDPATTERN_NONE, ~LEDPATTERN_ALL); break;
+		case '+':
+			obsled_set_pattern(LEDPATTERN_DOT, ~LEDPATTERN_NONE); break;
+		case '-':
+			obsled_set_pattern(LEDPATTERN_NONE, ~LEDPATTERN_DOT); break;
+		default:
+			break;
+		}
+	}
+	return size;
+}
+
+/* ioctl device */
+int obsled_ioctl(struct inode* inode, struct file* file, unsigned int cmd,
+						unsigned long arg)
+{
+	if (MINOR(inode->i_rdev) != OBSLED_MINOR) return -ENODEV;
+	switch (cmd) {
+	case OBSLED_IOCTL_SETSEG:
+		if (obsled_owner_pid != 0 && obsled_owner_pid != current->pid) {
+			return -EPERM;
+		}
+		obsled_set_pattern(arg, ~LEDPATTERN_ALL);
+		break;
+	case OBSLED_IOCTL_GET_OWNER_PID:
+		return put_user(obsled_owner_pid, (pid_t*)arg);
+	case OBSLED_IOCTL_RESERVE:
+		if (obsled_owner_pid != 0 && obsled_owner_pid != current->pid) {
+			return -EPERM;
+		}
+		obsled_owner_pid = current->pid;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+module_init(obsled_init);
+module_exit(obsled_exit);
diff -Naru linux-2.4.28.orig/drivers/char/serial.c linux-2.4.28/drivers/char/serial.c
--- linux-2.4.28.orig/drivers/char/serial.c	2004-11-17 20:54:21.000000000 +0900
+++ linux-2.4.28/drivers/char/serial.c	2005-01-31 11:52:56.000000000 +0900
@@ -62,6 +62,9 @@
  *        Robert Schwebel <robert@schwebel.de>,
  *        Juergen Beisert <jbeisert@eurodsn.de>,
  *        Theodore Ts'o <tytso@mit.edu>
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- added UPS control for OpenBlockS 266
  */
 
 static char *serial_version = "5.05c";
@@ -289,6 +292,16 @@
 static void change_speed(struct async_struct *info, struct termios *old);
 static void rs_wait_until_sent(struct tty_struct *tty, int timeout);
 
+#if CONFIG_OBS266
+static void UPS_proc(void);
+static int ups_init(struct async_struct *info);
+static int ups_start(struct async_struct *info);
+static int ups_stop(struct async_struct *info);
+static int ups_set_timeout(int);
+extern void psw_isr(int irq, void *dev_id, struct pt_regs *regs);
+void UPS_poff(void);
+#endif
+
 /*
  * Here we define the default xmit fifo size used for each type of
  * UART
@@ -1356,7 +1369,11 @@
 	/*
 	 * Allocate the IRQ if necessary
 	 */
+#ifdef CONFIG_OBS2xx
+	if (/*state->irq &&*/ (!IRQ_ports[state->irq] ||
+#else
 	if (state->irq && (!IRQ_ports[state->irq] ||
+#endif
 			  !IRQ_ports[state->irq]->next_port)) {
 		if (IRQ_ports[state->irq]) {
 #ifdef CONFIG_SERIAL_SHARE_IRQ
@@ -1522,7 +1539,11 @@
 	/*
 	 * Free the IRQ, if necessary
 	 */
+#ifdef CONFIG_OBS2xx
+	if (/*state->irq &&*/ (!IRQ_ports[state->irq] ||
+#else
 	if (state->irq && (!IRQ_ports[state->irq] ||
+#endif
 			  !IRQ_ports[state->irq]->next_port)) {
 		if (IRQ_ports[state->irq]) {
 			free_irq(state->irq, &IRQ_ports[state->irq]);
@@ -1557,10 +1578,16 @@
 	
 	/* disable break condition */
 	serial_out(info, UART_LCR, serial_inp(info, UART_LCR) & ~UART_LCR_SBC);
-	
+
+#if CONFIG_OBS266
+	if (info->iomem_base != 0xef600400) {
+#endif
 	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
 		info->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);
 	serial_outp(info, UART_MCR, info->MCR);
+#if CONFIG_OBS266
+	}
+#endif
 
 	/* disable FIFO's */	
 	serial_outp(info, UART_FCR, (UART_FCR_ENABLE_FIFO |
@@ -2569,7 +2596,11 @@
 
 	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
 	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&
-	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
+	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)
+#if CONFIG_OBS266
+	    && (cmd != UPSIOINIT) && (cmd != UPSIOSTART) && (cmd != UPSIOSTOP)
+#endif
+	) {
 		if (tty->flags & (1 << TTY_IO_ERROR))
 		    return -EIO;
 	}
@@ -2712,7 +2743,24 @@
 			/* "setserial -W" is called in Debian boot */
 			printk ("TIOCSER?WILD ioctl obsolete, ignored.\n");
 			return 0;
-
+#if CONFIG_OBS266
+		case UPSIOINIT:
+			if (ups_init(info))
+				return -EIO;
+			return 0;
+		case UPSIOSTART:
+			if (ups_start(info))
+				return -EIO;
+			return 0;
+		case UPSIOSTOP:
+			if (ups_stop(info))
+				return -EIO;
+			return 0;
+		case UPSIOTIME:
+			if (ups_set_timeout((int)arg))
+				return -EIO;
+			return 0;
+#endif
 		default:
 			return -ENOIOCTLCMD;
 		}
@@ -6041,6 +6089,135 @@
 }
 #endif
 
+#if CONFIG_OBS266
+
+#define	UPS_IDLE	0
+#define	UPS_RUN		1
+#define	UPS_POLL	2
+#define	UPS_HALT	3
+
+#ifdef CONFIG_OBS266_UPS_DEBUG
+#define	UPS_UNITTIME	1
+#define	UPS_TIMEOUT	5
+#define	UPS_TIMEBASE	1
+#else
+#define	UPS_UNITTIME	5
+#define	UPS_TIMEOUT	300
+#define	UPS_TIMEBASE	60
+#endif
+
+static struct async_struct *ups_info = 0;
+static struct timer_list ups_timer;
+static int UPS_state = UPS_IDLE;
+static int UPS_count = 0;
+static int UPS_timeout = UPS_TIMEOUT;
+
+static void UPS_proc()
+{
+	int ctrl;
+
+	switch (UPS_state) {
+	default:
+	case UPS_IDLE:
+	case UPS_HALT:
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+		/* XXX XXX XXX */
+		printk("UPS_IDEL\n");
+#endif
+		/* just return. better than break. */
+		return;
+
+	case UPS_RUN:
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+		/* XXX XXX XXX */
+		printk("UPS_RUN\n");
+#endif
+		ctrl = serial_in(ups_info, UART_MSR);
+		if (ctrl & UART_MSR_DSR) {		/* DSR ON */
+			UPS_state = UPS_POLL;
+		}
+		break;
+
+	case UPS_POLL:
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+		/* XXX XXX XXX */
+		printk("UPS_POLL\n");
+#endif
+		ctrl = serial_in(ups_info, UART_MSR);
+		if ((ctrl & UART_MSR_DSR) == 0) {	/* DSR OFF */
+			UPS_count = 0;
+			UPS_state = UPS_RUN;
+		} else {
+			UPS_count++;
+			if (UPS_count > (UPS_timeout / UPS_UNITTIME)) {
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+				printk("psw_isr()\n");
+#endif
+				psw_isr(SA_INTERRUPT, "push switch", NULL);
+				UPS_count = 0;
+				UPS_state = UPS_HALT;
+				return;
+			}
+#ifdef	CONFIG_OBS266_UPS_DEBUG
+			printk("count = %d\n", UPS_count);
+#endif
+		}
+		break;
+	}
+	mod_timer(&ups_timer, jiffies + UPS_UNITTIME * HZ);
+}
+
+static int ups_init(struct async_struct *info)
+{
+	if (info->iomem_base != 0xef600400)
+		return -1;
+	ups_info = info;
+	init_timer(&ups_timer);
+	ups_timer.function = UPS_proc;
+	/*UPS_state = UPS_RUN;*/
+	/*mod_timer(&ups_timer, jiffies + UPS_UNITTIME * HZ);*/
+	return 0;
+}
+
+static int ups_start(struct async_struct *info)
+{
+	if (UPS_state != UPS_IDLE)
+		return -1;
+	if (info->iomem_base != 0xef600400)
+		return -1;
+	if (ups_info == 0)
+		ups_init(info);
+	info->MCR |= UART_MCR_DTR;
+	UPS_state = UPS_RUN;
+	UPS_count = 0;
+	mod_timer(&ups_timer, jiffies + UPS_UNITTIME * HZ);
+	return 0;
+}
+
+static int ups_stop(struct async_struct *info)
+{
+	if (info->iomem_base != 0xef600400)
+		return -1;
+	UPS_state = UPS_IDLE;
+	UPS_count = 0;
+	return 0;
+}
+
+static int ups_set_timeout(int time)
+{
+	if (time < 1 || time > 10)
+		return -1;
+	UPS_timeout = time * UPS_TIMEBASE;
+	return 0;
+}
+
+void UPS_poff()
+{
+	if (ups_info) serial_out(ups_info, UART_MCR, 0);
+}
+
+#endif
+
 /*
   Local variables:
   compile-command: "gcc -D__KERNEL__ -I../../include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -fno-strict-aliasing -pipe -fno-strength-reduce -march=i586 -DMODULE -DMODVERSIONS -include ../../include/linux/modversions.h   -DEXPORT_SYMTAB -c serial.c"
diff -Naru linux-2.4.28.orig/drivers/char/tty_io.c linux-2.4.28/drivers/char/tty_io.c
--- linux-2.4.28.orig/drivers/char/tty_io.c	2004-11-17 20:54:21.000000000 +0900
+++ linux-2.4.28/drivers/char/tty_io.c	2005-01-31 11:52:56.000000000 +0900
@@ -63,6 +63,9 @@
  *
  * Move do_SAK() into process context.  Less stack use in devfs functions.
  * alloc_tty_struct() always uses kmalloc() -- Andrew Morton <andrewm@uow.edu.eu> 17Mar01
+ *
+ * PlatHome <openlab.plathome.co.jp>
+ *	- Added for OpenBlockS 266
  */
 
 #include <linux/config.h>
@@ -2228,7 +2231,11 @@
 	memcpy(tty_std_termios.c_cc, INIT_C_CC, NCCS);
 	tty_std_termios.c_iflag = ICRNL | IXON;
 	tty_std_termios.c_oflag = OPOST | ONLCR;
+#ifdef CONFIG_OBS266
+	tty_std_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL;
+#else
 	tty_std_termios.c_cflag = B38400 | CS8 | CREAD | HUPCL;
+#endif
 	tty_std_termios.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK |
 		ECHOCTL | ECHOKE | IEXTEN;
 
diff -Naru linux-2.4.28.orig/drivers/char/x1226-rtc.c linux-2.4.28/drivers/char/x1226-rtc.c
--- linux-2.4.28.orig/drivers/char/x1226-rtc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/char/x1226-rtc.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,547 @@
+
+/*
+ *  linux/drivers/char/x1226-rtc.c
+ *
+ *  I2C Real Time Clock Client Driver for Xicor X1226 RTC/Calendar
+ *
+ *  Copyright 2002 MontaVista Software Inc.
+ *  Author: MontaVista Software, Inc.
+ *     	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  TODO:
+ *    - implement alarm and periodic IRQ support.
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/rtc.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+#ifdef DEBUG_X1226
+#define	dbg(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define	dbg(fmt, args...)
+#endif
+
+#define X1226_MODULE_NAME "X1226"
+#define PFX X1226_MODULE_NAME
+#ifndef I2C_DRIVERID_X1226
+#define I2C_DRIVERID_X1226  I2C_DRIVERID_EXP0
+#endif
+
+#define err(format, arg...) printk(KERN_ERR PFX ": " format , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format , ## arg)
+#define emerg(format, arg...) printk(KERN_EMERG PFX ": " format , ## arg)
+
+#define EPOCH 2000
+#define SYS_EPOCH 1900
+
+#undef BCD_TO_BIN
+#define BCD_TO_BIN(val) (((val)&15) + ((val)>>4)*10)
+
+#undef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((((val)/10)<<4) + (val)%10)
+
+#define X1226_RTC_SR      0x3f
+#define   RTC_SR_RTCF  (1)
+#define   RTC_SR_WEL  (1<<1)
+#define   RTC_SR_RWEL (1<<2)
+
+#define X1226_RTC_BASE    0x30
+
+/* This is an image of the RTC registers starting at offset 0x30 */
+struct rtc_registers {
+	unsigned char secs;  // 30
+        unsigned char mins;  // 31
+        unsigned char hours; // 32
+        unsigned char day;   // 33
+        unsigned char mon;   // 34
+        unsigned char year;  // 35
+        unsigned char dayofweek; // 36
+        unsigned char epoch; // 37
+};
+
+#define X1226_CONTROL_DTR  0x13
+#define X1226_CONTROL_ATR  0x12
+#define X1226_CONTROL_INT  0x11
+#define X1226_CONTROL_BL   0x10
+
+#define DEVID_RTC          0x6F
+#define DEVID_NVRAM        0x57
+#define   SLAVE_READ 0x01
+#ifndef I2C_M_WR
+#define I2C_M_WR 0x0
+#endif
+#define ABITS           9
+#define EESIZE          (1 << ABITS)    /* size in bytes */
+
+#define NVSIZE          512             /* we use 512 bytes */
+#define NVOFFSET        (EESIZE-NVSIZE) /* at end of EEROM */
+
+static struct i2c_driver x1226_driver;
+
+static int x1226_use_count = 0;
+
+static struct i2c_client *this_client = NULL;
+
+static int rtc_read_proc(char *page, char **start, off_t off,
+                         int count, int *eof, void *data);
+
+
+
+
+static int x1226_read (struct i2c_client *client,
+		       u8 reg_offset, u8* buf, int len)
+{
+	int ret;
+	u8 regbuf[2] = { 0, reg_offset };
+	struct i2c_msg random_addr_read[2] = {
+		{
+			/* "Set Current Address" */
+			client->addr,
+			client->flags | I2C_M_WR,
+			sizeof(regbuf),
+			regbuf
+		},
+		{
+			/* "Sequential Read" if len>1,
+			   "Current Address Read" if len=1 */
+			client->addr ,
+			client->flags| I2C_M_RD ,
+			len,
+			buf
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, random_addr_read, 2)) != 2) {
+		ret = -ENXIO;
+		dbg("i2c_transfer failed\n");
+	}
+
+	return ret;
+}
+
+static int x1226_write (struct i2c_client *client,
+			u8 reg_offset, u8* buf, int len)
+{
+	int ret;
+	u8* local_buf;
+	u8 regbuf[2] = { 0, reg_offset };
+	struct i2c_msg page_write = {
+		client->addr,
+		client->flags ,
+		len + sizeof(regbuf),
+		NULL
+	};
+
+	if ((local_buf = (u8*)kmalloc(len + sizeof(regbuf),
+				      GFP_KERNEL)) == NULL) {
+		err("buffer alloc failed\n");
+		return -ENOMEM;
+	}
+
+	memcpy(local_buf, regbuf, sizeof(regbuf));
+	memcpy(local_buf + sizeof(regbuf), buf, len);
+	page_write.buf = local_buf;
+	
+	if ((ret = i2c_transfer(client->adapter, &page_write, 1)) != 1) {
+		ret = -ENXIO;
+		dbg("i2c_transfer failed\n");
+	}
+
+	kfree(local_buf);
+	return ret;
+}
+
+
+static int ccr_write_enable(struct i2c_client *client)
+{
+	u8 sr = RTC_SR_WEL;
+	int ret;
+	if ((ret = x1226_write(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+	sr |= RTC_SR_RWEL;
+	if ((ret = x1226_write(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+	sr = 0;
+	if ((ret = x1226_read(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+
+	sr &= (RTC_SR_RWEL | RTC_SR_RWEL);
+	if (sr != (RTC_SR_RWEL | RTC_SR_RWEL)) {
+		dbg("verify SR failed\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int ccr_write_disable(struct i2c_client *client)
+{
+	int ret;
+	u8 sr = 0;
+	
+	if ((ret = x1226_write(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+	if ((ret = x1226_read(client, X1226_RTC_SR, &sr, 1)) < 0)
+		return ret;
+	if (sr != 0) {
+		dbg("verify SR failed\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+
+static int
+x1226_get_time(struct i2c_client *client, struct rtc_time *tm)
+{	
+	struct rtc_registers rtc;
+	u32 epoch;
+	int ret;
+	
+	/* read RTC registers */
+	if ((ret = x1226_read(client, X1226_RTC_BASE, (u8*)&rtc,
+			      sizeof(struct rtc_registers))) < 0) {
+		dbg("couldn't read RTC\n");
+		return ret;
+	}
+	dbg("IN: epoch=%02x, year=%02x, mon=%02x, day=%02x, hour=%02x, "
+	    "min=%02x, sec=%02x\n",
+	    rtc.epoch, rtc.year, rtc.mon, rtc.day, rtc.hours,
+	    rtc.mins, rtc.secs);
+	
+	epoch  = 100 * BCD_TO_BIN(rtc.epoch);   // 19 / 20
+	tm->tm_year = BCD_TO_BIN(rtc.year); // 0 - 99
+	tm->tm_year += (epoch - SYS_EPOCH);
+	tm->tm_mon = BCD_TO_BIN(rtc.mon);   // 1 - 12
+	tm->tm_mon--;                       /* tm_mon is 0 to 11 */
+	tm->tm_mday = BCD_TO_BIN(rtc.day);  // 1 - 31
+	tm->tm_hour = BCD_TO_BIN(rtc.hours & ~0x80);
+	if (!(rtc.hours & 0x80)) {
+		// AM/PM 1-12 format, convert to MIL
+		tm->tm_hour--; // 0 - 11
+		if (rtc.hours & (1<<5))
+			tm->tm_hour += 12; // PM
+	}
+	
+	tm->tm_min = BCD_TO_BIN(rtc.mins);
+	tm->tm_sec = BCD_TO_BIN(rtc.secs);
+
+	dbg("OUT: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+	    tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
+	    tm->tm_min, tm->tm_sec);
+	
+	return 0;
+}
+
+static int 
+x1226_set_time(struct i2c_client *client, const struct rtc_time *tm)
+{
+	struct rtc_registers rtc;
+	int ret;
+
+	dbg("IN: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+	    tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
+	    tm->tm_min, tm->tm_sec);
+
+	rtc.epoch = BIN_TO_BCD(EPOCH/100);
+	rtc.year  = BIN_TO_BCD(tm->tm_year + SYS_EPOCH - EPOCH);
+	rtc.mon   = BIN_TO_BCD(tm->tm_mon + 1); /* tm_mon is 0 to 11 */
+	rtc.day   = BIN_TO_BCD(tm->tm_mday);
+	rtc.dayofweek = 0; // ignore day of week
+	rtc.hours = BIN_TO_BCD(tm->tm_hour) | 0x80; /* 24 hour format */
+	rtc.mins  = BIN_TO_BCD(tm->tm_min);
+	rtc.secs  = BIN_TO_BCD(tm->tm_sec);
+	
+	dbg("OUT: epoch=%02x, year=%02x, mon=%02x, day=%02x, hour=%02x, "
+	    "min=%02x, sec=%02x\n",
+	    rtc.epoch, rtc.year, rtc.mon, rtc.day, rtc.hours,
+	    rtc.mins, rtc.secs);
+	
+	/* write RTC registers */
+	if ((ret = ccr_write_enable(client)) < 0)
+		return ret;
+	if ((ret = x1226_write(client, X1226_RTC_BASE, (u8*)&rtc,
+			       sizeof(struct rtc_registers))) < 0) {
+		dbg("couldn't write RTC\n");
+		return ret;
+	}
+	ccr_write_disable(client);
+
+	return 0;
+}
+
+static int
+x1226_probe(struct i2c_adapter *adap)
+{
+	int ret;
+	char stat;
+	unsigned char crs[4];
+	struct rtc_time dummy_tm={0,0,0, 1, 0, 100, 0, 0};
+	if (this_client != NULL)
+		return -EBUSY;
+	
+	this_client = kmalloc(sizeof(*this_client), GFP_KERNEL);
+	if (this_client == NULL) {
+		return -ENOMEM;
+	}
+
+	strcpy(this_client->name, X1226_MODULE_NAME);
+	this_client->id		= x1226_driver.id;
+
+	this_client->flags	= 0;
+	this_client->addr	= DEVID_RTC;
+	this_client->adapter	= adap;
+	this_client->driver	= &x1226_driver;
+	this_client->data	= NULL;
+
+	/*
+	 * use x1226_get_time() to probe for an X1226 on this bus.
+	 */
+	if((ret = x1226_read(this_client,X1226_RTC_SR, &stat, 1))< 0){
+		kfree(this_client);
+		this_client = NULL;
+		return ret;
+	}
+	info("found X1226 on %s\n", adap->name);
+	if(stat & RTC_SR_RTCF){
+	  printk("X1226:Timer Not Initialized after power fail. Setting 2002/1/1/0:00\n" );
+	  ret= x1226_set_time(this_client, &dummy_tm);
+	}
+	dbg("stat %x \n", stat);
+	x1226_read(this_client,0x10, &crs[0], 1);
+	x1226_read(this_client,0x11, &crs[1], 1);
+	x1226_read(this_client,0x12, &crs[2], 1);
+	x1226_read(this_client,0x13, &crs[3], 1);
+	dbg("CTLREG:%d %x %x %x %x\n", ret, crs[0],crs[1],crs[2],crs[3]);
+
+	if ((ret = x1226_get_time(this_client, &dummy_tm)) < 0) {
+	  printk("Fetch Timer Failed\n");
+	}else{
+#ifdef DEBUG_X1226
+	  struct rtc_time *tm = &dummy_tm;
+	  dbg("OUT: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+	    tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
+	    tm->tm_min, tm->tm_sec);
+#endif
+	}
+
+	/* attach it. */
+	return i2c_attach_client(this_client);
+}
+
+static int
+x1226_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+
+	if (this_client != NULL) {
+		kfree(this_client);
+		this_client = NULL;
+	}
+
+	return 0;
+}
+
+int rtc_open(struct inode *minode, struct file *mfile)
+{
+	/*if(MOD_IN_USE)*/
+	if(x1226_use_count > 0) {
+		return -EBUSY;
+	}
+	MOD_INC_USE_COUNT;
+	++x1226_use_count;
+	return 0;
+}
+
+int rtc_release(struct inode *minode, struct file *mfile)
+{
+	MOD_DEC_USE_COUNT;
+	--x1226_use_count;
+	return 0;
+}
+
+static loff_t rtc_llseek(struct file *mfile, loff_t offset, int origint)
+{
+	return -ESPIPE;
+}
+
+static int
+x1226_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return -EINVAL;
+}
+
+static int rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		     unsigned long arg)
+{
+	struct rtc_time rtc_tm;
+	int ret;
+	
+	switch (cmd) {
+	case RTC_RD_TIME:	/* Read the time/date from RTC  */
+		if ((ret = x1226_get_time(this_client, &rtc_tm)) < 0)
+			return ret;
+		return copy_to_user((void *)arg, &rtc_tm, sizeof(rtc_tm)) ? 
+			-EFAULT : 0;
+	case RTC_SET_TIME:	/* Set the RTC */
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		if (copy_from_user(&rtc_tm, 
+				   (struct rtc_time *) arg,
+		                   sizeof(struct rtc_time))) 
+			return -EFAULT;
+
+		return x1226_set_time(this_client, &rtc_tm);
+	default:
+		return -EINVAL;
+	}
+}
+
+
+static struct i2c_driver x1226_driver = {
+	name:		X1226_MODULE_NAME,
+	id:		I2C_DRIVERID_X1226,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	x1226_probe,
+	detach_client:	x1226_detach,
+	command:	x1226_command
+};
+
+static struct file_operations rtc_fops = {
+	owner:		THIS_MODULE,
+	llseek:		rtc_llseek,
+	ioctl:		rtc_ioctl,
+	open:		rtc_open,
+	release:	rtc_release,
+};
+
+static struct miscdevice x1226rtc_miscdev = {
+	RTC_MINOR,
+	"rtc",
+	&rtc_fops
+};
+
+static __init int x1226_init(void)
+{
+	int ret;
+
+	info("I2C based RTC driver.\n");
+	ret = i2c_add_driver(&x1226_driver);
+	if (ret) {
+		err("Register I2C driver failed, errno is %d\n", ret);
+		return ret;
+	}
+	ret = misc_register(&x1226rtc_miscdev);
+	if (ret) {
+		err("Register misc driver failed, errno is %d\n", ret);
+		ret = i2c_del_driver(&x1226_driver);
+		if (ret) {
+			err("Unregister I2C driver failed, errno is %d\n",
+			    ret);
+		}
+		return ret;
+	}
+
+	create_proc_read_entry("driver/rtc", 0, 0, rtc_read_proc, NULL);
+
+	return 0;
+}
+
+static void __exit x1226_exit(void)
+{
+        remove_proc_entry("driver/rtc", NULL);
+        misc_deregister(&x1226rtc_miscdev);
+	i2c_del_driver(&x1226_driver);
+}
+
+
+module_init(x1226_init);
+module_exit(x1226_exit);
+
+/*
+ *	Info exported via "/proc/driver/rtc".
+ */
+
+static int rtc_proc_output(char *buf)
+{
+	char *p;
+	struct rtc_time tm;
+	int ret;
+	
+	if ((ret = x1226_get_time(this_client, &tm)) < 0)
+		return ret;
+
+	p = buf;
+
+	/*
+	 * There is no way to tell if the luser has the RTC set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	p += sprintf(p,
+		     "rtc_time\t: %02d:%02d:%02d\n"
+		     "rtc_date\t: %04d-%02d-%02d\n"
+		     "rtc_epoch\t: %04d\n",
+		     tm.tm_hour, tm.tm_min, tm.tm_sec,
+		     tm.tm_year + SYS_EPOCH, tm.tm_mon + 1,
+		     tm.tm_mday, EPOCH);
+
+	return p - buf;
+}
+
+static int rtc_read_proc(char *page, char **start, off_t off,
+			 int count, int *eof, void *data)
+{
+	int len = rtc_proc_output(page);
+	if (len <= off + count)
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+MODULE_AUTHOR("Steve Longerbeam");
+MODULE_LICENSE("GPL");
+
diff -Naru linux-2.4.28.orig/drivers/i2c/Config.in linux-2.4.28/drivers/i2c/Config.in
--- linux-2.4.28.orig/drivers/i2c/Config.in	2004-04-14 22:05:29.000000000 +0900
+++ linux-2.4.28/drivers/i2c/Config.in	2005-01-31 11:52:56.000000000 +0900
@@ -38,6 +38,9 @@
          dep_tristate '  Embedded Planet RPX Lite/Classic support' CONFIG_I2C_RPXLITE $CONFIG_I2C_ALGO8XX
       fi
    fi
+   if [ "$CONFIG_IBM_OCP" = "y" ]; then
+      dep_tristate 'IBM PPC4xx I2C interface' CONFIG_I2C_IBM_OCP $CONFIG_I2C
+   fi
    if [ "$CONFIG_405" = "y" ]; then
       dep_tristate 'PPC 405 I2C Algorithm' CONFIG_I2C_PPC405_ALGO $CONFIG_I2C
       if [ "$CONFIG_I2C_PPC405_ALGO" != "n" ]; then
diff -Naru linux-2.4.28.orig/drivers/i2c/Makefile linux-2.4.28/drivers/i2c/Makefile
--- linux-2.4.28.orig/drivers/i2c/Makefile	2004-02-18 22:36:31.000000000 +0900
+++ linux-2.4.28/drivers/i2c/Makefile	2005-01-31 11:52:56.000000000 +0900
@@ -6,7 +6,7 @@
 
 export-objs	:= i2c-core.o i2c-algo-bit.o i2c-algo-pcf.o \
 		   i2c-algo-ite.o i2c-algo-sibyte.o i2c-algo-sgi.o \
-		   i2c-proc.o
+		   i2c-proc.o i2c-algo-ibm_ocp.o i2c-adap-ibm_ocp.o
 
 obj-$(CONFIG_I2C)		+= i2c-core.o
 obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
@@ -19,6 +19,7 @@
 obj-$(CONFIG_ITE_I2C_ALGO)	+= i2c-algo-ite.o
 obj-$(CONFIG_ITE_I2C_ADAP)	+= i2c-adap-ite.o
 obj-$(CONFIG_I2C_PROC)		+= i2c-proc.o
+obj-$(CONFIG_I2C_IBM_OCP)	+= i2c-algo-ibm_ocp.o i2c-adap-ibm_ocp.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_I2C_KEYWEST)	+= i2c-keywest.o
diff -Naru linux-2.4.28.orig/drivers/i2c/i2c-adap-ibm_ocp.c linux-2.4.28/drivers/i2c/i2c-adap-ibm_ocp.c
--- linux-2.4.28.orig/drivers/i2c/i2c-adap-ibm_ocp.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/i2c/i2c-adap-ibm_ocp.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,747 @@
+/*
+ * drivers/i2c/i2c-ibm_iic.c
+ *
+ * Support for the IIC peripheral on IBM PPC 4xx
+ *
+ * Copyright (c) 2003 Zultys Technologies.
+ * Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>
+ *
+ * Based on original work by 
+ * 	Ian DaSilva  <idasilva@mvista.com>
+ *      Armin Kuster <akuster@mvista.com>
+ * 	Matt Porter  <mporter@mvista.com>
+ *
+ *      Copyright 2000-2003 MontaVista Software Inc.
+ *
+ * Original driver version was highly leveraged from i2c-elektor.c
+ *
+ *   	Copyright 1995-97 Simon G. Vogl
+ *                1998-99 Hans Berglund
+ *
+ *   	With some changes from Kyti Mkki <kmalkki@cc.hut.fi> 
+ *	and even Frodo Looijaard <frodol@dds.nl>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#ifdef CONFIG_I2C_DEBUG_BUS
+#define DEBUG	1
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <asm/ocp.h>
+#include <asm/ibm4xx.h>
+
+#include "i2c-ibm_iic.h"
+
+#define DRIVER_VERSION "2.0"
+
+MODULE_DESCRIPTION("IBM IIC driver v" DRIVER_VERSION);
+MODULE_LICENSE("GPL");
+
+static int iic_force_poll = 0;
+MODULE_PARM(iic_force_poll, "i");
+MODULE_PARM_DESC(iic_force_poll, "Force polling mode");
+
+static int iic_force_fast = 0;
+MODULE_PARM(iic_force_fast, "i");
+MODULE_PARM_DESC(iic_fast_poll, "Force fast mode (400 kHz)");
+
+#define DBG_LEVEL 0
+
+#ifdef DBG
+#undef DBG
+#endif
+
+#ifdef DBG2
+#undef DBG2
+#endif
+
+static wait_queue_head_t iic_wait[2];
+static int iic_pending;
+
+#if DBG_LEVEL > 0
+#  define DBG(x...)	printk(KERN_DEBUG "ibm-iic" ##x)
+#else
+#  define DBG(x...)	((void)0)
+#endif
+#if DBG_LEVEL > 1
+#  define DBG2(x...) 	DBG( ##x )
+#else
+#  define DBG2(x...) 	((void)0)
+#endif
+#if DBG_LEVEL > 2
+static void dump_iic_regs(const char* header, struct ibm_iic_private* dev)
+{
+	volatile struct iic_regs *iic = dev->vaddr;
+	printk(KERN_DEBUG "ibm-iic%d: %s\n", dev->idx, header);
+	printk(KERN_DEBUG "  cntl     = 0x%02x, mdcntl = 0x%02x\n"
+	       KERN_DEBUG "  sts      = 0x%02x, extsts = 0x%02x\n"
+	       KERN_DEBUG "  clkdiv   = 0x%02x, xfrcnt = 0x%02x\n"
+	       KERN_DEBUG "  xtcntlss = 0x%02x, directcntl = 0x%02x\n",
+		in_8(&iic->cntl), in_8(&iic->mdcntl), in_8(&iic->sts), 
+		in_8(&iic->extsts), in_8(&iic->clkdiv), in_8(&iic->xfrcnt), 
+		in_8(&iic->xtcntlss), in_8(&iic->directcntl));
+}
+#  define DUMP_REGS(h,dev)	dump_iic_regs((h),(dev))
+#else
+#  define DUMP_REGS(h,dev)	((void)0)
+#endif
+
+/* Enable/disable interrupt generation */
+static inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable)
+{
+	out_8(&dev->vaddr->intmsk, enable ? INTRMSK_EIMTC : 0);
+}
+ 
+/*
+ * Initialize IIC interface.
+ */
+static void iic_dev_init(struct ibm_iic_private* dev)
+{
+	volatile struct iic_regs *iic = dev->vaddr;
+
+	DBG("%d: init\n", dev->idx);
+	
+	/* Clear master address */
+	out_8(&iic->lmadr, 0);
+	out_8(&iic->hmadr, 0);
+
+	/* Clear slave address */
+	out_8(&iic->lsadr, 0);
+	out_8(&iic->hsadr, 0);
+
+	/* Clear status & extended status */
+	out_8(&iic->sts, STS_SCMP | STS_IRQA);
+	out_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD | EXTSTS_LA
+			    | EXTSTS_ICT | EXTSTS_XFRA);
+
+	/* Set clock divider */
+	out_8(&iic->clkdiv, dev->clckdiv);
+
+	/* Clear transfer count */
+	out_8(&iic->xfrcnt, 0);
+
+	/* Clear extended control and status */
+	out_8(&iic->xtcntlss, XTCNTLSS_SRC | XTCNTLSS_SRS | XTCNTLSS_SWC
+			    | XTCNTLSS_SWS);
+
+	/* Clear control register */
+	out_8(&iic->cntl, 0);
+	
+	/* Enable interrupts if possible */
+	iic_interrupt_mode(dev, dev->irq >= 0);
+
+	/* Set mode control */
+	out_8(&iic->mdcntl, MDCNTL_FMDB | MDCNTL_EINT | MDCNTL_EUBS
+			    | (dev->fast_mode ? MDCNTL_FSM : 0));
+
+	DUMP_REGS("iic_init", dev);
+}
+
+/* 
+ * Reset IIC interface
+ */
+static void iic_dev_reset(struct ibm_iic_private* dev)
+{
+	volatile struct iic_regs *iic = dev->vaddr;
+	int i;
+	u8 dc;
+	
+	DBG("%d: soft reset\n", dev->idx);
+	DUMP_REGS("reset", dev);
+	
+    	/* Place chip in the reset state */
+	out_8(&iic->xtcntlss, XTCNTLSS_SRST);
+	
+	/* Check if bus is free */
+	dc = in_8(&iic->directcntl);	
+	if (!DIRCTNL_FREE(dc)){
+		DBG("%d: trying to regain bus control\n", dev->idx);
+	
+		/* Try to set bus free state */
+		out_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);	
+	
+		/* Wait until we regain bus control */
+		for (i = 0; i < 100; ++i){
+			dc = in_8(&iic->directcntl);
+			if (DIRCTNL_FREE(dc))
+				break;
+			
+			/* Toggle SCL line */
+			dc ^= DIRCNTL_SCC;
+			out_8(&iic->directcntl, dc);
+			udelay(10);
+			dc ^= DIRCNTL_SCC;
+			out_8(&iic->directcntl, dc);
+			
+			/* be nice */
+			cond_resched();
+		}
+	}
+	
+	/* Remove reset */
+	out_8(&iic->xtcntlss, 0);
+	
+	/* Reinitialize interface */
+	iic_dev_init(dev);
+}
+
+/*
+ * IIC interrupt handler
+ */
+static irqreturn_t iic_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct ibm_iic_private* dev = (struct ibm_iic_private*)dev_id;
+	volatile struct iic_regs* iic = dev->vaddr;
+	
+	DBG2("%d: irq handler, STS = 0x%02x, EXTSTS = 0x%02x\n", 
+	     dev->idx, in_8(&iic->sts), in_8(&iic->extsts));
+	
+	/* Acknowledge IRQ and wakeup iic_wait_for_tc */
+	out_8(&iic->sts, STS_IRQA | STS_SCMP);
+	wake_up_interruptible(&dev->wq);
+	
+	return IRQ_HANDLED;
+}
+
+/*
+ * Get master transfer result and clear errors if any.
+ * Returns the number of actually transferred bytes or error (<0)
+ */
+static int iic_xfer_result(struct ibm_iic_private* dev)
+{
+	volatile struct iic_regs *iic = dev->vaddr;	
+	
+	if (unlikely(in_8(&iic->sts) & STS_ERR)){
+		DBG("%d: xfer error, EXTSTS = 0x%02x\n", dev->idx, 
+			in_8(&iic->extsts));
+				
+		/* Clear errors and possible pending IRQs */
+		out_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD | 
+			EXTSTS_LA | EXTSTS_ICT | EXTSTS_XFRA);
+			
+		/* Flush master data buffer */
+		out_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);
+		
+		/* Is bus free?
+		 * If error happened during combined xfer
+		 * IIC interface is usually stuck in some strange
+		 * state, the only way out - soft reset.
+		 */
+		if ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){
+			DBG("%d: bus is stuck, resetting\n", dev->idx);
+			iic_dev_reset(dev);
+		}
+		return -EREMOTEIO;
+	}
+	else
+		return in_8(&iic->xfrcnt) & XFRCNT_MTC_MASK;
+}
+
+/*
+ * Try to abort active transfer.
+ */
+static void iic_abort_xfer(struct ibm_iic_private* dev)
+{
+	volatile struct iic_regs *iic = dev->vaddr;
+	unsigned long x;
+	
+	DBG("%d: iic_abort_xfer\n", dev->idx);
+	
+	out_8(&iic->cntl, CNTL_HMT);
+	
+	/*
+	 * Wait for the abort command to complete.
+	 * It's not worth to be optimized, just poll (timeout >= 1 tick)
+	 */
+	x = jiffies + 2;
+	while ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){
+		if (time_after(jiffies, x)){
+			DBG("%d: abort timeout, resetting...\n", dev->idx);
+			iic_dev_reset(dev);
+			return;
+		}
+		schedule();
+	}
+
+	/* Just to clear errors */
+	iic_xfer_result(dev);
+}
+
+/*
+ * Wait for master transfer to complete.
+ * It puts current process to sleep until we get interrupt or timeout expires.
+ * Returns the number of transferred bytes or error (<0)
+ */
+static int iic_wait_for_tc(struct ibm_iic_private* dev){
+	
+	volatile struct iic_regs *iic = dev->vaddr;
+	int ret = 0;
+	
+	if (dev->irq >= 0){
+		/* Interrupt mode */
+		wait_queue_t wait;
+    		init_waitqueue_entry(&wait, current);
+		
+		add_wait_queue(&dev->wq, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (in_8(&iic->sts) & STS_PT)
+			schedule_timeout(dev->adap.timeout * HZ);
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&dev->wq, &wait);
+		
+		if (unlikely(signal_pending(current))){
+			DBG("%d: wait interrupted\n", dev->idx);
+			ret = -ERESTARTSYS;
+		} else if (unlikely(in_8(&iic->sts) & STS_PT)){
+			DBG("%d: wait timeout\n", dev->idx);
+			ret = -ETIMEDOUT;
+		}
+	}
+	else {
+		/* Polling mode */
+		unsigned long x = jiffies + dev->adap.timeout * HZ;
+		
+		while (in_8(&iic->sts) & STS_PT){
+			if (unlikely(time_after(jiffies, x))){
+				DBG("%d: poll timeout\n", dev->idx);
+				ret = -ETIMEDOUT;
+				break;
+			}
+		
+			if (unlikely(signal_pending(current))){
+				DBG("%d: poll interrupted\n", dev->idx);
+				ret = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+		}	
+	}
+	
+	if (unlikely(ret < 0))
+		iic_abort_xfer(dev);
+	else
+		ret = iic_xfer_result(dev);
+	
+	DBG2("%d: iic_wait_for_tc -> %d\n", dev->idx, ret);
+	
+	return ret;
+}
+
+/*
+ * Low level master transfer routine
+ */
+static int iic_xfer_bytes(struct ibm_iic_private* dev, struct i2c_msg* pm, 
+			  int combined_xfer)
+{
+	volatile struct iic_regs *iic = dev->vaddr;
+	char* buf = pm->buf;
+	int i, j, loops, ret = 0;
+	int len = pm->len;
+
+	u8 cntl = (in_8(&iic->cntl) & CNTL_AMD) | CNTL_PT;
+	if (pm->flags & I2C_M_RD)
+		cntl |= CNTL_RW;
+	
+	loops = (len + 3) / 4;
+	for (i = 0; i < loops; ++i, len -= 4){
+		int count = len > 4 ? 4 : len;
+		u8 cmd = cntl | ((count - 1) << CNTL_TCT_SHIFT);
+		
+		if (!(cntl & CNTL_RW))
+			for (j = 0; j < count; ++j)
+				out_8((volatile u8*)&iic->mdbuf, *buf++);
+		
+		if (i < loops - 1)
+			cmd |= CNTL_CHT;
+		else if (combined_xfer)
+			cmd |= CNTL_RPST;
+		
+		DBG2("%d: xfer_bytes, %d, CNTL = 0x%02x\n", dev->idx, count, cmd);
+		
+		/* Start transfer */
+		out_8(&iic->cntl, cmd);
+		
+		/* Wait for completion */
+		ret = iic_wait_for_tc(dev);
+
+		if (unlikely(ret < 0))
+			break;
+		else if (unlikely(ret != count)){
+			DBG("%d: xfer_bytes, requested %d, transfered %d\n", 
+				dev->idx, count, ret);
+			
+			/* If it's not a last part of xfer, abort it */
+			if (combined_xfer || (i < loops - 1))
+    				iic_abort_xfer(dev);
+				
+			ret = -EREMOTEIO;
+			break;				
+		}
+		
+		if (cntl & CNTL_RW)
+			for (j = 0; j < count; ++j)
+				*buf++ = in_8((volatile u8*)&iic->mdbuf);
+	}
+	
+	return ret > 0 ? 0 : ret;
+}
+
+/*
+ * Set target slave address for master transfer
+ */
+static inline void iic_address(struct ibm_iic_private* dev, struct i2c_msg* msg)
+{
+	volatile struct iic_regs *iic = dev->vaddr;
+	u16 addr = msg->addr;
+	
+	DBG2("%d: iic_address, 0x%03x (%d-bit)\n", dev->idx, 
+		addr, msg->flags & I2C_M_TEN ? 10 : 7);
+	
+	if (msg->flags & I2C_M_TEN){
+	    out_8(&iic->cntl, CNTL_AMD);
+	    out_8(&iic->lmadr, addr);
+	    out_8(&iic->hmadr, 0xf0 | ((addr >> 7) & 0x06));
+	}
+	else {
+	    out_8(&iic->cntl, 0);
+	    out_8(&iic->lmadr, addr << 1);
+	}
+}
+
+static inline int iic_invalid_address(const struct i2c_msg* p)
+{
+	return (p->addr > 0x3ff) || (!(p->flags & I2C_M_TEN) && (p->addr > 0x7f));
+}
+
+static inline int iic_address_neq(const struct i2c_msg* p1, 
+				  const struct i2c_msg* p2)
+{
+	return (p1->addr != p2->addr) 
+		|| ((p1->flags & I2C_M_TEN) != (p2->flags & I2C_M_TEN));
+} 
+
+/*
+ * Generic master transfer entrypoint. 
+ * Returns the number of processed messages or error (<0)
+ */
+static int iic_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
+{
+    	struct ibm_iic_private* dev = (struct ibm_iic_private*)(i2c_get_adapdata(adap));
+	volatile struct iic_regs *iic = dev->vaddr;
+	int i, ret = 0;
+	
+	DBG2("%d: iic_xfer, %d msg(s)\n", dev->idx, num);
+	
+	if (!num)
+		return 0;
+	
+	/* Check the sanity of the passed messages.
+	 * Uhh, generic i2c layer is more suitable place for such code...
+	 */
+	if (unlikely(iic_invalid_address(&msgs[0]))){
+		DBG("%d: invalid address 0x%03x (%d-bit)\n", dev->idx, 
+			msgs[0].addr, msgs[0].flags & I2C_M_TEN ? 10 : 7);
+		return -EINVAL;
+	}		
+	for (i = 0; i < num; ++i){
+		if (unlikely(msgs[i].len <= 0)){
+			DBG("%d: invalid len %d in msg[%d]\n", dev->idx, 
+				msgs[i].len, i);
+			return -EINVAL;
+		}
+		if (unlikely(iic_address_neq(&msgs[0], &msgs[i]))){
+			DBG("%d: invalid addr in msg[%d]\n", dev->idx, i);
+			return -EINVAL;
+		}
+	}
+	
+	/* Check bus state */
+	if (unlikely((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE)){
+		DBG("%d: iic_xfer, bus is not free\n", dev->idx);
+		
+		/* Usually it means something serious has happend.
+		 * We *cannot* have unfinished previous transfer
+		 * so it doesn't make any sense to try to stop it.
+		 * Probably we were not able to recover from the 
+		 * previous error.
+		 * The only *reasonable* thing I can think of here
+		 * is soft reset.  --ebs
+		 */
+		iic_dev_reset(dev);
+		
+		if ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){
+			DBG("%d: iic_xfer, bus is still not free\n", dev->idx);
+			return -EREMOTEIO;
+		}
+	} 
+	else {
+		/* Flush master data buffer (just in case) */
+		out_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);
+	}
+	
+	/* Load slave address */
+	iic_address(dev, &msgs[0]);
+	
+	/* Do real transfer */
+    	for (i = 0; i < num && !ret; ++i)
+		ret = iic_xfer_bytes(dev, &msgs[i], i < num - 1);
+
+	return ret < 0 ? ret : num;
+}
+
+static u32 iic_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;
+}
+
+static struct i2c_algorithm iic_algo = {
+	.name 		= "IBM IIC algorithm",
+	.id   		= I2C_ALGO_OCP,
+	.master_xfer 	= iic_xfer,
+	.smbus_xfer	= NULL,
+	.slave_send	= NULL,
+	.slave_recv	= NULL,
+	.algo_control	= NULL,
+	.functionality	= iic_func
+};
+
+/*
+ * Calculates IICx_CLCKDIV value for a specific OPB clock frequency
+ */
+static inline u8 iic_clckdiv(unsigned int opb)
+{
+	/* Compatibility kludge, should go away after all cards
+	 * are fixed to fill correct value for opbfreq.
+	 * Previous driver version used hardcoded divider value 4,
+	 * it corresponds to OPB frequency from the range (40, 50] MHz
+	 */
+	if (!opb){
+		printk(KERN_WARNING "ibm-iic: using compatibility value for OPB freq,"
+			" fix your board specific setup\n");
+		opb = 50000000;
+	}
+
+	/* Convert to MHz */
+	opb /= 1000000;
+	
+	if (opb < 20 || opb > 150){
+		printk(KERN_CRIT "ibm-iic: invalid OPB clock frequency %u MHz\n",
+			opb);
+		opb = opb < 20 ? 20 : 150;
+	}
+	return (u8)((opb + 9) / 10 - 1);
+}
+
+/*
+ * Register single IIC interface
+ */
+static int __devinit iic_probe(struct ocp_device *ocp){
+
+	struct ibm_iic_private* dev;
+	struct i2c_adapter* adap;
+	int ret;
+	bd_t* bd = (bd_t*)&__res;
+	
+	if (!(dev = kmalloc(sizeof(*dev), GFP_KERNEL))){
+		printk(KERN_CRIT "ibm-iic: failed to allocate device data\n");
+		return -ENOMEM;
+	}
+
+	memset(dev, 0, sizeof(*dev));
+	ocp_set_drvdata(ocp, dev);
+	
+	if (!(dev->vaddr = ioremap(ocp->def->paddr, sizeof(struct iic_regs)))){
+		printk(KERN_CRIT "ibm-iic%d: failed to ioremap device registers\n",
+			dev->idx);
+		ret = -ENXIO;
+		goto fail2;
+	}
+	
+	init_waitqueue_head(&dev->wq);
+
+	dev->irq = iic_force_poll ? -1 : ocp->def->irq;
+	if (dev->irq >= 0){
+		/* Disable interrupts until we finish intialization,
+		   assumes level-sensitive IRQ setup...
+		 */
+		iic_interrupt_mode(dev, 0);
+		if (request_irq(dev->irq, iic_handler, 0, "IBM IIC", dev)){
+			printk(KERN_ERR "ibm-iic%d: request_irq %d failed\n", 
+				dev->idx, dev->irq);
+			/* Fallback to the polling mode */	
+			dev->irq = -1;
+		}
+	}
+	
+	if (dev->irq < 0)
+		printk(KERN_WARNING "ibm-iic%d: using polling mode\n", 
+			dev->idx);
+		
+	/* Board specific settings */
+	BUG_ON(dev->idx >= sizeof(bd->bi_iic_fast) / sizeof(bd->bi_iic_fast[0]));
+	dev->fast_mode = iic_force_fast ? 1 : bd->bi_iic_fast[dev->idx];
+	
+	/* clckdiv is the same for *all* IIC interfaces, 
+	 * but I'd rather make a copy than introduce another global. --ebs
+	 */
+	dev->clckdiv = iic_clckdiv(bd->bi_opb_busfreq);
+	DBG("%d: clckdiv = %d\n", dev->idx, dev->clckdiv);
+	
+	/* Initialize IIC interface */
+	iic_dev_init(dev);
+	
+	/* Register it with i2c layer */
+	adap = &dev->adap;
+	strcpy(adap->name, "IBM IIC");
+	i2c_set_adapdata(adap, dev);
+	adap->id = I2C_HW_OCP | iic_algo.id;
+	adap->algo = &iic_algo;
+	adap->client_register = NULL;
+	adap->client_unregister = NULL;
+	adap->timeout = 1;
+	adap->retries = 1;
+
+	if ((ret = i2c_add_adapter(adap)) != 0){
+		printk(KERN_CRIT "ibm-iic%d: failed to register i2c adapter\n",
+			dev->idx);
+		goto fail;
+	}
+	
+	printk(KERN_INFO "ibm-iic%d: using %s mode\n", dev->idx,
+		dev->fast_mode ? "fast (400 kHz)" : "standard (100 kHz)");
+
+	return 0;
+
+fail:	
+	if (dev->irq >= 0){
+		iic_interrupt_mode(dev, 0);
+		free_irq(dev->irq, dev);
+	}	
+
+	iounmap((void*)dev->vaddr);
+fail2:	
+	ocp_set_drvdata(ocp, 0);
+	kfree(dev);	
+	return ret;
+}
+
+/*
+ * Cleanup initialized IIC interface
+ */
+static void __devexit iic_remove(struct ocp_device *ocp)
+{
+	struct ibm_iic_private* dev = (struct ibm_iic_private*)ocp_get_drvdata(ocp);
+	BUG_ON(dev == NULL);
+	if (i2c_del_adapter(&dev->adap)){
+		printk(KERN_CRIT "ibm-iic%d: failed to delete i2c adapter :(\n",
+			dev->idx);
+		/* That's *very* bad, just shutdown IRQ ... */
+		if (dev->irq >= 0){
+		    iic_interrupt_mode(dev, 0);	
+		    free_irq(dev->irq, dev);
+		    dev->irq = -1;
+		}
+	} else {
+		if (dev->irq >= 0){
+		    iic_interrupt_mode(dev, 0);	
+		    free_irq(dev->irq, dev);
+		}
+		iounmap((void*)dev->vaddr);
+		kfree(dev);
+	}
+}
+
+static struct ocp_device_id ibm_iic_ids[] __devinitdata = 
+{
+	{ OCP_VENDOR_IBM, OCP_FUNC_IIC },
+	{ OCP_VENDOR_INVALID, }
+};
+
+MODULE_DEVICE_TABLE(ocp, ibm_iic_ids);
+
+static struct ocp_driver ibm_iic_driver =
+{
+	.name 		= "ocp_iic",
+	.id_table	= ibm_iic_ids,
+	.probe		= iic_probe,
+	.remove		= __devexit_p(iic_remove),
+#if defined(CONFIG_PM)
+	.suspend	= NULL,
+	.resume		= NULL,
+#endif
+};
+
+/*
+ * Description:  Put this process to sleep.  We will wake up when the
+ * IIC controller interrupts.
+ */
+void
+iic_ibmocp_waitforpin(void *data)
+{
+
+	int timeout = 2;
+	struct ocp_device *iic_dev;
+
+	iic_dev = (struct ocp_device *) data;
+
+	/*
+	 * If interrupts are enabled (which they are), then put the process to
+	 * sleep.  This process will be awakened by two events -- either the
+	 * the IIC peripheral interrupts or the timeout expires. 
+	 */
+	if (iic_dev->def->irq > 0) {
+		cli();
+		if (iic_pending == 0) {
+			interruptible_sleep_on_timeout(&
+						       (iic_wait[0]),
+						       timeout * HZ);
+		} else
+			iic_pending = 0;
+		sti();
+	} else {
+		/*
+		 * If interrupts are not enabled then delay for a reasonable amount
+		 * of time and return.  We expect that by time we return to the calling
+		 * function that the IIC has finished our requested transaction and
+		 * the status bit reflects this.
+		 * 
+		 * udelay is probably not the best choice for this since it is
+		 * the equivalent of a busy wait
+		 */
+		udelay(100);
+	}
+}
+
+EXPORT_SYMBOL(iic_ibmocp_waitforpin);
+
+static int __init iic_init(void)
+{
+	printk(KERN_INFO "IBM IIC driver v" DRIVER_VERSION "\n");
+	return ocp_module_init(&ibm_iic_driver);
+}
+
+static void __exit iic_exit(void)
+{
+	ocp_unregister_driver(&ibm_iic_driver);
+}
+
+module_init(iic_init);
+module_exit(iic_exit);
+
diff -Naru linux-2.4.28.orig/drivers/i2c/i2c-adap-ite.c linux-2.4.28/drivers/i2c/i2c-adap-ite.c
--- linux-2.4.28.orig/drivers/i2c/i2c-adap-ite.c	2004-02-18 22:36:31.000000000 +0900
+++ linux-2.4.28/drivers/i2c/i2c-adap-ite.c	2005-01-31 11:52:56.000000000 +0900
@@ -30,7 +30,7 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		     */
 /* ------------------------------------------------------------------------- */
 
-/* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
+/* With some changes from Kyti Mkki <kmalkki@cc.hut.fi> and even
    Frodo Looijaard <frodol@dds.nl> */
 
 #include <linux/kernel.h>
diff -Naru linux-2.4.28.orig/drivers/i2c/i2c-algo-ibm_ocp.c linux-2.4.28/drivers/i2c/i2c-algo-ibm_ocp.c
--- linux-2.4.28.orig/drivers/i2c/i2c-algo-ibm_ocp.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/i2c/i2c-algo-ibm_ocp.c	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,982 @@
+/*
+   -------------------------------------------------------------------------
+   i2c-algo-ibm_ocp.c i2c driver algorithms for IBM PPC 405 adapters	    
+   -------------------------------------------------------------------------
+      
+   current Mainainers
+   Ian DaSilva and Armin Kuster, MontaVista Software, Inc.
+   idasilva@mvista.com, Akuster@mvista.com or source@mvista.com
+
+   Copyright 2000-2002 MontaVista Software Inc.
+
+   Changes made to support the IIC peripheral on the IBM PPC 405
+
+   ---------------------------------------------------------------------------
+   This file was highly leveraged from i2c-algo-pcf.c, which was created
+   by Simon G. Vogl and Hans Berglund:
+
+     Copyright (C) 1995-1997 Simon G. Vogl
+                   1998-2000 Hans Berglund
+
+   With some changes from Kyti Mkki <kmalkki@cc.hut.fi> and 
+   Frodo Looijaard <frodol@dds.nl> ,and also from Martin Bailey
+   <mbailey@littlefeet-inc.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+   ---------------------------------------------------------------------------
+
+   History: 01/20/12 - Armin
+   	akuster@mvista.com
+   	ported up to 2.4.16+	
+
+   Version 02/03/25 - Armin
+       converted to ocp format
+       removed commented out or #if 0 code
+       added Gard Basler's fix to iic_combined_transaction() such that it 
+       returns the number of successfully completed transfers .
+
+   Version 04/29/03 - Armin
+   	General cleanups
+	changes c++ style comments to c
+	converted to ocp
+	deleted unused printk's
+	Added scan routine from Andrew May
+
+   Version 05/25/02 - Armin
+      name change for *_driver to *_dev
+
+   PlatHome <openlab.plathome.co.jp>
+	- Modified OpenBlockS 2xx
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+
+#include <linux/i2c.h>
+#include <asm/ocp.h>
+
+#include <asm/ibm4xx.h>
+#include <asm/bootinfo.h>
+#define IIC_VER	"2002.30.04"
+
+/* ----- global defines ----------------------------------------------- */
+#define DEB(x) if (i2c_debug>=1) x
+#define DEB2(x) if (i2c_debug>=2) x
+#define DEB3(x) if (i2c_debug>=3) x	/* print several statistical values */
+#define DEBPROTO(x) if (i2c_debug>=9) x;
+	/* debug the protocol by showing transferred bits */
+#define DEF_TIMEOUT 5
+
+#define IIC_DEV(x)	(((struct ocp_device *)adap->data)->def)->x
+
+/* ----- global variables ---------------------------------------------	*/
+
+#ifdef SLO_IO
+int jif;
+#endif
+
+/* module parameters:
+ */
+static int i2c_debug = 0;
+static int iic_scan = 0;	/* have a look at what's hanging 'round         */
+
+/* --- setting states on the bus with the right timing: ---------------	*/
+
+#define iic_outb( reg, val) writeb(val,&(reg))
+#define iic_inb( reg) readb(&(reg))
+
+#define IICO_I2C_SDAHIGH	0x0780
+#define IICO_I2C_SDALOW		0x0781
+#define IICO_I2C_SCLHIGH	0x0782
+#define IICO_I2C_SCLLOW		0x0783
+#define IICO_I2C_LINEREAD	0x0784
+
+#define IIC_SINGLE_XFER		0
+#define IIC_COMBINED_XFER	1
+
+#define IIC_ERR_LOST_ARB        -2
+#define IIC_ERR_INCOMPLETE_XFR  -3
+#define IIC_ERR_NACK            -1
+#define IIC_TIMEOUT		100
+#define IIC_RETRY		3
+
+extern void iic_ibmocp_waitforpin(void *data);
+
+/* --- other auxiliary functions --------------------------------------	*/
+
+/*
+ *Description: Puts this process to sleep for a period equal to timeout 
+ */
+static inline void
+iic_sleep(unsigned long timeout)
+{
+	schedule_timeout(timeout * HZ);
+}
+
+/*
+ * Description: This performs the IBM PPC 405 IIC initialization sequence
+ * as described in the PPC405GP data book.
+ */
+static int
+iic_init(struct i2c_adapter *adap)
+{
+	struct iic_regs *iic;
+	unsigned short retval;
+
+	iic = (struct iic_regs *) IIC_DEV(vaddr);
+
+	/* Clear master low master address */
+	iic_outb(iic->lmadr, 0);
+
+	/* Clear high master address */
+	iic_outb(iic->hmadr, 0);
+
+	/* Clear low slave address */
+	iic_outb(iic->lsadr, 0);
+
+	/* Clear high slave address */
+	iic_outb(iic->hsadr, 0);
+
+	/* Clear status */
+	iic_outb(iic->sts, 0x0a);
+
+	/* Clear extended status */
+	iic_outb(iic->extsts, 0x8f);
+
+	/* Set clock division */
+	iic_outb(iic->clkdiv, 0x04);
+
+	retval = iic_inb(iic->clkdiv);
+	DEB(printk("iic_init: CLKDIV register = %x\n", retval));
+
+	/* Enable interrupts on Requested Master Transfer Complete */
+	iic_outb(iic->intmsk, 0x01);
+
+	/* Clear transfer count */
+	iic_outb(iic->xfrcnt, 0x0);
+
+	/* Clear extended control and status */
+	iic_outb(iic->xtcntlss, 0xf0);
+
+	/* Set mode control (flush master data buf, enable hold SCL, exit */
+	/* unknown state.                                                 */
+	iic_outb(iic->mdcntl, 0x47);
+
+	/* Clear control register */
+	iic_outb(iic->cntl, 0x0);
+
+	DEB2(printk(KERN_DEBUG "iic_init: Initialized IIC on PPC 405\n"));
+	return 0;
+}
+
+/*
+ * Description: After we issue a transaction on the IIC bus, this function
+ * is called.  It puts this process to sleep until we get an interrupt from
+ * from the controller telling us that the transaction we requested in complete.
+ */
+static int
+wait_for_pin(struct i2c_adapter *adap, int *status)
+{
+
+	int timeout = DEF_TIMEOUT;
+	int retval;
+	struct iic_regs *iic;
+
+	iic = (struct iic_regs *) IIC_DEV(vaddr);
+
+	*status = iic_inb(iic->sts);
+#ifndef STUB_I2C
+
+	while (timeout-- && (*status & 0x01)) {
+		iic_ibmocp_waitforpin(adap->data);
+		*status = iic_inb(iic->sts);
+	}
+#endif
+	if (timeout <= 0) {
+		/* Issue stop signal on the bus, and force an interrupt */
+		retval = iic_inb(iic->cntl);
+		iic_outb(iic->cntl, retval | 0x80);
+		/* Clear status register */
+		iic_outb(iic->sts, 0x0a);
+		/* Exit unknown bus state */
+		retval = iic_inb(iic->mdcntl);
+		iic_outb(iic->mdcntl, (retval | 0x02));
+
+		/* Check the status of the controller.  Does it still see a
+		 * pending transfer, even though we've tried to stop any
+		 * ongoing transaction?
+		 */
+		retval = iic_inb(iic->sts);
+		retval = retval & 0x01;
+		if (retval) {
+			/* The iic controller is hosed.  It is not responding to any
+			 * of our commands.  We have already tried to force it into
+			 * a known state, but it has not worked.  Our only choice now
+			 * is a soft reset, which will clear all registers, and force
+			 * us to re-initialize the controller.
+			 * Soft reset
+			 */
+			iic_outb(iic->xtcntlss, 0x01);
+			udelay(500);
+			iic_init(adap);
+			/* Is the pending transfer bit in the sts reg finally cleared? */
+			retval = iic_inb(iic->sts);
+			retval = retval & 0x01;
+			if (retval) {
+				printk(KERN_CRIT
+				       "The IIC Controller is hosed.  A processor reset is required\n");
+			}
+			/* For some reason, even though the interrupt bit in this
+			 * register was set during iic_init, it didn't take.  We
+			 * need to set it again.  Don't ask me why....this is just what
+			 * I saw when testing timeouts.
+			 */
+			iic_outb(iic->intmsk, 0x01);
+		}
+		return (-1);
+	} else
+		return (0);
+}
+
+/* ------------------------------------ */
+/*  Utility functions */
+
+/*  Description: Look at the status register to see if there was an error 
+ *  in the requested transaction.  If there is, look at the extended status 
+ *  register and determine the exact cause. 
+ */
+
+int
+analyze_status(struct i2c_adapter *adap, int *error_code)
+{
+	int ret;
+	struct iic_regs *iic;
+
+	iic = (struct iic_regs *) IIC_DEV(vaddr);
+
+	ret = iic_inb(iic->sts);
+	if (ret & 0x04) {
+		/* Error occurred */
+		ret = iic_inb(iic->extsts);
+		if (ret & 0x04) {
+			/* Lost arbitration */
+			*error_code = IIC_ERR_LOST_ARB;
+		}
+		if (ret & 0x02) {
+			/* Incomplete transfer */
+			*error_code = IIC_ERR_INCOMPLETE_XFR;
+		}
+		if (ret & 0x01) {
+			/* Master transfer aborted by a NACK during the transfer of the address byte */
+			*error_code = IIC_ERR_NACK;
+		}
+		return -1;
+	}
+	return 0;
+}
+
+/*  Description: This function is called by the upper layers to do the 
+ *  grunt work for a master send transaction
+ */
+
+static int
+iic_sendbytes(struct i2c_adapter *adap, const char *buf,
+	      int count, int xfer_flag)
+{
+	struct iic_regs *iic;
+	int wrcount, status, timeout;
+	int loops, remainder, i, j;
+	int ret, error_code;
+
+	iic = (struct iic_regs *) IIC_DEV(vaddr);
+
+	if (count == 0)
+		return 0;
+	wrcount = 0;
+	loops = count / 4;
+	remainder = count % 4;
+
+	if ((loops > 1) && (remainder == 0)) {
+		for (i = 0; i < (loops - 1); i++) {
+
+			/* Write four bytes to master data buffer */
+
+			for (j = 0; j < 4; j++) {
+				iic_outb(iic->mdbuf, buf[wrcount++]);
+			}
+
+			/* Issue command to IICO device to begin transmission */
+
+			iic_outb(iic->cntl, 0x35);
+
+			/*    Wait for transmission to complete.  When it does,  
+			 *    loop to the top of the for statement and write the  
+			 *    next four bytes. 
+			 */
+
+			timeout = wait_for_pin(adap, &status);
+			if (timeout < 0) {
+
+				/* Error handling */
+
+				return wrcount;
+			}
+			ret = analyze_status(adap, &error_code);
+			if (ret < 0) {
+				if (error_code == IIC_ERR_INCOMPLETE_XFR) {
+					/* Return the number of bytes transferred */
+					ret = iic_inb(iic->xfrcnt);
+					ret = ret & 0x07;
+					return (wrcount - 4 + ret);
+				} else
+					return error_code;
+			}
+		}
+	} else if ((loops >= 1) && (remainder > 0)) {
+		/*printk(KERN_DEBUG "iic_sendbytes: (loops >= 1)\n"); */
+		for (i = 0; i < loops; i++) {
+			/*
+			 * Write four bytes to master data buffer
+			 */
+			for (j = 0; j < 4; j++) {
+				iic_outb(iic->mdbuf, buf[wrcount++]);
+			}
+			/*
+			 * Issue command to IICO device to begin transmission
+			 */
+			iic_outb(iic->cntl, 0x35);
+			/*
+			 * Wait for transmission to complete.  When it does,
+			 * loop to the top of the for statement and write the
+			 * next four bytes.
+			 */
+			timeout = wait_for_pin(adap, &status);
+			if (timeout < 0)
+				return wrcount;
+
+			ret = analyze_status(adap, &error_code);
+			if (ret < 0) {
+				if (error_code == IIC_ERR_INCOMPLETE_XFR) {
+					/* Return the number of bytes transferred */
+					ret = iic_inb(iic->xfrcnt);
+					ret = ret & 0x07;
+					return (wrcount - 4 + ret);
+				} else
+					return error_code;
+			}
+		}
+	}
+
+	if (remainder == 0)
+		remainder = 4;
+	/* Write the remaining bytes (less than or equal to 4) */
+
+	for (i = 0; i < remainder; i++)
+		iic_outb(iic->mdbuf, buf[wrcount++]);
+
+	if (xfer_flag == IIC_COMBINED_XFER) {
+		iic_outb(iic->cntl, (0x09 | ((remainder - 1) << 4)));
+	} else {
+		iic_outb(iic->cntl, (0x01 | ((remainder - 1) << 4)));
+	}
+	DEB2(printk(KERN_DEBUG "iic_sendbytes: Waiting for interrupt\n"));
+	timeout = wait_for_pin(adap, &status);
+	if (timeout < 0)
+		return wrcount;
+	ret = analyze_status(adap, &error_code);
+	if (ret < 0) {
+		if (error_code == IIC_ERR_INCOMPLETE_XFR) {
+			/* Return the number of bytes transferred */
+			ret = iic_inb(iic->xfrcnt);
+			ret = ret & 0x07;
+			return (wrcount - 4 + ret);
+		} else
+			return error_code;
+	}
+	DEB2(printk(KERN_DEBUG "iic_sendbytes: Got interrupt\n"));
+	return wrcount;
+}
+
+/*
+ * Description: Called by the upper layers to do the grunt work for
+ * a master read transaction.
+ */
+static int
+iic_readbytes(struct i2c_adapter *adap, char *buf, int count, int xfer_type)
+{
+	struct iic_regs *iic;
+	int rdcount = 0, i, status, timeout;
+	int loops, remainder, j;
+	int ret, error_code;
+
+	iic = (struct iic_regs *) IIC_DEV(vaddr);
+
+	if (count == 0)
+		return 0;
+	loops = count / 4;
+	remainder = count % 4;
+
+	if ((loops > 1) && (remainder == 0)) {
+		for (i = 0; i < (loops - 1); i++) {
+			/* Issue command to begin master read (4 bytes maximum) */
+			iic_outb(iic->cntl, 0x37);
+			/*
+			 * Wait for transmission to complete.  When it does,
+			 * loop to the top of the for statement and write the
+			 * next four bytes.
+			 */
+			timeout = wait_for_pin(adap, &status);
+			if (timeout < 0)
+				return rdcount;
+
+			ret = analyze_status(adap, &error_code);
+			if (ret < 0) {
+				if (error_code == IIC_ERR_INCOMPLETE_XFR)
+					return rdcount;
+				else
+					return error_code;
+			}
+
+			for (j = 0; j < 4; j++) {
+				/* Wait for data to shuffle to top of data buffer
+				 * This value needs to optimized.
+				 */
+				udelay(1);
+				buf[rdcount] = iic_inb(iic->mdbuf);
+				rdcount++;
+			}
+		}
+	}
+
+	else if ((loops >= 1) && (remainder > 0)) {
+		for (i = 0; i < loops; i++) {
+			/* Issue command to begin master read (4 bytes maximum) */
+			iic_outb(iic->cntl, 0x37);
+			/*
+			 * Wait for transmission to complete.  When it does,
+			 * loop to the top of the for statement and write the
+			 * next four bytes.
+			 */
+			timeout = wait_for_pin(adap, &status);
+			if (timeout < 0)
+				return rdcount;
+
+			ret = analyze_status(adap, &error_code);
+			if (ret < 0) {
+				if (error_code == IIC_ERR_INCOMPLETE_XFR)
+					return rdcount;
+				else
+					return error_code;
+			}
+
+			for (j = 0; j < 4; j++) {
+				/* Wait for data to shuffle to top of data buffer
+				 * This value needs to optimized.
+				 */
+				udelay(1);
+				buf[rdcount] = iic_inb(iic->mdbuf);
+				rdcount++;
+			}
+		}
+	}
+
+	if (remainder == 0)
+		remainder = 4;
+	DEB2(printk
+	     (KERN_DEBUG "iic_readbytes: writing %x to IICO_CNTL\n",
+	      (0x03 | ((remainder - 1) << 4))));
+
+	if (xfer_type == IIC_COMBINED_XFER) {
+		iic_outb(iic->cntl, (0x0b | ((remainder - 1) << 4)));
+	} else {
+		iic_outb(iic->cntl, (0x03 | ((remainder - 1) << 4)));
+	}
+	DEB2(printk(KERN_DEBUG "iic_readbytes: Wait for pin\n"));
+	timeout = wait_for_pin(adap, &status);
+	DEB2(printk(KERN_DEBUG "iic_readbytes: Got the interrupt\n"));
+	if (timeout < 0)
+		return rdcount;
+
+	ret = analyze_status(adap, &error_code);
+	if (ret < 0) {
+		if (error_code == IIC_ERR_INCOMPLETE_XFR)
+			return rdcount;
+		else
+			return error_code;
+	}
+
+	for (i = 0; i < remainder; i++) {
+		buf[rdcount] = iic_inb(iic->mdbuf);
+		rdcount++;
+	}
+
+	return rdcount;
+}
+
+/*
+ * Description:  This function implements combined transactions.  Combined
+ * transactions consist of combinations of reading and writing blocks of data.
+ * Each transfer (i.e. a read or a write) is separated by a repeated start
+ * condition.
+ */
+static int
+iic_combined_transaction(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[],
+			 int num)
+{
+	int i;
+	struct i2c_msg *pmsg;
+	int ret;
+
+	DEB2(printk(KERN_DEBUG "Beginning combined transaction\n"));
+	for (i = 0; i < num; i++) {
+		pmsg = &msgs[i];
+		if (pmsg->flags & I2C_M_RD) {
+
+			/* Last read or write segment needs to be terminated with a stop */
+			if (i < num - 1) {
+				DEB2(printk(KERN_DEBUG "This one is a read\n"));
+			} else {
+				DEB2(printk
+				     (KERN_DEBUG "Doing the last read\n"));
+			}
+			ret =
+			    iic_readbytes(i2c_adap, pmsg->buf, pmsg->len,
+					  (i <
+					   num -
+					   1) ? IIC_COMBINED_XFER :
+					  IIC_SINGLE_XFER);
+
+			if (ret != pmsg->len) {
+				DEB2(printk("i2c-algo-ppc405.o: fail: "
+					    "only read %d bytes.\n", ret));
+				return i;
+			} else {
+				DEB2(printk
+				     ("i2c-algo-ppc405.o: read %d bytes.\n",
+				      ret));
+			}
+		} else if (!(pmsg->flags & I2C_M_RD)) {
+
+			/* Last read or write segment needs to be terminated with a stop */
+			if (i < num - 1) {
+				DEB2(printk
+				     (KERN_DEBUG "This one is a write\n"));
+			} else {
+				DEB2(printk
+				     (KERN_DEBUG "Doing the last write\n"));
+			}
+			ret =
+			    iic_sendbytes(i2c_adap, pmsg->buf, pmsg->len,
+					  (i <
+					   num -
+					   1) ? IIC_COMBINED_XFER :
+					  IIC_SINGLE_XFER);
+
+			if (ret != pmsg->len) {
+				DEB2(printk("i2c-algo-ppc405.o: fail: "
+					    "only wrote %d bytes.\n", ret));
+				return i;
+			} else {
+				DEB2(printk
+				     ("i2c-algo-ppc405.o: wrote %d bytes.\n",
+				      ret));
+			}
+		}
+	}
+
+	return num;
+}
+
+/*
+ * Description: Whenever we initiate a transaction, the first byte clocked
+ * onto the bus after the start condition is the address (7 bit) of the
+ * device we want to talk to.  This function manipulates the address specified
+ * so that it makes sense to the hardware when written to the IIC peripheral.
+ *
+ * Note: 10 bit addresses are not supported in this driver, although they are
+ * supported by the hardware.  This functionality needs to be implemented.
+ */
+static inline int
+iic_doAddress(struct i2c_adapter *adap, struct i2c_msg *msg, int retries)
+{
+	struct iic_regs *iic;
+	unsigned short flags = msg->flags;
+	unsigned char addr;
+
+	iic = (struct iic_regs *) IIC_DEV(vaddr);
+
+/*
+ * The following segment for 10 bit addresses needs to be ported
+ */
+#if 0
+	/* Ten bit addresses not supported right now */
+	if ((flags & I2C_M_TEN)) {
+		/* a ten bit address */
+		addr = 0xf0 | ((msg->addr >> 7) & 0x03);
+		DEB2(printk(KERN_DEBUG "addr0: %d\n", addr));
+		/* try extended address code... */
+		ret = try_address(adap, addr, retries);
+		if (ret != 1) {
+			printk(KERN_ERR
+			       "iic_doAddress: died at extended address code.\n");
+			return -EREMOTEIO;
+		}
+		/* the remaining 8 bit address */
+		iic_outb(msg->addr & 0x7f);
+		/* Status check comes here */
+		if (ret != 1) {
+			printk(KERN_ERR
+			       "iic_doAddress: died at 2nd address code.\n");
+			return -EREMOTEIO;
+		}
+		if (flags & I2C_M_RD) {
+			i2c_repstart(adap);
+			/* okay, now switch into reading mode */
+			addr |= 0x01;
+			ret = try_address(adap, addr, retries);
+			if (ret != 1) {
+				printk(KERN_ERR
+				       "iic_doAddress: died at extended address code.\n");
+				return -EREMOTEIO;
+			}
+		}
+	} else
+		/* ---------->  normal 7 bit address */
+		/*Ten bit addresses not supported yet */
+#endif
+		addr = (msg->addr << 1);
+	if (flags & I2C_M_RD)
+		addr |= 1;
+	if (flags & I2C_M_REV_DIR_ADDR)
+		addr ^= 1;
+	/*
+	 * Write to the low slave address
+	 */
+	iic_outb(iic->lmadr, addr);
+	/*
+	 * Write zero to the high slave register since we are
+	 * only using 7 bit addresses
+	 */
+	iic_outb(iic->hmadr, 0);
+
+	return 0;
+}
+
+/*
+ * Description: Prepares the controller for a transaction (clearing status
+ * registers, data buffers, etc), and then calls either iic_readbytes or
+ * iic_sendbytes to do the actual transaction.
+ */
+static int
+iic_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
+{
+	struct iic_regs *iic;
+	struct i2c_msg *pmsg;
+	int i = 0;
+	int ret;
+
+	iic = (struct iic_regs *) IIC_DEV(vaddr);
+
+	pmsg = &msgs[i];
+
+	/*
+	 * Clear status register
+	 */
+	DEB2(printk
+	     (KERN_DEBUG "iic_xfer: iic_xfer: Clearing status register\n"));
+	iic_outb(iic->sts, 0x0a);
+
+	/*
+	 * Wait for any pending transfers to complete
+	 */
+	DEB2(printk
+	     (KERN_DEBUG
+	      "iic_xfer: Waiting for any pending transfers to complete\n"));
+	while ((ret = iic_inb(iic->sts)) == 0x01) {
+		;
+	}
+
+	/*
+	 * Flush master data buf
+	 */
+	DEB2(printk(KERN_DEBUG "iic_xfer: Clearing master data buffer\n"));
+	ret = iic_inb(iic->mdcntl);
+	iic_outb(iic->mdcntl, ret | 0x40);
+
+	/*
+	 * Load slave address
+	 */
+	DEB2(printk(KERN_DEBUG "iic_xfer: Loading slave address\n"));
+	ret = iic_doAddress(adap, pmsg, adap->retries);
+
+	/*
+	 * Check to see if the bus is busy
+	 */
+	ret = iic_inb(iic->extsts);
+	/* Mask off the irrelevent bits */
+	ret = ret & 0x70;
+	/* When the bus is free, the BCS bits in the EXTSTS register are 0b100 */
+	if (ret != 0x40)
+		return IIC_ERR_LOST_ARB;
+
+	/*
+	 * Combined transaction (read and write)
+	 */
+	if (num > 1) {
+		DEB2(printk
+		     (KERN_DEBUG "iic_xfer: Call combined transaction\n"));
+		ret = iic_combined_transaction(adap, msgs, num);
+	}
+	/*
+	 * Read only
+	 */
+	else if ((num == 1) && (pmsg->flags & I2C_M_RD)) {
+		/*
+		 * Tell device to begin reading data from the  master data 
+		 */
+		DEB2(printk(KERN_DEBUG "iic_xfer: Call adapter's read\n"));
+		ret =
+		    iic_readbytes(adap, pmsg->buf, pmsg->len, IIC_SINGLE_XFER);
+#ifdef CONFIG_OBS2xx
+		ret = (ret == pmsg->len)? num: ret;
+#endif
+	}
+	/*
+	 * Write only
+	 */
+	else if ((num == 1) && (!(pmsg->flags & I2C_M_RD))) {
+		/*
+		 * Write data to master data buffers and tell our device
+		 * to begin transmitting
+		 */
+		DEB2(printk(KERN_DEBUG "iic_xfer: Call adapter's write\n"));
+		ret =
+		    iic_sendbytes(adap, pmsg->buf, pmsg->len, IIC_SINGLE_XFER);
+#ifdef CONFIG_OBS2xx
+		ret = (ret == pmsg->len)? num: ret;
+#endif
+	}
+
+	return ret;
+}
+
+/*
+ * Description: Implements device specific ioctls.  Higher level ioctls can
+ * be found in i2c-core.c and are typical of any i2c controller (specifying
+ * slave address, timeouts, etc).  These ioctls take advantage of any hardware
+ * features built into the controller for which this algorithm-adapter set
+ * was written.  These ioctls allow you to take control of the data and clock
+ * lines on the IBM PPC 405 IIC controller and set the either high or low,
+ * similar to a GPIO pin.
+ */
+static int
+algo_control(struct i2c_adapter *adap, unsigned int cmd, unsigned long arg)
+{
+	struct iic_regs *iic;
+	int ret = 0;
+	int lines;
+
+	iic = (struct iic_regs *) IIC_DEV(vaddr);
+
+	lines = iic_inb(iic->directcntl);
+
+	if (cmd == IICO_I2C_SDAHIGH) {
+		lines = lines & 0x01;
+		if (lines)
+			lines = 0x04;
+		else
+			lines = 0;
+		iic_outb(iic->directcntl, (0x08 | lines));
+	} else if (cmd == IICO_I2C_SDALOW) {
+		lines = lines & 0x01;
+		if (lines)
+			lines = 0x04;
+		else
+			lines = 0;
+		iic_outb(iic->directcntl, (0x00 | lines));
+	} else if (cmd == IICO_I2C_SCLHIGH) {
+		lines = lines & 0x02;
+		if (lines)
+			lines = 0x08;
+		else
+			lines = 0;
+		iic_outb(iic->directcntl, (0x04 | lines));
+	} else if (cmd == IICO_I2C_SCLLOW) {
+		lines = lines & 0x02;
+		if (lines)
+			lines = 0x08;
+		else
+			lines = 0;
+		iic_outb(iic->directcntl, (0x00 | lines));
+	} else if (cmd == IICO_I2C_LINEREAD) {
+		ret = lines;
+	}
+	return ret;
+}
+
+static u32
+iic_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |
+	    I2C_FUNC_PROTOCOL_MANGLING;
+}
+
+/* -----exported algorithm data: -------------------------------------	*/
+
+static struct i2c_algorithm iic_algo = {
+	"IBM on-chip IIC algorithm",
+	I2C_ALGO_OCP,
+	iic_xfer,
+	NULL,
+	NULL,			/* slave_xmit           */
+	NULL,			/* slave_recv           */
+	algo_control,		/* ioctl                */
+	iic_func,		/* functionality        */
+};
+
+/* 
+ * registering functions to load algorithms at runtime 
+ */
+
+/*
+ * Description: Register bus structure
+ */
+int
+i2c_iic_add_bus(struct i2c_adapter *adap)
+{
+
+	DEB2(printk
+	     (KERN_DEBUG "i2c-algo-iic.o: hw routines for %s registered.\n",
+	      adap->name));
+	adap->id |= iic_algo.id;
+	adap->algo = &iic_algo;
+	adap->timeout = IIC_TIMEOUT;
+	adap->retries = IIC_RETRY;
+
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+
+	iic_init(adap);
+	i2c_add_adapter(adap);
+	/* scan the I2C bus for valid 7 bit addresses
+	 * (ie things that ACK on 1byte read)
+	 * if i2c_debug is off we print everything on one line.
+	 * if i2c_debug is on we do a newline per print so we don't
+	 * clash too much with printk's in the other functions.
+	 * TODO: check for 10-bit mode and never run as a slave.
+	 */
+
+	if (iic_scan) {
+
+		int found = 0;
+		int i;
+		printk(KERN_INFO " i2c-algo-iic.o: scanning bus %s. Found ",
+		       adap->name);
+		if (i2c_debug)
+			printk("\n");
+		for (i = 0; i < 0x7f; i++) {
+			int ret;
+			struct i2c_msg msg;
+			char data[1];
+			msg.addr = i;
+			msg.buf = data;
+			msg.len = 1;
+			msg.flags = I2C_M_RD;
+			if ((ret = iic_xfer(adap, &msg, 1)) == 1) {
+				if (i2c_debug)
+					printk
+					    ("I2C Found 0x%02x ret %d Data 0x%02x\n",
+					     i, ret, data[0]);
+				else
+					printk("0x%02x ", i);
+				found++;
+			}
+		}
+		if (i2c_debug) {
+			if (!found)
+				printk("I2C Found Nothing\n");
+		} else {
+			if (found)
+				printk("\n");
+			else
+				printk("Nothing\n");
+		}
+
+	}
+	return 1;
+}
+
+int
+i2c_iic_del_bus(struct i2c_adapter *adap)
+{
+	int res;
+	if ((res = i2c_del_adapter(adap)) < 0)
+		return res;
+	DEB2(printk
+	     (KERN_DEBUG "i2c-algo-iic.o: adapter unregistered: %s\n",
+	      adap->name));
+
+#ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#endif
+	return 1;
+}
+
+int __init
+i2c_algo_iic_init(void)
+{
+	printk(KERN_INFO "IBM On-chip iic (i2c) algorithm module %s\n",
+	       IIC_VER);
+
+	return 0;
+}
+
+void
+i2c_algo_iic_exit(void)
+{
+	return;
+}
+
+EXPORT_SYMBOL(i2c_iic_add_bus);
+EXPORT_SYMBOL(i2c_iic_del_bus);
+
+/*
+ * The MODULE_* macros resolve to nothing if MODULES is not defined
+ * when this file is compiled.
+ */
+MODULE_AUTHOR("MontaVista Software <www.mvista.com>");
+MODULE_DESCRIPTION("PPC 405 iic algorithm");
+
+MODULE_PARM(iic_scan, "i");
+MODULE_PARM(i2c_debug, "i");
+
+MODULE_PARM_DESC(iic_scan, "Scan for active chips on the bus");
+MODULE_PARM_DESC(i2c_debug,
+		 "debug level - 0 off; 1 normal; 2,3 more verbose; 9 iic-protocol");
+
+MODULE_LICENSE("GPL");
+
+module_init(i2c_algo_iic_init);
+module_exit(i2c_algo_iic_exit);
diff -Naru linux-2.4.28.orig/drivers/i2c/i2c-ibm_iic.h linux-2.4.28/drivers/i2c/i2c-ibm_iic.h
--- linux-2.4.28.orig/drivers/i2c/i2c-ibm_iic.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/drivers/i2c/i2c-ibm_iic.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,106 @@
+/*
+ * drivers/i2c/i2c-ibm_iic.h
+ *
+ * Support for the IIC peripheral on IBM PPC 4xx
+ * 
+ * Copyright (c) 2003 Zultys Technologies.
+ * Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>
+ *
+ * Based on original work by 
+ * 	Ian DaSilva  <idasilva@mvista.com>
+ *      Armin Kuster <akuster@mvista.com>
+ * 	Matt Porter  <mporter@mvista.com>
+ *
+ *      Copyright 2000-2003 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#ifndef __I2C_IBM_IIC_H_
+#define __I2C_IBM_IIC_H_
+
+#include <linux/config.h>
+#include <linux/i2c.h> 
+
+struct ibm_iic_private {
+	struct i2c_adapter adap;
+	volatile struct iic_regs *vaddr;
+	wait_queue_head_t wq;
+	int idx;
+	int irq;
+	int fast_mode;
+	u8  clckdiv;
+};
+
+/* IICx_CNTL register */
+#define CNTL_HMT	0x80
+#define CNTL_AMD	0x40
+#define CNTL_TCT_MASK	0x30
+#define CNTL_TCT_SHIFT	4
+#define CNTL_RPST	0x08
+#define CNTL_CHT	0x04 
+#define CNTL_RW		0x02
+#define CNTL_PT		0x01
+
+/* IICx_MDCNTL register */
+#define MDCNTL_FSDB	0x80
+#define MDCNTL_FMDB	0x40
+#define MDCNTL_EGC	0x20
+#define MDCNTL_FSM	0x10
+#define MDCNTL_ESM	0x08
+#define MDCNTL_EINT	0x04
+#define MDCNTL_EUBS	0x02
+#define MDCNTL_HSCL	0x01
+
+/* IICx_STS register */
+#define STS_SSS		0x80
+#define STS_SLPR	0x40
+#define STS_MDBS	0x20
+#define STS_MDBF	0x10
+#define STS_SCMP	0x08
+#define STS_ERR		0x04
+#define STS_IRQA	0x02
+#define STS_PT		0x01
+
+/* IICx_EXTSTS register */
+#define EXTSTS_IRQP	0x80
+#define EXTSTS_BCS_MASK	0x70
+#define   EXTSTS_BCS_FREE  0x40
+#define EXTSTS_IRQD	0x08
+#define EXTSTS_LA	0x04
+#define EXTSTS_ICT	0x02
+#define EXTSTS_XFRA	0x01
+
+/* IICx_INTRMSK register */
+#define INTRMSK_EIRC	0x80
+#define INTRMSK_EIRS	0x40
+#define INTRMSK_EIWC	0x20
+#define INTRMSK_EIWS	0x10
+#define INTRMSK_EIHE	0x08
+#define INTRMSK_EIIC	0x04
+#define INTRMSK_EITA	0x02
+#define INTRMSK_EIMTC	0x01
+
+/* IICx_XFRCNT register */
+#define XFRCNT_MTC_MASK	0x07
+
+/* IICx_XTCNTLSS register */
+#define XTCNTLSS_SRC	0x80
+#define XTCNTLSS_SRS	0x40
+#define XTCNTLSS_SWC	0x20
+#define XTCNTLSS_SWS	0x10
+#define XTCNTLSS_SRST	0x01
+
+/* IICx_DIRECTCNTL register */
+#define DIRCNTL_SDAC	0x08
+#define DIRCNTL_SCC	0x04
+#define DIRCNTL_MSDA	0x02
+#define DIRCNTL_MSC	0x01
+
+/* Check if we really control the I2C bus and bus is free */
+#define DIRCTNL_FREE(v)	(((v) & 0x0f) == 0x0f)
+
+#endif /* __I2C_IBM_IIC_H_ */
diff -Naru linux-2.4.28.orig/drivers/ide/ide-disk.c linux-2.4.28/drivers/ide/ide-disk.c
--- linux-2.4.28.orig/drivers/ide/ide-disk.c	2004-08-08 08:26:04.000000000 +0900
+++ linux-2.4.28/drivers/ide/ide-disk.c	2005-01-31 11:52:56.000000000 +0900
@@ -41,6 +41,10 @@
  * Version 1.16		added suspend-resume-checkpower
  * Version 1.17		do flush on standy, do flush on ATA < ATA6
  *			fix wcache setup.
+ *
+ * PlatHome <openlab.plathome.co.jp>
+ *	- Added LED Display for OpenBlockS 266
+ *	- Added for OpenBlockS 50
  */
 
 #define IDEDISK_VERSION	"1.17"
@@ -1722,6 +1726,10 @@
 	drive->no_io_32bit = id->dword_io ? 1 : 0;
 	if (drive->id->cfs_enable_2 & 0x3000)
 		write_cache(drive, (id->cfs_enable_2 & 0x3000));
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	extern int obsled_out(int);
+	obsled_out(4);
+#endif
 }
 
 static int idedisk_cleanup(ide_drive_t *drive)
diff -Naru linux-2.4.28.orig/drivers/ide/ide-probe.c linux-2.4.28/drivers/ide/ide-probe.c
--- linux-2.4.28.orig/drivers/ide/ide-probe.c	2004-04-14 22:05:29.000000000 +0900
+++ linux-2.4.28/drivers/ide/ide-probe.c	2005-01-31 11:52:56.000000000 +0900
@@ -29,6 +29,13 @@
  * 			then fall over when they get to 256.	Paul G.
  * Version 1.10		Update set for new IDE. drive->id is now always
  *			valid after probe time even with noprobe
+ * 
+ *	Century <www.centurysys.co.jp>
+ *		- Added LED display
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added CONFIG_OBS200
+ *		- just fixed around CONFIG_IDEPCI_SHARE_IRQ
+ * 
  */
 
 #undef REALLY_SLOW_IO		/* most systems can safely undef this */
@@ -55,6 +62,10 @@
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
+#ifdef CONFIG_OBS200
+#include <asm/segled_obs200.h>
+#define OPNT ((volatile unsigned char *)(0x40000000))
+#endif
 
 /**
  *	generic_id		-	add a generic drive id
@@ -326,7 +337,11 @@
 		/* ask drive for ID */
 		hwif->OUTB(cmd, IDE_COMMAND_REG);
 	}
+#ifdef CONFIG_OBS200
+	timeout = ((cmd == WIN_IDENTIFY) ? (WAIT_WORSTCASE/10) : (WAIT_PIDENTIFY/10)) / 2;
+#else
 	timeout = ((cmd == WIN_IDENTIFY) ? WAIT_WORSTCASE : WAIT_PIDENTIFY) / 2;
+#endif
 	timeout += jiffies;
 	do {
 		if (time_after(jiffies, timeout)) {
@@ -355,6 +370,9 @@
 		/* drive refused ID */
 		rc = 2;
 	}
+#ifdef CONFIG_OBS200
+	*OPNT = (unsigned char)~(SL_V3);
+#endif
 	return rc;
 }
 
@@ -860,7 +878,7 @@
 
 	local_irq_set(flags);
 
-#ifdef CONFIG_PPC
+#ifdef CONFIG_ALL_PPC
 	/* This is needed on some PPCs and a bunch of BIOS-less embedded
 	 * platforms. Typical cases are:
 	 * 
@@ -882,7 +900,7 @@
 	 */
 	if (ide_wait_hwif_ready(hwif))
 		printk(KERN_WARNING "%s: Wait for ready failed before probe !\n", hwif->name);
-#endif /* CONFIG_PPC */
+#endif /* CONFIG_ALL_PPC */
 
 	/*
 	 * Second drive should only exist if first drive was found,
diff -Naru linux-2.4.28.orig/drivers/ide/pci/hpt366.c linux-2.4.28/drivers/ide/pci/hpt366.c
--- linux-2.4.28.orig/drivers/ide/pci/hpt366.c	2004-08-08 08:26:04.000000000 +0900
+++ linux-2.4.28/drivers/ide/pci/hpt366.c	2005-01-31 11:52:56.000000000 +0900
@@ -51,6 +51,9 @@
  * keeping me sane. 
  *		Alan Cox <alan@redhat.com>
  *
+ *
+ *  PlatHome <openlab.plathome.co.jp>
+ *	- Adjusted for OpenBlockS 266
  */
 
 
@@ -100,7 +103,7 @@
 	int i;
 
 	p += sprintf(p, "\n                             "
-		"HighPoint HPT366/368/370/372/374\n");
+		"HighPoint HPT366/368/370/371/372/374\n");
 	for (i = 0; i < n_hpt_devs; i++) {
 		struct pci_dev *dev = hpt_devs[i];
 		unsigned long iobase = dev->resource[4].start;
@@ -573,6 +576,13 @@
 no_dma_set:
 		hpt3xx_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
+#ifdef CONFIG_OBS266
+	} else {
+		if( !(id && (id->capability & 1)) ){
+			printk("HPT37X: %s: unsupported DMA drive\n", drive->name);
+			goto fast_ata_pio;
+		}
+#endif
 	}
 	/* IORDY not supported */
 	return 0;
@@ -1214,6 +1224,9 @@
 		pci_write_config_word(dev, 0x52, mcr3);
 		pci_write_config_word(dev, 0x56, mcr6);
 	} else if (hpt_minimum_revision(dev, 3)) {
+#ifdef CONFIG_OBS266
+		ata66 = 0;
+#else
 		/*
 		 * HPT370/372 and 374 pcifn 0
 		 * - clear bit 0 of 0x5b to enable P/SCBLID as inputs
@@ -1224,6 +1237,7 @@
 		/* now read cable id register */
 		pci_read_config_byte(dev, 0x5a, &ata66);
 		pci_write_config_byte(dev, 0x5b, scr2);
+#endif
 	} else {
 		pci_read_config_byte(dev, 0x5a, &ata66);
 	}
diff -Naru linux-2.4.28.orig/drivers/ide/pci/hpt366.h linux-2.4.28/drivers/ide/pci/hpt366.h
--- linux-2.4.28.orig/drivers/ide/pci/hpt366.h	2003-06-13 23:51:33.000000000 +0900
+++ linux-2.4.28/drivers/ide/pci/hpt366.h	2005-01-31 11:52:56.000000000 +0900
@@ -496,7 +496,11 @@
 		.channels	= 2,
 		.autodma	= AUTODMA,
 		.enablebits	= {{0x00,0x00,0x00}, {0x00,0x00,0x00}},
-		.bootable	= OFF_BOARD,
+#ifdef CONFIG_OBS266
+		.bootable       = ON_BOARD,
+#else
+		.bootable       = OFF_BOARD,
+#endif
 		.extra		= 0
 	},{	/* 4 */
 		.vendor		= PCI_VENDOR_ID_TTI,
diff -Naru linux-2.4.28.orig/drivers/ide/ppc/mpc8xx.c linux-2.4.28/drivers/ide/ppc/mpc8xx.c
--- linux-2.4.28.orig/drivers/ide/ppc/mpc8xx.c	2003-06-13 23:51:34.000000000 +0900
+++ linux-2.4.28/drivers/ide/ppc/mpc8xx.c	2005-01-31 11:52:56.000000000 +0900
@@ -9,6 +9,9 @@
  *	by Steven.Scholz@imc-berlin.de
  *  Moved out of arch/ppc/kernel/m8xx_setup.c, other minor cleanups
  *	by Mathew Locke <mattl@mvista.com>
+ *
+ *  PlatHome <openlab@plathome.co.jp>
+ *  	- Added for OpenBlockS 50
  */
 
 #include <linux/config.h>
@@ -49,8 +52,13 @@
 static void print_funcid (int func);
 static int check_ide_device (unsigned long base);
 
+#ifdef CONFIG_OBS50
+void ide_interrupt_ack (void *dev);
+void m8xx_ide_tuneproc(ide_drive_t *drive, u8 pio);
+#else
 static void ide_interrupt_ack (void *dev);
 static void m8xx_ide_tuneproc(ide_drive_t *drive, u8 pio);
+#endif
 
 typedef	struct ide_ioport_desc {
 	unsigned long	base_off;		/* Offset to PCMCIA memory	*/
@@ -432,8 +440,13 @@
 
 
 /* Calculate PIO timings */
+#ifdef CONFIG_OBS50
+void
+m8xx_ide_tuneproc(ide_drive_t *drive, u8 pio)
+#else
 static void
 m8xx_ide_tuneproc(ide_drive_t *drive, u8 pio)
+#endif
 {
 	ide_pio_data_t d;
 #if defined(CONFIG_IDE_8xx_PCCARD) || defined(CONFIG_IDE_8xx_DIRECT)
@@ -492,8 +505,13 @@
 #endif /* defined(CONFIG_IDE_8xx_PCCARD) || defined(CONFIG_IDE_8xx_PCMCIA */
 }
 
+#ifdef CONFIG_OBS50
+void
+ide_interrupt_ack (void *dev)
+#else
 static void
 ide_interrupt_ack (void *dev)
+#endif
 {
 #ifdef CONFIG_IDE_8xx_PCCARD
 	u_int pscr, pipr;
diff -Naru linux-2.4.28.orig/drivers/ide/setup-pci.c linux-2.4.28/drivers/ide/setup-pci.c
--- linux-2.4.28.orig/drivers/ide/setup-pci.c	2003-08-25 20:44:41.000000000 +0900
+++ linux-2.4.28/drivers/ide/setup-pci.c	2005-01-31 11:52:56.000000000 +0900
@@ -416,6 +416,13 @@
 	unsigned long ctl = 0, base = 0;
 	ide_hwif_t *hwif;
 
+#ifdef CONFIG_OBS266
+	if ((dev->vendor == PCI_VENDOR_ID_TTI) &&
+	    (dev->device == PCI_DEVICE_ID_TTI_HPT371) &&
+	    (port == 0)) {
+		return NULL;
+	}
+#endif
 	/*  Possibly we should fail if these checks report true */
 	ide_pci_check_iomem(dev, d, 2*port);
 	ide_pci_check_iomem(dev, d, 2*port+1);
diff -Naru linux-2.4.28.orig/drivers/mtd/maps/redwood.c linux-2.4.28/drivers/mtd/maps/redwood.c
--- linux-2.4.28.orig/drivers/mtd/maps/redwood.c	2003-06-13 23:51:34.000000000 +0900
+++ linux-2.4.28/drivers/mtd/maps/redwood.c	2005-01-31 11:52:56.000000000 +0900
@@ -28,6 +28,9 @@
  *  History: 12/17/2001 - Armin
  *  		migrated to use do_map_probe
  *
+ *		PlatHome <openlab.plathome.co.jp>
+ *			- Added for OpenBlockS 266
+ *
  */
 
 #include <linux/module.h>
@@ -40,48 +43,61 @@
 
 #include <asm/io.h>
 
+#if defined(CONFIG_OBS266)
+#define WINDOW_ADDR 0xff800000
+#define WINDOW_SIZE 0x00800000
+#else
 #define WINDOW_ADDR 0xffc00000
 #define WINDOW_SIZE 0x00400000
+#endif
 
 __u8 redwood_flash_read8(struct map_info *map, unsigned long ofs)
 {
+	iobarrier_rw();
         return *(__u8 *)(map->map_priv_1 + ofs);
 }
 
 __u16 redwood_flash_read16(struct map_info *map, unsigned long ofs)
 {
+	iobarrier_rw();
         return *(__u16 *)(map->map_priv_1 + ofs);
 }
 
 __u32 redwood_flash_read32(struct map_info *map, unsigned long ofs)
 {
+	iobarrier_rw();
         return *(volatile unsigned int *)(map->map_priv_1 + ofs);
 }
 
 void redwood_flash_copy_from(struct map_info *map, void *to,
                              unsigned long from, ssize_t len)
 {
+	iobarrier_rw();
         memcpy(to, (void *)(map->map_priv_1 + from), len);
 }
 
 void redwood_flash_write8(struct map_info *map, __u8 d, unsigned long adr)
 {
+	iobarrier_rw();
         *(__u8 *)(map->map_priv_1 + adr) = d;
 }
 
 void redwood_flash_write16(struct map_info *map, __u16 d, unsigned long adr)
 {
+	iobarrier_rw();
         *(__u16 *)(map->map_priv_1 + adr) = d;
 }
 
 void redwood_flash_write32(struct map_info *map, __u32 d, unsigned long adr)
 {
+	iobarrier_rw();
         *(__u32 *)(map->map_priv_1 + adr) = d;
 }
 
 void redwood_flash_copy_to(struct map_info *map, unsigned long to,
                            const void *from, ssize_t len)
 {
+	iobarrier_rw();
         memcpy((void *)(map->map_priv_1 + to), from, len);
 }
 
@@ -100,6 +116,53 @@
 };
 
 
+#if defined(CONFIG_OBS266)
+#define RW_CONF_OF     0
+#define RW_CONF_SZ     0x10000          /*64Kb Variable data*/
+#define RW_BIOS_OF	0x7c0000         /* BIOS area */
+#define RW_BIOS_SZ	0x40000
+#define RW_KERN_OF	(RW_CONF_OF)+(RW_CONF_SZ)
+#if defined(CONFIG_OBS_MAXKERNSIZE) && (CONFIG_OBS_MAXKERNSIZE != 0)
+#define RW_KERN_SZ     CONFIG_OBS_MAXKERNSIZE
+#else
+#define RW_KERN_SZ     (RW_BIOS_OF) - (RW_KERN_OF)
+#endif
+#define RW_USER_OF     (RW_KERN_OF) + (RW_KERN_SZ)
+#define RW_USER_SZ     (RW_BIOS_OF) - (RW_USER_OF)
+static struct mtd_partition redwood_flash_partitions[] = {
+	{
+		name: "OpenBlockS Configuration Data",
+		offset: RW_CONF_OF,
+		size: RW_CONF_SZ
+	},
+	{
+		name: "OpenBlockS Boot Image",
+		offset: RW_KERN_OF,
+		size: RW_KERN_SZ
+	},
+	{
+		name: "OpenBlockS OpenBIOS",
+		offset: RW_BIOS_OF,
+		size: RW_BIOS_SZ,
+		mask_flags: MTD_WRITEABLE	/* force read-only */
+	},
+	{
+		name: "OpenBlockS All Flash",
+		offset: RW_CONF_OF,
+		size: RW_BIOS_OF + RW_BIOS_SZ,
+		mask_flags: MTD_WRITEABLE       /* force read-only */
+	},
+#if  (RW_USER_SZ > 0)
+	{
+		name: "OpenBlockS User Flash",
+		offset: RW_USER_OF,
+		size: RW_USER_SZ,
+	}
+#elif (RW_USER_SZ < 0)
+#error  "Kernel Size Invalid"
+#endif	
+};
+#else
 static struct mtd_partition redwood_flash_partitions[] = {
         {
                 name: "Redwood OpenBIOS Vital Product Data",
@@ -130,6 +193,7 @@
                 mask_flags: MTD_WRITEABLE       /* force read-only */
         }
 };
+#endif
 #define NUM_REDWOOD_FLASH_PARTITIONS \
         (sizeof(redwood_flash_partitions)/sizeof(redwood_flash_partitions[0]))
 
diff -Naru linux-2.4.28.orig/drivers/net/8139too.c linux-2.4.28/drivers/net/8139too.c
--- linux-2.4.28.orig/drivers/net/8139too.c	2004-11-17 20:54:21.000000000 +0900
+++ linux-2.4.28/drivers/net/8139too.c	2005-01-31 11:52:56.000000000 +0900
@@ -89,6 +89,10 @@
 
 		See 8139too.txt for more details.
 
+	PlatHome <openlab.plathome.co.jp>
+		- Added __BIG_ENDIAN
+
+
 */
 
 #define DRV_NAME	"8139too"
@@ -2448,7 +2452,11 @@
 		     i++, mclist = mclist->next) {
 			int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
 
+#ifdef __BIG_ENDIAN
 			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+#else
+			mc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));
+#endif
 			rx_mode |= AcceptMulticast;
 		}
 	}
diff -Naru linux-2.4.28.orig/drivers/net/Makefile linux-2.4.28/drivers/net/Makefile
--- linux-2.4.28.orig/drivers/net/Makefile	2004-08-08 08:26:04.000000000 +0900
+++ linux-2.4.28/drivers/net/Makefile	2005-01-31 11:52:56.000000000 +0900
@@ -21,12 +21,12 @@
 list-multi	:=	rcpci.o
 rcpci-objs	:=	rcpci45.o rclanmtl.o
 
+obj-$(CONFIG_OCP_NET) += ibm_emac/ocp.o
+
 ifeq ($(CONFIG_TULIP),y)
   obj-y += tulip/tulip.o
 endif
 
-obj-$(CONFIG_OCP_NET) += ibm_emac/ocp.o
-
 ifeq ($(CONFIG_E1000),y)
   obj-y += e1000/e1000.o
 endif
diff -Naru linux-2.4.28.orig/drivers/net/e100/e100_main.c linux-2.4.28/drivers/net/e100/e100_main.c
--- linux-2.4.28.orig/drivers/net/e100/e100_main.c	2004-11-17 20:54:21.000000000 +0900
+++ linux-2.4.28/drivers/net/e100/e100_main.c	2005-01-31 11:52:56.000000000 +0900
@@ -1358,6 +1358,9 @@
 	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
 	case SIOCGMIIREG:	/* Read MII PHY register. */
 	case SIOCSMIIREG:	/* Write to MII PHY register. */
+	case SIOCDEVPRIVATE:
+	case SIOCDEVPRIVATE + 1:
+	case SIOCDEVPRIVATE + 2:
 		return e100_mii_ioctl(dev, ifr, cmd);
 		break;
 
@@ -4023,10 +4026,12 @@
 
 	switch (cmd) {
 	case SIOCGMIIPHY:
+	case SIOCDEVPRIVATE:
 		data_ptr->phy_id = bdp->phy_addr & 0x1f;
-		break;
+/*		break;	*/
 
 	case SIOCGMIIREG:
+	case SIOCDEVPRIVATE + 1:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 		e100_mdi_read(bdp, data_ptr->reg_num & 0x1f, bdp->phy_addr,
@@ -4034,6 +4039,7 @@
 		break;
 
 	case SIOCSMIIREG:
+	case SIOCDEVPRIVATE + 2:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
 		/* If reg = 0 && change speed/duplex */
diff -Naru linux-2.4.28.orig/drivers/net/ibm_emac/ibm_ocp_enet.c linux-2.4.28/drivers/net/ibm_emac/ibm_ocp_enet.c
--- linux-2.4.28.orig/drivers/net/ibm_emac/ibm_ocp_enet.c	2004-04-14 22:05:30.000000000 +0900
+++ linux-2.4.28/drivers/net/ibm_emac/ibm_ocp_enet.c	2005-01-31 11:52:56.000000000 +0900
@@ -1101,11 +1101,14 @@
 emac_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct ocp_enet_private *fep = dev->priv;
-	uint *data = (uint *) & rq->ifr_data;
+//	uint *data = (uint *) & rq->ifr_data;
+	struct mii_ioctl_data *odata = (struct mii_ioctl_data *) & rq->ifr_data;
+	uint wdata[4];
 
 	switch (cmd) {
         case SIOCETHTOOL:
                 return emac_ethtool(dev, rq->ifr_data);
+#if 0
 	case SIOCDEVPRIVATE:
 	case SIOCGMIIPHY:
 		data[0] = fep->mii_phy_addr;
@@ -1121,6 +1124,28 @@
 
 		emac_phy_write(dev, fep->mii_phy_addr, data[1], data[2]);
 		return 0;
+#else
+	case SIOCDEVPRIVATE:
+	case SIOCGMIIPHY:
+		odata->phy_id = (u16) fep->mii_phy_addr;
+		/*FALLTHRU*/
+	case SIOCDEVPRIVATE + 1:
+	case SIOCGMIIREG:
+		wdata[1] = (uint) odata->reg_num;
+		wdata[3] = emac_phy_read(dev, fep->mii_phy_addr, wdata[1]);
+		odata->val_out = (u16) wdata[3];
+		return 0;
+	case SIOCDEVPRIVATE + 2:
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		wdata[1] = (uint) odata->reg_num;
+		wdata[2] = (uint) odata->val_in;
+
+		emac_phy_write(dev, fep->mii_phy_addr, wdata[1], wdata[2]);
+		return 0;
+#endif
 	default:
 		return -EOPNOTSUPP;
 	}
diff -Naru linux-2.4.28.orig/drivers/net/ibm_emac/ibm_ocp_phy.c linux-2.4.28/drivers/net/ibm_emac/ibm_ocp_phy.c
--- linux-2.4.28.orig/drivers/net/ibm_emac/ibm_ocp_phy.c	2003-08-25 20:44:42.000000000 +0900
+++ linux-2.4.28/drivers/net/ibm_emac/ibm_ocp_phy.c	2005-01-31 11:52:56.000000000 +0900
@@ -173,7 +173,18 @@
 	 return 0;
 }
 
+#ifdef CONFIG_OBS266
+static int genmii_init(struct mii_phy *phy) {
+#define MII_LXT971A_CFG         16      /* PHY Configuration Register */
+	/* On OpenBlockS266 PHY is LXT972A bit 6 4;3 2 0 has no meaning. */
+	/* So direct write 0x0180 to disable TP Loopback.                */
+	/* When using LXT971A bit 6 0 come from hardware pin setting.    */
+	/* So first read register then set bit 8 and write to register.  */
+	phy_write(phy, MII_LXT971A_CFG, 0x0180);
 
+	udelay(100);
+}
+#endif
 #define MII_BASIC_FEATURES	(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full | \
 				 SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full | \
 				 SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII)
@@ -183,6 +194,9 @@
 
 /* Generic implementation for most 10/100 PHYs */
 static struct mii_phy_ops generic_phy_ops = {
+#ifdef CONFIG_OBS266
+	init:		genmii_init,
+#endif
 	setup_aneg:	genmii_setup_aneg,
 	setup_forced:	genmii_setup_forced,
 	poll_link:	genmii_poll_link,
diff -Naru linux-2.4.28.orig/drivers/net/setup.c linux-2.4.28/drivers/net/setup.c
--- linux-2.4.28.orig/drivers/net/setup.c	2001-07-05 06:41:33.000000000 +0900
+++ linux-2.4.28/drivers/net/setup.c	2005-01-31 11:52:56.000000000 +0900
@@ -1,6 +1,10 @@
 
 /*
  *	New style setup code for the network devices
+ *
+ *	PlatHome <openlab@plathome.co.jp>
+ *		- Modified probe order fec_enet and scc_enet
+ *		  for OpenBlockS 50
  */
  
 #include <linux/config.h>
@@ -66,12 +70,21 @@
 #if defined(CONFIG_ARCNET)
 	{arcnet_init, 0},
 #endif
+#ifdef CONFIG_OBS50
+#if defined(CONFIG_FEC_ENET)
+        {fec_enet_init, 0},
+#endif
+#if defined(CONFIG_SCC_ENET)
+        {scc_enet_init, 0},
+#endif
+#else
 #if defined(CONFIG_SCC_ENET)
         {scc_enet_init, 0},
 #endif
 #if defined(CONFIG_FEC_ENET)
         {fec_enet_init, 0},
 #endif
+#endif /* CONFIG_OBS50 */
 #if defined(CONFIG_COMX)
 	{comx_init, 0},
 #endif
diff -Naru linux-2.4.28.orig/drivers/net/tulip/21142.c linux-2.4.28/drivers/net/tulip/21142.c
--- linux-2.4.28.orig/drivers/net/tulip/21142.c	2003-06-13 23:51:35.000000000 +0900
+++ linux-2.4.28/drivers/net/tulip/21142.c	2005-01-31 11:52:56.000000000 +0900
@@ -56,7 +56,11 @@
 			t21142_start_nway(dev);
 			next_tick = 3*HZ;
 		}
+#ifdef CONFIG_OBS2xx
+	} else if (((csr12 & 0x7000) != 0x5000) && tp->chip_id != X3201_3) {
+#else
 	} else if ((csr12 & 0x7000) != 0x5000) {
+#endif
 		/* Negotiation failed.  Search media types. */
 		if (tulip_debug > 1)
 			printk(KERN_INFO"%s: 21143 negotiation failed, status %8.8x.\n",
diff -Naru linux-2.4.28.orig/drivers/net/tulip/interrupt.c linux-2.4.28/drivers/net/tulip/interrupt.c
--- linux-2.4.28.orig/drivers/net/tulip/interrupt.c	2003-06-13 23:51:35.000000000 +0900
+++ linux-2.4.28/drivers/net/tulip/interrupt.c	2005-01-31 11:52:56.000000000 +0900
@@ -380,7 +380,11 @@
 							 PCI_DMA_TODEVICE);
 					continue;
 				}
-
+#ifdef CONFIG_OBS2xx
+				if ((tp->chip_id == X3201_3) && tp->full_duplex &&
+					((status & 0xcf86) == 0x8800))
+					status &= ~0x8800;
+#endif
 				if (status & 0x8000) {
 					/* There was an major error, log it. */
 #ifndef final_version
diff -Naru linux-2.4.28.orig/drivers/net/tulip/media.c linux-2.4.28/drivers/net/tulip/media.c
--- linux-2.4.28.orig/drivers/net/tulip/media.c	2003-06-13 23:51:35.000000000 +0900
+++ linux-2.4.28/drivers/net/tulip/media.c	2005-01-31 11:52:56.000000000 +0900
@@ -383,6 +383,24 @@
 			outl(0x0000, ioaddr + CSR15);
 		}
 		outl(0x8f01 | t21040_csr13[dev->if_port], ioaddr + CSR13);
+#ifdef CONFIG_OBS2xx
+	} else if (tp->chip_id == X3201_3) {					/* Xircom */
+		if (tp->default_port == 0)
+			dev->if_port = tp->mii_cnt ? 11 : 3;
+/* Someone is on crack, the Xircom only does MII, no Fx */
+/*		if (media_cap[dev->if_port] & MediaIsMII) {
+			new_csr6 = 0x020E0000;
+		} else if (media_cap[dev->if_port] & MediaIsFx) {
+			new_csr6 = 0x028600000;
+		} else
+			new_csr6 = 0x038600000;*/
+		new_csr6 = 0x324c0000;
+		if (tulip_debug > 1)
+			printk(KERN_DEBUG "%s: Xircom CardBus Adapter: "
+				   "%s transceiver, CSR12 %2.2x.\n",
+				   dev->name, medianame[dev->if_port],
+				   inl(ioaddr + CSR12));
+#endif
 	} else {					/* Unknown chip type with no media table. */
 		if (tp->default_port == 0)
 			dev->if_port = tp->mii_cnt ? 11 : 3;
diff -Naru linux-2.4.28.orig/drivers/net/tulip/timer.c linux-2.4.28/drivers/net/tulip/timer.c
--- linux-2.4.28.orig/drivers/net/tulip/timer.c	2004-08-08 08:26:05.000000000 +0900
+++ linux-2.4.28/drivers/net/tulip/timer.c	2005-01-31 11:52:56.000000000 +0900
@@ -87,6 +87,12 @@
 			break;
 		}
 		break;
+#ifdef CONFIG_OBS2xx
+	case X3201_3:
+		tulip_check_duplex(dev);
+		next_tick = 10*HZ;
+		break;
+#endif
 	case DC21140:
 	case DC21142:
 	case MX98713:
@@ -205,7 +211,6 @@
 {
 	struct net_device *dev = (struct net_device *)data;
 	struct tulip_private *tp = (struct tulip_private *)dev->priv;
-	long ioaddr = dev->base_addr;
 	int next_tick = 60*HZ;
 
 	if (tulip_debug > 1)
diff -Naru linux-2.4.28.orig/drivers/net/tulip/tulip.h linux-2.4.28/drivers/net/tulip/tulip.h
--- linux-2.4.28.orig/drivers/net/tulip/tulip.h	2002-11-29 08:53:14.000000000 +0900
+++ linux-2.4.28/drivers/net/tulip/tulip.h	2005-01-31 11:52:56.000000000 +0900
@@ -11,6 +11,9 @@
 	for more information on this driver, or visit the project
 	Web page at http://sourceforge.net/projects/tulip/
 
+	PlatHome <openlab.plathome.co.jp>
+		- Added for OpenBlockS 2xx
+
 */
 
 #ifndef __NET_TULIP_H__
@@ -86,6 +89,9 @@
 	I21145,
 	DM910X,
 	CONEXANT,
+#ifdef CONFIG_OBS2xx
+	X3201_3,
+#endif
 };
 
 
@@ -332,6 +338,10 @@
 
 struct ring_info {
 	struct sk_buff	*skb;
+#ifdef CONFIG_OBS2xx
+	char *bounce_buffer;
+	size_t bb_size;
+#endif
 	dma_addr_t	mapping;
 };
 
@@ -347,6 +357,10 @@
 	struct ring_info tx_buffers[TX_RING_SIZE];
 	/* The addresses of receive-in-place skbuffs. */
 	struct ring_info rx_buffers[RX_RING_SIZE];
+#ifdef CONFIG_OBS2xx
+	/* The X3201-3 requires double word aligned tx bufs */
+	struct sk_buff* tx_aligned_skbuff[TX_RING_SIZE];
+#endif
 	u16 setup_frame[96];	/* Pseudo-Tx frame to init address table. */
 	int chip_id;
 	int revision;
@@ -452,6 +466,9 @@
 extern u16 t21041_csr13[];
 extern u16 t21041_csr14[];
 extern u16 t21041_csr15[];
+#ifdef CONFIG_OBS2xx
+void outl_CSR6 (u32 newcsr6, long ioaddr, int chip_idx);
+#endif
 
 #ifndef USE_IO_OPS
 #undef inb
@@ -468,12 +485,14 @@
 #define outl(val,addr) writel((val), (void*)(addr))
 #endif /* !USE_IO_OPS */
 
-
-
 static inline void tulip_start_rxtx(struct tulip_private *tp)
 {
 	long ioaddr = tp->base_addr;
+#ifdef CONFIG_OBS2xx
+	outl_CSR6(tp->csr6 | RxTx, ioaddr, tp->chip_id);
+#else
 	outl(tp->csr6 | RxTx, ioaddr + CSR6);
+#endif
 	barrier();
 	(void) inl(ioaddr + CSR6); /* mmio sync */
 }
@@ -484,7 +503,11 @@
 	u32 csr6 = inl(ioaddr + CSR6);
 
 	if (csr6 & RxTx) {
+#ifdef CONFIG_OBS2xx
+		outl_CSR6(csr6 & ~RxTx, ioaddr, tp->chip_id);
+#else
 		outl(csr6 & ~RxTx, ioaddr + CSR6);
+#endif
 		barrier();
 		(void) inl(ioaddr + CSR6); /* mmio sync */
 	}
diff -Naru linux-2.4.28.orig/drivers/net/tulip/tulip_core.c linux-2.4.28/drivers/net/tulip/tulip_core.c
--- linux-2.4.28.orig/drivers/net/tulip/tulip_core.c	2004-08-08 08:26:05.000000000 +0900
+++ linux-2.4.28/drivers/net/tulip/tulip_core.c	2005-01-31 11:52:56.000000000 +0900
@@ -11,6 +11,9 @@
 	Please refer to Documentation/DocBook/tulip.{pdf,ps,html}
 	for more information on this driver, or visit the project
 	Web page at http://sourceforge.net/projects/tulip/
+	
+	PlatHome <openlab.plathome.co.jp>
+		- Added for OpenBlockS 2xx
 
 */
 
@@ -195,6 +198,13 @@
   /* CONEXANT */
   {	"Conexant LANfinity", 256, 0x0001ebef,
 	HAS_MII, tulip_timer },
+
+#ifdef CONFIG_OBS2xx
+  /* XIRCOM */
+  { "Xircom Cardbus Adapter (DEC 21143 compatible mode)", 128, 0x0801fbff,
+        HAS_MII | HAS_ACPI, tulip_timer },
+#endif
+
 };
 
 
@@ -235,6 +245,9 @@
 	{ 0x14f1, 0x1803, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CONEXANT },
 	{ 0x10b9, 0x5261, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DM910X },	/* ALi 1563 integrated ethernet */
 	{ 0x10b7, 0x9300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, COMET },	/* 3Com 3CSOHO100B-TX */
+#ifdef CONFIG_OBS2xx
+	{ 0x115D, 0x0003, PCI_ANY_ID, PCI_ANY_ID, 0, 0, X3201_3 },
+#endif
 	{ } /* terminate list */
 };
 MODULE_DEVICE_TABLE(pci, tulip_pci_tbl);
@@ -268,7 +281,58 @@
 static int private_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static void set_rx_mode(struct net_device *dev);
 
+/* The Xircom cards are picky about when certain bits in CSR6 can be
+   manipulated.  Keith Owens <kaos@ocs.com.au>. */
 
+#ifdef CONFIG_OBS2xx
+void outl_CSR6 (u32 newcsr6, long ioaddr, int chip_idx)
+{
+	const int strict_bits = 0x0060e202;
+    int csr5, csr5_22_20, csr5_19_17, currcsr6, attempts = 200;
+    long flags;
+    save_flags(flags);
+    cli();
+    if (chip_idx != X3201_3) {
+		outl(newcsr6, ioaddr + CSR6);
+		restore_flags(flags);
+		return;
+    }
+    newcsr6 &= 0x726cfecb; /* mask out the reserved CSR6 bits that always */
+			   /* read 0 on the Xircom cards */
+    newcsr6 |= 0x320c0000; /* or in the reserved bits that always read 1 */
+    currcsr6 = inl(ioaddr + CSR6);
+    if (((newcsr6 & strict_bits) == (currcsr6 & strict_bits)) ||
+	((currcsr6 & ~0x2002) == 0)) {
+		outl(newcsr6, ioaddr + CSR6);	/* safe */
+		restore_flags(flags);
+		return;
+    }
+    /* make sure the transmitter and receiver are stopped first */
+    currcsr6 &= ~0x2002;
+    while (1) {
+		csr5 = inl(ioaddr + CSR5);
+		if (csr5 == 0xffffffff)
+			break;  /* cannot read csr5, card removed? */
+		csr5_22_20 = csr5 & 0x700000;
+		csr5_19_17 = csr5 & 0x0e0000;
+		if ((csr5_22_20 == 0 || csr5_22_20 == 0x600000) &&
+			(csr5_19_17 == 0 || csr5_19_17 == 0x80000 || csr5_19_17 == 0xc0000))
+			break;  /* both are stopped or suspended */
+		if (!--attempts) {
+			printk(KERN_INFO "tulip.c: outl_CSR6 too many attempts,"
+				   "csr5=0x%08x\n", csr5);
+			outl(newcsr6, ioaddr + CSR6);  /* unsafe but do it anyway */
+			restore_flags(flags);
+			return;
+		}
+		outl(currcsr6, ioaddr + CSR6);
+		udelay(50);
+    }
+    /* now it is safe to change csr6 */
+    outl(newcsr6, ioaddr + CSR6);
+    restore_flags(flags);
+}
+#endif
 
 static void tulip_set_power_state (struct tulip_private *tp,
 				   int sleep, int snooze)
@@ -300,7 +364,11 @@
 
 	/* On some chip revs we must set the MII/SYM port before the reset!? */
 	if (tp->mii_cnt  ||  (tp->mtable  &&  tp->mtable->has_mii))
+#ifdef CONFIG_OBS2xx
+		outl_CSR6(0x00040000, ioaddr, tp->chip_id);
+#else
 		outl(0x00040000, ioaddr + CSR6);
+#endif
 
 	/* Reset the chip, holding bit 0 set at least 50 PCI cycles. */
 	outl(0x00000001, ioaddr + CSR0);
@@ -329,8 +397,10 @@
 			outl(1, ioaddr + CSR13);
 			outl(addr_high, ioaddr + CSR14);
 		} else if (tp->flags & COMET_MAC_ADDR) {
+#ifndef		CONFIG_OBS2xx
 			outl(addr_low,  ioaddr + 0xA4);
 			outl(addr_high, ioaddr + 0xA8);
+#endif
 			outl(0, ioaddr + 0xAC);
 			outl(0, ioaddr + 0xB0);
 		}
@@ -355,6 +425,10 @@
 
 		/* Put the setup frame on the Tx list. */
 		tp->tx_ring[tp->cur_tx].length = cpu_to_le32(0x08000000 | 192);
+#ifdef CONFIG_OBS2xx
+		if (tp->chip_id == X3201_3)
+			tp->tx_ring[0].length |= cpu_to_le32(0x60000000);
+#endif
 		tp->tx_ring[tp->cur_tx].buffer1 = cpu_to_le32(mapping);
 		tp->tx_ring[tp->cur_tx].status = cpu_to_le32(DescOwned);
 
@@ -467,6 +541,16 @@
 		tp->csr6 = 0x01a80200;
 		outl(0x0f370000 | inw(ioaddr + 0x80), ioaddr + 0x80);
 		outl(0x11000 | inw(ioaddr + 0xa0), ioaddr + 0xa0);
+#ifdef CONFIG_OBS2xx
+	} else if (tp->chip_id == X3201_3) {
+		outl(0x0008, ioaddr + CSR15);
+		udelay(5);
+		outl(0xa8050000, ioaddr + CSR15);
+		udelay(5);
+		outl(0xa00f0000, ioaddr + CSR15); 
+		udelay(5);
+		tp->csr6  = 0x32400000;
+#endif
 	} else if (tp->chip_id == COMET || tp->chip_id == CONEXANT) {
 		/* Enable automatic Tx underrun recovery. */
 		outl(inl(ioaddr + 0x88) | 1, ioaddr + 0x88);
@@ -481,7 +565,11 @@
 	tulip_stop_rxtx(tp);
 	barrier();
 	udelay(5);
+#ifdef CONFIG_OBS2xx
+	outl_CSR6(tp->csr6 | TxOn, ioaddr, tp->chip_id);
+#else
 	outl(tp->csr6 | TxOn, ioaddr + CSR6);
+#endif
 
 	/* Enable interrupts by setting the interrupt mask. */
 	outl(tulip_tbl[tp->chip_id].valid_intrs, ioaddr + CSR5);
@@ -709,6 +797,12 @@
 		tp->tx_buffers[i].mapping = 0;
 		tp->tx_ring[i].status = 0x00000000;
 		tp->tx_ring[i].buffer2 = cpu_to_le32(tp->tx_ring_dma + sizeof(struct tulip_tx_desc) * (i + 1));
+#ifdef CONFIG_OBS2xx
+		tp->tx_buffers[i].bounce_buffer = NULL;
+		tp->tx_buffers[i].bb_size = 0;
+		if (tp->chip_id == X3201_3)
+			tp->tx_aligned_skbuff[i] = dev_alloc_skb(PKT_BUF_SZ);
+#endif
 	}
 	tp->tx_ring[i-1].buffer2 = cpu_to_le32(tp->tx_ring_dma);
 }
@@ -728,8 +822,28 @@
 	entry = tp->cur_tx % TX_RING_SIZE;
 
 	tp->tx_buffers[entry].skb = skb;
+#ifdef CONFIG_OBS2xx
+	{
+	  /*realloc bounce buffer*/
+	  u32 ptr; /*XXX I want to use uintptr_t */
+	  if(tp->tx_buffers[entry].bb_size < skb->len){ 
+	    tp->tx_buffers[entry].bb_size = skb->len;
+	    if(tp->tx_buffers[entry].bounce_buffer)
+	      kfree(tp->tx_buffers[entry].bounce_buffer);
+	    tp->tx_buffers[entry].bounce_buffer = kmalloc(skb->len+3,
+							  GFP_ATOMIC);
+	  }
+	  /*Align 4 byte boundary*/
+	  ptr = (u32)tp->tx_buffers[entry].bounce_buffer + 3;
+	  ptr &= ~3;
+	  
+	  memcpy((void *)ptr, skb->data, skb->len);
+	  mapping = pci_map_single(tp->pdev, (void *)ptr, skb->len, PCI_DMA_TODEVICE);
+	}
+#else
 	mapping = pci_map_single(tp->pdev, skb->data,
 				 skb->len, PCI_DMA_TODEVICE);
+#endif
 	tp->tx_buffers[entry].mapping = mapping;
 	tp->tx_ring[entry].buffer1 = cpu_to_le32(mapping);
 
@@ -892,6 +1006,13 @@
 		}
 		tp->tx_buffers[i].skb = NULL;
 		tp->tx_buffers[i].mapping = 0;
+#ifdef CONFIG_OBS2xx
+		if(tp->tx_buffers[i].bounce_buffer != NULL) {
+			kfree(tp->tx_buffers[i].bounce_buffer);
+		}
+		tp->tx_buffers[i].bounce_buffer = NULL;
+		tp->tx_buffers[i].bb_size = 0;
+#endif
 	}
 
 	MOD_DEC_USE_COUNT;
@@ -1180,6 +1301,10 @@
 	} else {
 		unsigned long flags;
 		u32 tx_flags = 0x08000000 | 192;
+#ifdef CONFIG_OBS2xx
+		if (tp->chip_id == X3201_3)
+			tx_flags |= 0x60000000;
+#endif
 
 		/* Note that only the low-address shortword of setup_frame is valid!
 		   The values are doubled for big-endian architectures. */
@@ -1238,7 +1363,11 @@
 		spin_unlock_irqrestore(&tp->lock, flags);
 	}
 
+#ifdef CONFIG_OBS2xx
+	outl_CSR6(csr6, ioaddr, tp->chip_id);
+#else
 	outl(csr6, ioaddr + CSR6);
+#endif
 }
 
 #ifdef CONFIG_TULIP_MWI
@@ -1497,7 +1626,11 @@
 		tulip_mwi_config (pdev, dev);
 #else
 	/* MWI is broken for DC21143 rev 65... */
+#ifdef CONFIG_OBS2xx
+	if ((chip_idx == DC21143 && chip_rev == 65) || (chip_idx == X3201_3))
+#else
 	if (chip_idx == DC21143 && chip_rev == 65)
+#endif
 		tp->csr0 &= ~MWI;
 #endif
 
@@ -1545,10 +1678,57 @@
 		}
 	} else if (chip_idx == COMET) {
 		/* No need to read the EEPROM. */
+#ifdef	CONFIG_OBS2xx
+		unsigned long hi, lo;
+		hi = le32_to_cpu(inl(ioaddr + 0xA4));
+		lo = le16_to_cpu(inl(ioaddr + 0xA8));
+		put_unaligned(hi, (u32 *)dev->dev_addr);
+		put_unaligned(lo, (u16 *)(dev->dev_addr + 4));
+#else
 		put_unaligned(cpu_to_le32(inl(ioaddr + 0xA4)), (u32 *)dev->dev_addr);
 		put_unaligned(cpu_to_le16(inl(ioaddr + 0xA8)), (u16 *)(dev->dev_addr + 4));
+#endif
 		for (i = 0; i < 6; i ++)
 			sum += dev->dev_addr[i];
+#ifdef CONFIG_OBS2xx
+	} else if (chip_idx == X3201_3) {
+		/* Xircom has its address stored in the CIS
+		 * we access it through the boot rom interface for now
+		 * this might not work, as the CIS is not parsed but I
+		 * (danilo) use the offset I found on my card's CIS !!!
+		 * 
+		 * Doug Ledford: I changed this routine around so that it
+		 * walks the CIS memory space, parsing the config items, and
+		 * finds the proper lan_node_id tuple and uses the data
+		 * stored there.
+		 */
+		unsigned char j, tuple, link, data_id, data_count;
+		outl(1<<12, ioaddr + CSR9); /* enable boot rom access */
+		for (i = 0x100; i < 0x1f7; i += link+2) {
+			outl(i, ioaddr + CSR10);
+			tuple = inl(ioaddr + CSR9) & 0xff;
+			outl(i + 1, ioaddr + CSR10);
+			link = inl(ioaddr + CSR9) & 0xff;
+			outl(i + 2, ioaddr + CSR10);
+			data_id = inl(ioaddr + CSR9) & 0xff;
+			outl(i + 3, ioaddr + CSR10);
+			data_count = inl(ioaddr + CSR9) & 0xff;
+			if ( (tuple == 0x22) &&
+				 (data_id == 0x04) && (data_count == 0x06) ) {
+				/*
+				 * This is it.  We have the data we want.
+				 */
+				for (j = 0; j < 6; j++) {
+					outl(i + j + 4, ioaddr + CSR10);
+					dev->dev_addr[j] = inl(ioaddr + CSR9) & 0xff;
+				}
+				break;
+			} else if (link == 0) {
+				break;
+			}
+		}
+		sum = 1; // to make check below fail!
+#endif
 	} else {
 		/* A serial EEPROM interface, we read now and sort it out later. */
 		int sa_offset = 0;
@@ -1789,6 +1969,20 @@
 		outl(0x0000, ioaddr + CSR13);
 		outl(0x0000, ioaddr + CSR14);
 		break;
+#ifdef CONFIG_OBS2xx
+	case X3201_3:
+		outl(0x0008, ioaddr + CSR15);
+		udelay(5);  /* The delays are Xircom recommended to give the
+					 * chipset time to reset the actual hardware
+					 * on the PCMCIA card
+					 */
+		outl(0xa8050000, ioaddr + CSR15);
+		udelay(5);
+		outl(0xa00f0000, ioaddr + CSR15);
+		udelay(5);
+		outl_CSR6(0x32000200, ioaddr, chip_idx);
+		break;
+#endif
 	case LC82C168:
 		if ( ! tp->mii_cnt) {
 			tp->nway = 1;
diff -Naru linux-2.4.28.orig/drivers/scsi/aic7xxx/aic7xxx_osm.h linux-2.4.28/drivers/scsi/aic7xxx/aic7xxx_osm.h
--- linux-2.4.28.orig/drivers/scsi/aic7xxx/aic7xxx_osm.h	2003-08-25 20:44:42.000000000 +0900
+++ linux-2.4.28/drivers/scsi/aic7xxx/aic7xxx_osm.h	2005-01-31 11:52:56.000000000 +0900
@@ -85,8 +85,8 @@
 
 /* Core SCSI definitions */
 #define AIC_LIB_PREFIX ahc
-#include "scsi.h"
-#include "hosts.h"
+#include "../scsi.h"
+#include "../hosts.h"
 
 /* Name space conflict with BSD queue macros */
 #ifdef LIST_HEAD
diff -Naru linux-2.4.28.orig/include/asm-ppc/commproc.h linux-2.4.28/include/asm-ppc/commproc.h
--- linux-2.4.28.orig/include/asm-ppc/commproc.h	2003-11-29 03:26:21.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/commproc.h	2005-01-31 11:52:56.000000000 +0900
@@ -13,6 +13,10 @@
  * bytes of the DP RAM and relocates the I2C parameter area to the
  * IDMA1 space.  The remaining DP RAM is available for buffer descriptors
  * or other use.
+ * 
+ * for OpenBlockS 50
+ * Copyright (C) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ * 
  */
 #ifndef __CPM_8XX__
 #define __CPM_8XX__
@@ -600,6 +604,29 @@
 #define SICR_ENET_CLKRT	((uint)0x00260000)
 #endif	/* CONFIG_SM850 */
 
+/***  OpenBlockS  ****************************************************/
+
+#ifdef CONFIG_OBS50
+
+/*
+ * for OpenBlockS
+ * Copyright (C) 2000-2002 MURASE Katsunori. <katsunori.murase@nifty.ne.jp>
+ * 
+ * This ENET stuff is for the MPC860 with ethernet on SCC2.
+ * This is unique to the OpenBlockS.
+ */
+#define PA_ENET_RXD	((ushort)0x0004)
+#define PA_ENET_TXD	((ushort)0x0008)
+#define PA_ENET_TCLK	((ushort)0x0100)
+#define PA_ENET_RCLK	((ushort)0x0200)
+#define PB_ENET_TENA	((uint)0x00002000)
+#define PC_ENET_CLSN	((ushort)0x0040)
+#define PC_ENET_RENA	((ushort)0x0080)
+
+#define SICR_ENET_MASK	((uint)0x0000ff00)
+#define SICR_ENET_CLKRT	((uint)0x00002c00)	/* RCLK:TCLK = CLK2:CLK1 */
+#endif /* CONFIG_OBS50 */
+
 /*********************************************************************/
 
 /* SCC Event register as used by Ethernet.
diff -Naru linux-2.4.28.orig/include/asm-ppc/ibm4xx.h linux-2.4.28/include/asm-ppc/ibm4xx.h
--- linux-2.4.28.orig/include/asm-ppc/ibm4xx.h	2004-04-14 22:05:40.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/ibm4xx.h	2005-01-31 11:52:56.000000000 +0900
@@ -8,6 +8,11 @@
  *	A generic include file which pulls in appropriate include files
  *      for specific board types based on configuration settings.
  *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Added CONFIG_OBS200
+ *		- Added CONFIG_EBK405GPR
+ *		- Added CONFIG_OBS266
+ *
  */
 
 #ifdef __KERNEL__
@@ -82,6 +87,18 @@
 #include <platforms/walnut.h>
 #endif
 
+#if defined(CONFIG_EBK405GPR)
+#include <platforms/ebk405gpr.h>
+#endif
+
+#if defined(CONFIG_OBS200)
+#include <platforms/obs200.h>
+#endif
+
+#if defined(CONFIG_OBS266)
+#include <platforms/obs266.h>
+#endif
+
 #ifndef PPC4xx_MACHINE_NAME
 #define PPC4xx_MACHINE_NAME	"Unidentified 4xx class"
 #endif
diff -Naru linux-2.4.28.orig/include/asm-ppc/ibm_ocp_gpio.h linux-2.4.28/include/asm-ppc/ibm_ocp_gpio.h
--- linux-2.4.28.orig/include/asm-ppc/ibm_ocp_gpio.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/ibm_ocp_gpio.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,58 @@
+/*
+ * FILE NAME ibm_ocp_gpio.h
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Generic gpio.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __IBM_OCP_GPIO_H
+#define __IBM_OCP_GPIO_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#define IBMGPIO_IOCTL_BASE	'Z'
+
+struct ocp_gpio_ioctl_data {
+	__u32 device;
+	__u32 mask;
+	__u32 data;
+};
+
+#define GPIO_MINOR             185
+#define IBMGPIO_IN		_IOWR(IBMGPIO_IOCTL_BASE, 0, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_OUT		_IOW (IBMGPIO_IOCTL_BASE, 1, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_OPEN_DRAIN	_IOW (IBMGPIO_IOCTL_BASE, 2, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_TRISTATE	_IOW (IBMGPIO_IOCTL_BASE, 3, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_CFG		_IOW (IBMGPIO_IOCTL_BASE, 4, struct ocp_gpio_ioctl_data)
+
+#endif
diff -Naru linux-2.4.28.orig/include/asm-ppc/ide.h linux-2.4.28/include/asm-ppc/ide.h
--- linux-2.4.28.orig/include/asm-ppc/ide.h	2003-06-13 23:51:38.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/ide.h	2005-01-31 11:52:56.000000000 +0900
@@ -3,6 +3,9 @@
  *
  *  Copyright (C) 1994-1996 Linus Torvalds & authors */
 
+/*	PlatHome <openlab@plathome.co.jp>
+ *		- Added for OpenBlockS 50
+ */
 /*
  *  This file contains the ppc architecture specific IDE code.
  */
@@ -110,6 +113,9 @@
  */
 #if (defined CONFIG_APUS || defined CONFIG_BLK_DEV_MPC8xx_IDE )
 #define IDE_ARCH_ACK_INTR 1
+#ifdef CONFIG_OBS50
+#define ide_ack_intr(hwif) (hwif->hw.ack_intr ? hwif->hw.ack_intr(hwif) : 1)
+#endif
 #endif
 
 #endif /* __KERNEL__ */
diff -Naru linux-2.4.28.orig/include/asm-ppc/io.h linux-2.4.28/include/asm-ppc/io.h
--- linux-2.4.28.orig/include/asm-ppc/io.h	2003-11-29 03:26:21.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/io.h	2005-01-31 11:52:56.000000000 +0900
@@ -73,10 +73,17 @@
  */
 #define insb(port, buf, ns)	_insb((u8 *)((port)+_IO_BASE), (buf), (ns))
 #define outsb(port, buf, ns)	_outsb((u8 *)((port)+_IO_BASE), (buf), (ns))
+#ifdef CONFIG_OBS50
+#define insw(port, buf, ns)	_insw((u16 *)((port)+_IO_BASE), (buf), (ns))
+#define outsw(port, buf, ns)	_outsw((u16 *)((port)+_IO_BASE), (buf), (ns))
+#define insl(port, buf, nl)	_insl((u32 *)((port)+_IO_BASE), (buf), (nl))
+#define outsl(port, buf, nl)	_outsl((u32 *)((port)+_IO_BASE), (buf), (nl))
+#else
 #define insw(port, buf, ns)	_insw_ns((u16 *)((port)+_IO_BASE), (buf), (ns))
 #define outsw(port, buf, ns)	_outsw_ns((u16 *)((port)+_IO_BASE), (buf), (ns))
 #define insl(port, buf, nl)	_insl_ns((u32 *)((port)+_IO_BASE), (buf), (nl))
 #define outsl(port, buf, nl)	_outsl_ns((u32 *)((port)+_IO_BASE), (buf), (nl))
+#endif
 
 #ifdef CONFIG_ALL_PPC
 /*
@@ -150,6 +157,18 @@
 #define inl(port)		in_be32((u32 *)((port)+_IO_BASE))
 #define outl(val, port)		out_be32((u32 *)((port)+_IO_BASE), (val))
 
+#elif defined(CONFIG_OBS50)
+extern unsigned char IN_BYTE(unsigned long port);
+extern void OUT_BYTE(unsigned char dat, unsigned long port);
+#define	HAVE_ARCH_OUT_BYTE
+#define	HAVE_ARCH_IN_BYTE
+#define inb(port)		IN_BYTE((port)+_IO_BASE)
+#define outb(dat,port)		OUT_BYTE((dat), (port)+_IO_BASE)
+#define inw(port)		in_le16((u16 *)((port)+_IO_BASE))
+#define outw(val, port)		out_le16((u16 *)((port)+_IO_BASE), (val))
+#define inl(port)		in_le32((u32 *)((port)+_IO_BASE))
+#define outl(val, port)		out_le32((u32 *)((port)+_IO_BASE), (val))
+
 #else /* not APUS or ALL_PPC */
 #define inb(port)		in_8((u8 *)((port)+_IO_BASE))
 #define outb(val, port)		out_8((u8 *)((port)+_IO_BASE), (val))
diff -Naru linux-2.4.28.orig/include/asm-ppc/ioctls.h linux-2.4.28/include/asm-ppc/ioctls.h
--- linux-2.4.28.orig/include/asm-ppc/ioctls.h	2003-06-13 23:51:38.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/ioctls.h	2005-01-31 11:52:56.000000000 +0900
@@ -1,3 +1,10 @@
+/*
+ * BK Id: %F% %I% %G% %U% %#%
+ */
+/*
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- added UPS control for OpenBlockS 266
+ */
 #ifndef _ASM_PPC_IOCTLS_H
 #define _ASM_PPC_IOCTLS_H
 
@@ -105,4 +112,11 @@
 #define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
 #define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
 
+#ifdef CONFIG_OBS266
+#define	UPSIOINIT	_IOW('U', 0x30, int)	/* initialize UPS func */
+#define	UPSIOSTART	_IOW('U', 0x31, int)	/* start UPS func */
+#define	UPSIOSTOP	_IOW('U', 0x32, int)	/* stop UPS func */
+#define	UPSIOTIME	_IOW('U', 0x33, int)	/* set ups timeout */
+#endif
+
 #endif /* _ASM_PPC_IOCTLS_H */
diff -Naru linux-2.4.28.orig/include/asm-ppc/mpc8xx.h linux-2.4.28/include/asm-ppc/mpc8xx.h
--- linux-2.4.28.orig/include/asm-ppc/mpc8xx.h	2003-11-29 03:26:21.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/mpc8xx.h	2005-01-31 11:52:56.000000000 +0900
@@ -3,6 +3,10 @@
  * we have a unique include file for each.  Rather than change every
  * file that has to include MPC8xx configuration, they all include
  * this one and the configuration switching is done here.
+ *
+ * 	PlatHome<openlab@plathome.co.jp>
+ *		- Added for OpenBlockS 50
+ *
  */
 #ifdef __KERNEL__
 #ifndef __CONFIG_8xx_DEFS
@@ -48,6 +52,9 @@
 #include <platforms/ivms8.h>
 #endif
 
+#if defined(CONFIG_OBS50)
+#include <platforms/obs50.h>
+#endif
 
 /* The PCI_ISA_IO_ADDR, PCI_ISA_MEM_ADDR, and PCI_DRAM_OFFSET macros
  * must be defined in the board-specific header file for targets that
diff -Naru linux-2.4.28.orig/include/asm-ppc/ocp.h linux-2.4.28/include/asm-ppc/ocp.h
--- linux-2.4.28.orig/include/asm-ppc/ocp.h	2004-04-14 22:05:40.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/ocp.h	2005-01-31 11:52:56.000000000 +0900
@@ -110,6 +110,7 @@
 	unsigned int	function;
 	int		index;
 	phys_addr_t	paddr;
+	void *		vaddr;
 	int	  	irq;
 	unsigned long	pm;
 	void		*additions;
@@ -145,7 +146,7 @@
 };
 
 /* Similar to the helpers above, these manipulate per-ocp_dev
- * driver-specific data.  Currently stored as ocp_dev::ocpdev,
+ * driver-specific data.  Currently stored as ocp_dev::drvdata,
  * a void pointer, but it is not present on older kernels.
  */
 static inline void *
@@ -203,5 +204,58 @@
 /* Remove a device by index */
 extern int ocp_remove_one_device(unsigned int vendor, unsigned int function, int index);
 
+/*
+ * a helper function which helps ensure correct pci_driver
+ * setup and cleanup for commonly-encountered hotplug/modular cases
+ *
+ * This MUST stay in a header, as it checks for -DMODULE
+ */
+static inline int ocp_module_init(struct ocp_driver *drv)
+{
+	int rc = ocp_register_driver(drv);
+
+	if (rc > 0)
+		return 0;
+
+	/* iff CONFIG_HOTPLUG and built into kernel, we should
+	 * leave the driver around for future hotplug events.
+	 * For the module case, a hotplug daemon of some sort
+	 * should load a module in response to an insert event. */
+#if defined(CONFIG_HOTPLUG) && !defined(MODULE)
+	if (rc == 0)
+		return 0;
+#else
+	if (rc == 0)
+		rc = -ENODEV;		
+#endif
+
+	/* if we get here, we need to clean up pci driver instance
+	 * and return some sort of error */
+	ocp_unregister_driver (drv);
+	
+	return rc;
+}
+
+#if defined (CONFIG_PM)
+/*
+ * This is right for the IBM 405 and 440 but will need to be
+ * generalized if the OCP stuff gets used on other processors.
+ */
+static inline void
+ocp_force_power_off(struct ocp_device *odev)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | odev->pm);
+}
+
+static inline void
+ocp_force_power_on(struct ocp_device *odev)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~odev->pm);
+}
+#else
+#define ocp_force_power_off(x)	(void)(x)
+#define ocp_force_power_on(x)	(void)(x)
+#endif
+
 #endif				/* __OCP_H__ */
 #endif				/* __KERNEL__ */
diff -Naru linux-2.4.28.orig/include/asm-ppc/pgtable.h linux-2.4.28/include/asm-ppc/pgtable.h
--- linux-2.4.28.orig/include/asm-ppc/pgtable.h	2004-02-18 22:36:32.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/pgtable.h	2005-01-31 11:52:56.000000000 +0900
@@ -1,3 +1,10 @@
+/*
+ * BK Id: %F% %I% %G% %U% %#%
+ *
+ *	PlatHome <openlab.plathome.co.jp>
+ *		by yhirano@mbc.nifty.com
+ *
+ */
 #ifdef __KERNEL__
 #ifndef _PPC_PGTABLE_H
 #define _PPC_PGTABLE_H
@@ -629,11 +636,25 @@
  * must not include the _PAGE_PRESENT bit, or the _PAGE_HASHPTE bit
  * (if used).  -- paulus
  */
+#if defined(CONFIG_OBS2xx)
+#define SWP_TYPE(entry)			((entry).val & 0x3f)
+#define SWP_OFFSET(entry)		((entry).val >> 10)
+#define SWP_ENTRY(type, offset)		((swp_entry_t) { (type) | ((offset) << 10) })
+#define pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 2 })
+#define swp_entry_to_pte(x)		((pte_t) { (x).val << 2 })
+#elif defined(CONFIG_OBS50)
+#define SWP_TYPE(entry)			((entry).val & 0x3f)
+#define SWP_OFFSET(entry)		((entry).val >> 6)
+#define SWP_ENTRY(type, offset)		((swp_entry_t) { (type) | ((offset) << 6) })
+#define pte_to_swp_entry(pte)		((swp_entry_t) { (pte_val(pte) & ~_PAGE_ACCESSED) >> 2 })
+#define swp_entry_to_pte(x)		((pte_t) { (x).val << 2 })
+#else
 #define SWP_TYPE(entry)			((entry).val & 0x3f)
 #define SWP_OFFSET(entry)		((entry).val >> 6)
 #define SWP_ENTRY(type, offset)		((swp_entry_t) { (type) | ((offset) << 6) })
 #define pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 2 })
 #define swp_entry_to_pte(x)		((pte_t) { (x).val << 2 })
+#endif
 
 /* CONFIG_APUS */
 /* For virtual address to physical address conversion */
diff -Naru linux-2.4.28.orig/include/asm-ppc/ppcboot.h linux-2.4.28/include/asm-ppc/ppcboot.h
--- linux-2.4.28.orig/include/asm-ppc/ppcboot.h	2004-04-14 22:05:40.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/ppcboot.h	2005-01-31 11:52:56.000000000 +0900
@@ -16,6 +16,9 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
+ *
+ * 	PlatHome <openlab@plathome.co.jp>
+ *		- Added for OpenBlockS 50
  */
 
 #ifndef __ASM_PPCBOOT_H__
@@ -84,6 +87,9 @@
 	unsigned char	bi_enet1addr[6];
 	unsigned char	bi_enet2addr[6];
 #endif
+#if defined(CONFIG_OBS50)
+	unsigned char	bi_enet1addr[6]; /* 2nd Ethernet address */
+#endif
 	mon_fnc_t	*bi_mon_fnc;	/* Pointer to monitor functions	*/
 } bd_t;
 
diff -Naru linux-2.4.28.orig/include/asm-ppc/pushsw_obs2xx.h linux-2.4.28/include/asm-ppc/pushsw_obs2xx.h
--- linux-2.4.28.orig/include/asm-ppc/pushsw_obs2xx.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/pushsw_obs2xx.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,19 @@
+/*
+ *	Century <www.centurysys.co.jp>
+ *		- Century's push switch driver header
+ */
+
+#include <linux/ioctl.h>
+#include <linux/major.h>
+/* #include <linux/miscdevice.h> */
+
+#define PUSHSW_MAJOR		(MISC_MAJOR)
+
+#define	PUSHSW_IOCTL_BASE	'P'
+
+#define	PSWIOC_GETSTATUS	_IOR(PUSHSW_IOCTL_BASE, 0, int)
+#define	PSWIOC_WAITPUSH		_IOR(PUSHSW_IOCTL_BASE, 1, int)
+#define	PSWIOC_GETWAITPID	_IOR(PUSHSW_IOCTL_BASE, 2, int)
+
+#define PSWIOF_PUSHED		(1)
+#define PSWIOF_NOTPUSHED	(0)
diff -Naru linux-2.4.28.orig/include/asm-ppc/segled_obs200.h linux-2.4.28/include/asm-ppc/segled_obs200.h
--- linux-2.4.28.orig/include/asm-ppc/segled_obs200.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.4.28/include/asm-ppc/segled_obs200.h	2005-01-31 11:52:56.000000000 +0900
@@ -0,0 +1,62 @@
+/*
+ * 	Century <www.centurysys.co.jp>
+ *		- Header for Century's 7 segment LED driver
+ *
+ */
+
+#include <linux/ioctl.h>
+#include <linux/major.h>
+/* #include <linux/miscdevice.h> */
+
+#define SEGLED_MAJOR		(MISC_MAJOR)
+
+#define	SEGLED_IOCTL_BASE	'S'
+
+#define	SLIOC_TEST		_IOR(SEGLED_IOCTL_BASE, 0, int)
+#define	SLIOC_SETVAL		_IOR(SEGLED_IOCTL_BASE, 1, int)
+#define	SLIOC_SETSEG		_IOR(SEGLED_IOCTL_BASE, 2, int)
+#define SLIOC_GET_OWNER_PID	_IOR(SEGLED_IOCTL_BASE, 3, int)
+#define SLIOC_RESERVE		_IOR(SEGLED_IOCTL_BASE, 4, int)
+#define	SLIOC_TEST405		_IOR(SEGLED_IOCTL_BASE, 5, int)
+
+/* @@ MA 360 boards
+#define SL_A	(0x01)
+#define SL_B	(0x02)
+#define SL_C	(0x80)
+#define SL_D	(0x20)
+#define SL_E	(0x40)
+#define SL_F	(0x04)
+#define SL_G	(0x08)
+#define SL_DP	(0x10)
+#define SL_NONE	(0x00)
+#define SL_ALL	(SL_A | SL_B | SL_C | SL_D | SL_E | SL_F | SL_G | SL_DP)
+*/
+
+/* @@ MA 300 */
+#define SL_A	(0x08)
+#define SL_B	(0x04)
+#define SL_C	(0x01)
+#define SL_D	(0x10)
+#define SL_E	(0x20)
+#define SL_F	(0x02)
+#define SL_G	(0x80)
+#define SL_DP	(0x40)
+#define SL_NONE	(0x00)
+#define SL_ALL	(SL_A | SL_B | SL_C | SL_D | SL_E | SL_F | SL_G | SL_DP)
+
+#define SL_V0	(SL_A | SL_B | SL_C | SL_D | SL_E | SL_F)
+#define SL_V1	(SL_B | SL_C)
+#define SL_V2	(SL_A | SL_B | SL_D | SL_E | SL_G)
+#define SL_V3	(SL_A | SL_B | SL_C | SL_D | SL_G)
+#define SL_V4	(SL_B | SL_C | SL_F | SL_G)
+#define SL_V5	(SL_C | SL_F | SL_A | SL_G | SL_D)
+#define SL_V6	(SL_C | SL_F | SL_A | SL_G | SL_E | SL_D)
+#define SL_V7	(SL_C | SL_F | SL_B | SL_A)
+#define SL_V8	(SL_A | SL_B | SL_C | SL_D | SL_E | SL_F | SL_G)
+#define SL_V9	(SL_A | SL_B | SL_C | SL_D | SL_F | SL_G)
+#define SL_VA	(SL_A | SL_B | SL_C | SL_E | SL_F | SL_G)
+#define SL_VB	(SL_C | SL_F | SL_G | SL_E | SL_D)
+#define SL_VC	(SL_F | SL_A | SL_E | SL_D)
+#define SL_VD	(SL_C | SL_B | SL_G | SL_E | SL_D)
+#define SL_VE	(SL_F | SL_A | SL_G | SL_E | SL_D)
+#define SL_VF	(SL_F | SL_A | SL_G | SL_E)
diff -Naru linux-2.4.28.orig/include/linux/i2c-id.h linux-2.4.28/include/linux/i2c-id.h
--- linux-2.4.28.orig/include/linux/i2c-id.h	2004-02-18 22:36:32.000000000 +0900
+++ linux-2.4.28/include/linux/i2c-id.h	2005-01-31 11:52:56.000000000 +0900
@@ -156,6 +156,8 @@
 
 #define I2C_ALGO_SGI	0x130000	/* SGI algorithm		*/
 
+#define	I2C_ALGO_OCP	0x140000	/* IBM or otherwize On-Chip I2C algorithm */
+
 #define I2C_ALGO_EXP	0x800000	/* experimental			*/
 
 #define I2C_ALGO_MASK	0xff0000	/* Mask for algorithms		*/
@@ -197,6 +199,9 @@
 /* --- MPC8xx PowerPC adapters						*/
 #define I2C_HW_MPC8XX_EPON 0x00	/* Eponymous MPC8xx I2C adapter 	*/
 
+/* --- PowerPC on-chip I2C adapter					*/
+#define	I2C_HW_OCP	0x00	/* IBM on-chip I2C adapter	*/
+
 /* --- Broadcom SiByte adapters						*/
 #define I2C_HW_SIBYTE	0x00
 
diff -Naru linux-2.4.28.orig/include/linux/i2c.h linux-2.4.28/include/linux/i2c.h
--- linux-2.4.28.orig/include/linux/i2c.h	2004-02-18 22:36:32.000000000 +0900
+++ linux-2.4.28/include/linux/i2c.h	2005-01-31 11:52:56.000000000 +0900
@@ -546,5 +546,25 @@
 #define i2c_is_isa_adapter(adapptr) \
         ((adapptr)->algo->id == I2C_ALGO_ISA)
 
-#endif /* def __KERNEL__ */
-#endif /* I2C_H */
+static inline void *i2c_get_clientdata (struct i2c_client *dev)
+{
+	return dev->data;
+}
+
+static inline void i2c_set_clientdata (struct i2c_client *dev, void *data)
+{
+	dev->data = data;
+}
+
+static inline void *i2c_get_adapdata (struct i2c_adapter *dev)
+{
+	return dev->data;
+}
+
+static inline void i2c_set_adapdata (struct i2c_adapter *dev, void *data)
+{
+	dev->data = data;
+}
+
+#endif
+#endif /* _LINUX_I2C_H */
diff -Naru linux-2.4.28.orig/include/linux/miscdevice.h linux-2.4.28/include/linux/miscdevice.h
--- linux-2.4.28.orig/include/linux/miscdevice.h	2003-06-13 23:51:38.000000000 +0900
+++ linux-2.4.28/include/linux/miscdevice.h	2005-01-31 11:52:56.000000000 +0900
@@ -1,3 +1,7 @@
+/*
+	PlatHome <openlab.plathome.co.jp>
+		- Added PUSHSW_MINOR, SEGLED_MINOR for OpenBlockS
+*/
 #ifndef _LINUX_MISCDEVICE_H
 #define _LINUX_MISCDEVICE_H
 
@@ -22,6 +26,8 @@
 #define SUN_OPENPROM_MINOR	139
 #define NVRAM_MINOR		144
 #define I2O_MINOR		166
+#define PUSHSW_MINOR	170
+#define SEGLED_MINOR	171
 #define MICROCODE_MINOR		184
 #define MWAVE_MINOR		219	/* ACP/Mwave Modem */
 #define MPT_MINOR		220
diff -Naru linux-2.4.28.orig/include/linux/netfilter_ipv4/ip_tables.h linux-2.4.28/include/linux/netfilter_ipv4/ip_tables.h
--- linux-2.4.28.orig/include/linux/netfilter_ipv4/ip_tables.h	2004-08-08 08:26:06.000000000 +0900
+++ linux-2.4.28/include/linux/netfilter_ipv4/ip_tables.h	2005-01-31 11:52:56.000000000 +0900
@@ -283,8 +283,6 @@
 	struct ipt_entry entrytable[0];
 };
 
-extern struct semaphore ipt_mutex;
-
 /* Standard return verdict, or do jump. */
 #define IPT_STANDARD_TARGET ""
 /* Error verdict. */
@@ -336,9 +334,12 @@
 /*
  *	Main firewall chains definitions and global var's definitions.
  */
-static DECLARE_MUTEX(ipt_mutex);
 #ifdef __KERNEL__
 
+extern struct semaphore ipt_mutex;
+
+static DECLARE_MUTEX(ipt_mutex);
+
 #include <linux/init.h>
 extern void ipt_init(void) __init;
 
diff -Naru linux-2.4.28.orig/include/linux/netfilter_ipv6/ip6_tables.h linux-2.4.28/include/linux/netfilter_ipv6/ip6_tables.h
--- linux-2.4.28.orig/include/linux/netfilter_ipv6/ip6_tables.h	2004-08-08 08:26:06.000000000 +0900
+++ linux-2.4.28/include/linux/netfilter_ipv6/ip6_tables.h	2005-01-31 11:52:56.000000000 +0900
@@ -106,8 +106,6 @@
 	u_int64_t pcnt, bcnt;			/* Packet and byte counters */
 };
 
-static DECLARE_MUTEX(ip6t_mutex);
-
 /* Values for "flag" field in struct ip6t_ip6 (general ip6 structure). */
 #define IP6T_F_PROTO		0x01	/* Set if rule cares about upper 
 					   protocols */
@@ -345,6 +343,8 @@
 
 #ifdef __KERNEL__
 
+static DECLARE_MUTEX(ip6t_mutex);
+
 #include <linux/init.h>
 extern void ip6t_init(void) __init;
 
diff -Naru linux-2.4.28.orig/init/do_mounts.c linux-2.4.28/init/do_mounts.c
--- linux-2.4.28.orig/init/do_mounts.c	2003-11-29 03:26:21.000000000 +0900
+++ linux-2.4.28/init/do_mounts.c	2005-01-31 11:52:56.000000000 +0900
@@ -1,3 +1,12 @@
+/*
+	ozawa CONFIG_OBSS
+	PlatHome <openlab.plathome.co.jp>
+		- Modified CONFIG_OBSS to CONFIG_OBS200
+		- Added do_restore()
+		- write able root mount if load user configuration
+		  in prepare_namespace()
+		- Added for CONFIG_OBS266, ONFIG_OBS2xx, ONFIG_OBS50 
+*/
 #define __KERNEL_SYSCALLS__
 #include <linux/config.h>
 #include <linux/slab.h>
@@ -8,6 +17,10 @@
 #include <linux/fd.h>
 #include <linux/tty.h>
 #include <linux/init.h>
+#ifdef CONFIG_OBS200
+#include <asm/io.h>
+#include <asm/bugs.h>
+#endif
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
@@ -16,6 +29,14 @@
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
 #include <linux/cramfs_fs.h>
+#ifdef CONFIG_OBS200
+#include <asm/segled_obs200.h>
+#define OPNT ((volatile unsigned char *)(0x40000000))
+#endif
+#ifdef CONFIG_OBS50
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+#endif
 
 #define BUILD_CRAMDISK
 
@@ -490,6 +511,16 @@
 	int nblocks = -1;
 	unsigned char *buf;
 
+#ifdef CONFIG_OBS50
+	printk("check dipsw:   ");
+	if ((((immap_t *)IMAP_ADDR)->im_ioport.iop_padat & 0xc000) != 0x0000) {
+		printk("hdroot\n");
+		/* image could not be found. */
+		return -1;
+	} else {
+		printk("ramroot\n");
+	}
+#endif
 	buf = kmalloc(size, GFP_KERNEL);
 	if (buf == 0)
 		return -1;
@@ -577,8 +608,12 @@
 
 #ifdef CONFIG_BLK_DEV_RAM
 	int in_fd, out_fd;
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+	int nblocks, rd_blocks, devblocks, i;
+#else
 	unsigned long rd_blocks, devblocks;
 	int nblocks, i;
+#endif
 	char *buf;
 	unsigned short rotate = 0;
 #if !defined(CONFIG_ARCH_S390) && !defined(CONFIG_PPC_ISERIES)
@@ -622,7 +657,7 @@
 
 	if (nblocks > rd_blocks) {
 		printk("RAMDISK: image too big! (%d/%lu blocks)\n",
-		       nblocks, rd_blocks);
+		       nblocks, (unsigned long)rd_blocks);
 		goto done;
 	}
 		
@@ -648,11 +683,15 @@
 		goto done;
 	}
 
+#ifdef CONFIG_OBS200
+	*OPNT = (unsigned char)~(SL_V5);
+#endif
+
 	printk(KERN_NOTICE "RAMDISK: Loading %d blocks [%ld disk%s] into ram disk... ", 
-		nblocks, ((nblocks-1)/devblocks)+1, nblocks>devblocks ? "s" : "");
+		nblocks, (long)((nblocks-1)/devblocks)+1, nblocks>devblocks ? "s" : "");
 	for (i=0; i < nblocks; i++) {
 		if (i && (i % devblocks == 0)) {
-			printk("done disk #%ld.\n", i/devblocks);
+			printk("done disk #%ld.\n", (long)i/devblocks);
 			rotate = 0;
 			if (close(in_fd)) {
 				printk("Error closing the disk.\n");
@@ -664,7 +703,7 @@
 				printk("Error opening disk.\n");
 				goto noclose_input;
 			}
-			printk("Loading disk #%ld... ", i/devblocks+1);
+			printk("Loading disk #%ld... ", (long)i/devblocks+1);
 		}
 		read(in_fd, buf, BLOCK_SIZE);
 		write(out_fd, buf, BLOCK_SIZE);
@@ -808,7 +847,33 @@
 	return execve(shell, argv, envp_init);
 }
 
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+static int do_restore(void *shell)
+{
+	static char *argv[] = { "flashcfg",
+#if defined(CONFIG_OBS266)
+				"-x",
+#endif
+				NULL, };
+	extern char *envp_init[];
+
+#ifdef CONFIG_OBS266
+	close(old_fd);
+	close(root_fd);
 #endif
+	close(0);
+	close(1);
+	close(2);
+	setsid();
+	(void) open("/dev/console",O_RDWR,0);
+	(void) dup(0);
+	(void) dup(0);
+	execve(shell, argv, envp_init);
+	printk("[do_restore] Error starting restore thread!\n");
+	return (-1);
+}
+#endif /* CONFIG_OBS2xx || CONFIG_OBS50 */
+#endif /* CONFIG_BLK_DEV_INITRD */
 
 static void __init handle_initrd(void)
 {
@@ -893,6 +958,11 @@
 	extern void arch_discover_root(void);
 	arch_discover_root();
 #endif /* CONFIG_ALL_PPC */
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+	bd_t *bip = (bd_t *)__res;
+	int real_root_mountflags;
+#endif
+
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (!initrd_start)
 		mount_initrd = 0;
@@ -914,12 +984,52 @@
 		}
 	} else if (is_floppy && rd_doload && rd_load_disk(0))
 		ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+	/* write able root mount if load user configuration from flash necessary. */
+#if defined(CONFIG_OBS2xx)
+	if (bip->bi_r_version[0] && mount_initrd) {
+#else
+	if (mount_initrd) {
+#endif
+		real_root_mountflags = root_mountflags;
+		root_mountflags &= ~MS_RDONLY;
+	}
+#endif
 	mount_root();
 out:
 	sys_umount("/dev", 0);
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
 	mount_devfs_fs ();
+
+#ifdef CONFIG_OBS200
+	*OPNT = (unsigned char)~(SL_V4);
+#endif
+#if defined(CONFIG_OBS2xx) || defined(CONFIG_OBS50)
+
+	/*
+	 *	If initrd has been mounted, load user configuration
+	 *	from flash if necessary.
+	 */
+#if defined(CONFIG_OBS266)
+	if (bip->bi_s_version[0] && mount_initrd) {
+#else
+	if (mount_initrd) {
+#endif
+		root_mountflags = real_root_mountflags;
+		printk("[prepare_namespace] Executing flashcfg...\n");
+		if ((MAJOR(ROOT_DEV) == RAMDISK_MAJOR) && (MINOR(ROOT_DEV) == 0)) {
+			int pid,i;
+			pid = kernel_thread(do_restore, "/usr/sbin/flashcfg", SIGCHLD);
+			if (pid > 0) {
+				while (pid != wait(&i));
+			}
+			else printk("[prepare_namespace] Error starting restore thread!\n");
+		}
+		printk("[prepare_namespace] Finished executing flashcfg\n");
+	}
+#endif /* CONFIG_OBS2xx || CONFIG_OBS50 */
 }
 
 #ifdef CONFIG_BLK_DEV_RAM
diff -Naru linux-2.4.28.orig/init/main.c linux-2.4.28/init/main.c
--- linux-2.4.28.orig/init/main.c	2004-11-17 20:54:22.000000000 +0900
+++ linux-2.4.28/init/main.c	2005-01-31 11:52:56.000000000 +0900
@@ -7,6 +7,15 @@
  *  Added initrd & change_root: Werner Almesberger & Hans Lermen, Feb '96
  *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May '96
  *  Simplified starting of init:  Michael A. Griffith <grif@acm.org> 
+ *
+ *	Century <www.centurysys.co.jp>
+ *		- Added LED display
+ *		- Added recovery mode handling
+ *	2001-12-25 ozawa CONFIG_OBSS
+ *	PlatHome <openlab.plathome.co.jp>
+ *		- Modified CONFIG_OBSS to CONFIG_OBS200
+ *		- Added for OpenBlockS 266
+ *
  */
 
 #define __KERNEL_SYSCALLS__
@@ -31,6 +40,10 @@
 
 #include <asm/io.h>
 #include <asm/bugs.h>
+#if defined(CONFIG_OBS200)
+#include <asm/segled_obs200.h>
+#define OPNT ((volatile unsigned char *)(0x40000000))
+#endif
 
 #if defined(CONFIG_ARCH_S390)
 #include <asm/s390mach.h>
@@ -117,6 +130,10 @@
 extern void ipc_init(void);
 #endif
 
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+extern int obsled_out(int);
+#endif
+
 /*
  * Boot command-line arguments
  */
@@ -131,7 +148,11 @@
 char *execute_command;
 
 static char * argv_init[MAX_INIT_ARGS+2] = { "init", NULL, };
+#if defined(CONFIG_OBS200)
+char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=vt100", NULL, };
+#else
 char * envp_init[MAX_INIT_ENVS+2] = { "HOME=/", "TERM=linux", NULL, };
+#endif
 
 static int __init profile_setup(char *str)
 {
@@ -364,6 +385,9 @@
  * enable them
  */
 	lock_kernel();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	obsled_out(2);
+#endif
 	printk(linux_banner);
 	setup_arch(&command_line);
 	printk("Kernel command line: %s\n", saved_command_line);
@@ -471,6 +495,9 @@
  */
 static void __init do_basic_setup(void)
 {
+#if defined(CONFIG_OBS200)
+	*OPNT = (unsigned char)~(SL_V2);
+#endif
 
 	/*
 	 * Tell the world that we're going to be the grim
@@ -563,9 +590,15 @@
 {
 	struct files_struct *files;
 	lock_kernel();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	obsled_out(3);
+#endif
 	do_basic_setup();
 
 	prepare_namespace();
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	obsled_out(5);
+#endif
 
 	/*
 	 * Ok, we have completed the initial bootup, and
@@ -598,6 +631,13 @@
 	 * trying to recover a really broken machine.
 	 */
 
+#if defined(CONFIG_OBS200)
+	*OPNT = (unsigned char)~(SL_V6);
+#endif
+#if defined(CONFIG_OBS266) && defined(CONFIG_OBS266_LED)
+	obsled_out(6);
+#endif
+
 	if (execute_command)
 		run_init_process(execute_command);
 
